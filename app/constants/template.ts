import type { FileMap } from '~/lib/stores/files';

export const TEMPLATE_BASIC_VITE_REACT = {
  'postcss.config.js': {
    type: 'file',
    content: 'export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n',
    isBinary: false,
  },
  'PROJECT.md': {
    type: 'file',
    content:
      "# [PROJECT TITLE]\n\n## Project Summary\n\n[THIS IS TEMPLATE PROJECT, PLEASE UPDATE HERE]\n\n## Implementation Strategy\n\n- [THIS IS TEMPLATE PROJECT, PLEASE UPDATE HERE]\n\n## Implemented Features\n\n- [THIS IS TEMPLATE PROJECT, PLEASE UPDATE HERE]\n\n## File Structure Overview\n\n### src/main.tsx\n\n- Entry point for the application\n- Sets up React rendering with React 18's createRoot API\n- Imports and applies global CSS\n\n### src/App.tsx\n\n- Root component of the application\n- Demonstrates basic React component structure\n- Shows how to handle state and events in a React component\n\n### src/App.css\n\n- Contains component-specific styles for the App component\n- Demonstrates how to use component-scoped CSS\n",
    isBinary: false,
  },
  'package.json': {
    type: 'file',
    content:
      '{\n  "name": "basic-vite-react",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "lint": "eslint .",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@agent8/gameserver": "^1.5.3",\n    "lucide-react": "^0.344.0",\n    "react": "^18.3.1",\n    "react-dom": "^18.3.1"\n  },\n  "devDependencies": {\n    "@types/react": "^18.2.33",\n    "@types/react-dom": "^18.2.11",\n    "@vitejs/plugin-react": "^4.3.4",\n    "globals": "^15.15.0",\n    "tailwindcss": "^3.4.1",\n    "autoprefixer": "^10.4.18",\n    "typescript": "~5.7.2",\n    "vite": "^6.2.0"\n  }\n}\n',
    isBinary: false,
  },
  '.gitignore': {
    type: 'file',
    content:
      '# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n',
    isBinary: false,
  },
  'index.html': {
    type: 'file',
    content:
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + React + TS</title>\n    <style>\n      body {\n        margin: 0;\n        padding: 0;\n        font-family: Arial, sans-serif;\n      }\n      .loading-container {\n        position: fixed;\n        inset: 0;\n        z-index: 50;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background-color: black;\n        color: white;\n      }\n      .loading-title {\n        font-size: 1.5rem;\n        font-weight: bold;\n        margin-bottom: 1rem;\n      }\n    </style>\n    <script>\n      (function () {\n        function reportGameSize() {\n          const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n\n          const width = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n\n          window.parent.postMessage(\n            {\n              type: \'GAME_SIZE_RESPONSE\',\n              height: height,\n              width: width,\n            },\n            \'*\',\n          );\n        }\n\n        window.addEventListener(\'load\', reportGameSize);\n\n        window.addEventListener(\'resize\', reportGameSize);\n\n        window.addEventListener(\'message\', function (event) {\n          if (event.data && event.data.type === \'REQUEST_GAME_SIZE\') {\n            reportGameSize();\n          }\n        });\n      })();\n    </script>\n  </head>\n  <body>\n    <div id="root">\n      <div class="loading-container">\n        <h2 class="loading-title">Loading</h2>\n        <p>Preparing...</p>\n      </div>\n    </div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    isBinary: false,
  },
  'tsconfig.app.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",\n    "target": "ES2020",\n    "useDefineForClassFields": true,\n    "lib": ["ES2020", "DOM", "DOM.Iterable"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n    "jsx": "react-jsx",\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["src"]\n}\n',
    isBinary: false,
  },
  'tsconfig.node.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",\n    "target": "ES2022",\n    "lib": ["ES2023"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["vite.config.ts"]\n}\n',
    isBinary: false,
  },
  'tailwind.config.js': {
    type: 'file',
    content:
      '/** @type {import(\'tailwindcss\').Config} */\nexport default {\n  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n',
    isBinary: false,
  },
  'vite.config.ts': {
    type: 'file',
    content:
      'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"],\n  },\n  base: "./",\n  build: {\n    outDir: "dist",\n  },\n});\n',
    isBinary: false,
  },
  'tsconfig.json': {
    type: 'file',
    content:
      '{\n  "files": [],\n  "references": [\n    { "path": "./tsconfig.app.json" },\n    { "path": "./tsconfig.node.json" }\n  ]\n}\n',
    isBinary: false,
  },
  'src/App.css': {
    type: 'file',
    content: '#root {\n  max-width: 1280px;\n  margin: 0 auto;\n  padding: 2rem;\n  text-align: center;\n}\n',
    isBinary: false,
  },
  'src/App.tsx': {
    type: 'file',
    content:
      'import { useState } from "react";\nimport "./App.css";\nfunction App() {\n  const [count, setCount] = useState(1);\n\n  return (\n    <>\n      <div className="card">\n        <button\n          onClick={() => setCount((count) => count + 1)}\n          className="bg-blue-500 text-white p-2 rounded-md"\n        >\n          Count is {count}\n        </button>\n      </div>\n    </>\n  );\n}\n\nexport default App;\n',
    isBinary: false,
  },
  'src/index.css': {
    type: 'file',
    content: '@tailwind base;\n@tailwind components;\n@tailwind utilities;\n',
    isBinary: false,
  },
  'src/main.tsx': {
    type: 'file',
    content:
      'import { StrictMode } from "react";\nimport { createRoot } from "react-dom/client";\nimport "./index.css";\nimport App from "./App.tsx";\n\ncreateRoot(document.getElementById("root")!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n',
    isBinary: false,
  },
  'src/assets.json': {
    type: 'file',
    content: '{ "images": {} }\n',
    isBinary: false,
  },
} as FileMap;

export const TEMPLATE_2D_PHASER_BASIC = {
  'PROJECT.md': {
    type: 'file',
    content:
      "# [PROJECT TITLE!]\n\n## Project Summary\n\n[THIS IS TEMPLATE PROJECT, PLEASE UPDATE HERE]\n\nThis project is a template project with a basic 2D. It is implemented using Phaser. It can be used to implement games like boardgame or simple 2d game.\n\n## Implementation Strategy\n\n- [THIS IS TEMPLATE PROJECT, PLEASE UPDATE HERE]\n\n## Implemented Features\n\n- [THIS IS TEMPLATE PROJECT, PLEASE UPDATE HERE]\n\n## File Structure Overview\n\n### src/main.tsx\n\n- Entry point for the application\n- Sets up React rendering with React 18's createRoot API\n- Imports and applies global CSS\n\n### src/App.tsx\n\n- Root component of the application\n- Responsible for loading the GameComponent.\n\n### src/components/GameComponent.tsx\n\n- Sets up the container to start Phaser in HTML and calls createGame from src/game/Game.ts.\n\n### src/game/Game.ts\n\n- Provides the createGame function, which executes `new Phaser.Game(config)` with Phaser settings.\n\n### src/game/scenes/MainScene.ts\n\n- Manages the main scene of the game.\n\n### src/App.css\n\n- Contains component-specific styles for the App component\n- Demonstrates how to use component-scoped CSS\n",
    isBinary: false,
  },
  'package.json': {
    type: 'file',
    content:
      '{\n  "name": "basic-vite-react",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "lint": "eslint .",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@agent8/gameserver": "^1.5.3",\n    "lucide-react": "^0.344.0",\n    "react": "^18.3.1",\n    "react-dom": "^18.3.1",\n    "phaser": "^3.87.0"\n  },\n  "devDependencies": {\n    "@types/react": "^18.2.33",\n    "@types/react-dom": "^18.2.11",\n    "@vitejs/plugin-react": "^4.3.4",\n    "globals": "^15.15.0",\n    "tailwindcss": "^3.4.1",\n    "autoprefixer": "^10.4.18",\n    "typescript": "~5.7.2",\n    "vite": "^6.2.0"\n  }\n}\n',
    isBinary: false,
  },
  'index.html': {
    type: 'file',
    content:
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + React + TS</title>\n    <style>\n      body {\n        margin: 0;\n        padding: 0;\n        font-family: Arial, sans-serif;\n      }\n      .loading-container {\n        position: fixed;\n        inset: 0;\n        z-index: 50;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background-color: black;\n        color: white;\n      }\n      .loading-title {\n        font-size: 1.5rem;\n        font-weight: bold;\n        margin-bottom: 1rem;\n      }\n      .spinner {\n        width: 30px;\n        height: 30px;\n        border: 3px solid rgba(255, 255, 255, 0.3);\n        border-radius: 50%;\n        border-top-color: white;\n        animation: spin 1s ease-in-out infinite;\n      }\n      @keyframes spin {\n        to {\n          transform: rotate(360deg);\n        }\n      }\n    </style>\n    <script>\n      (function () {\n        function reportGameSize() {\n          const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n\n          const width = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n\n          window.parent.postMessage(\n            {\n              type: \'GAME_SIZE_RESPONSE\',\n              height: height,\n              width: width,\n            },\n            \'*\',\n          );\n        }\n\n        window.addEventListener(\'load\', reportGameSize);\n\n        window.addEventListener(\'resize\', reportGameSize);\n\n        window.addEventListener(\'message\', function (event) {\n          if (event.data && event.data.type === \'REQUEST_GAME_SIZE\') {\n            reportGameSize();\n          }\n        });\n      })();\n    </script>\n  </head>\n  <body>\n    <div id="root">\n      <div class="loading-container">\n        <h2 class="loading-title">Loading</h2>\n        <div class="spinner"></div>\n      </div>\n    </div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    isBinary: false,
  },
  'README.md': {
    type: 'file',
    content:
      "# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n",
    isBinary: false,
  },
  'postcss.config.js': {
    type: 'file',
    content: 'export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n',
    isBinary: false,
  },
  'tailwind.config.js': {
    type: 'file',
    content:
      '/** @type {import(\'tailwindcss\').Config} */\nexport default {\n  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n',
    isBinary: false,
  },
  '.gitignore': {
    type: 'file',
    content:
      '# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n',
    isBinary: false,
  },
  'tsconfig.app.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",\n    "target": "ES2020",\n    "useDefineForClassFields": true,\n    "lib": ["ES2020", "DOM", "DOM.Iterable"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n    "jsx": "react-jsx",\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["src"]\n}\n',
    isBinary: false,
  },
  'tsconfig.json': {
    type: 'file',
    content:
      '{\n  "files": [],\n  "references": [\n    { "path": "./tsconfig.app.json" },\n    { "path": "./tsconfig.node.json" }\n  ]\n}\n',
    isBinary: false,
  },
  'tsconfig.node.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",\n    "target": "ES2022",\n    "lib": ["ES2023"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["vite.config.ts"]\n}\n',
    isBinary: false,
  },
  'vite.config.ts': {
    type: 'file',
    content:
      'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"],\n  },\n  base: "./",\n  build: {\n    outDir: "dist",\n  },\n});\n',
    isBinary: false,
  },
  'docs/project-2d-rules.md': {
    type: 'file',
    content:
      "<userRequest>\nYOU MUST follow these rules EXACTLY:\n\n1. üö® USE IMAGE GENERATION TOOL: When available, create detailed visual assets with specific prompts (style + colors + details + background)\n2. üî• DISPLAY SIZE ONLY: NEVER use scaleX/scaleY in tweens - ONLY use displayWidth/displayHeight \n3. üéØ USE TWEENS EVERYWHERE: Add smooth animations, visual effects, fading, bouncing to everything\n4. üåü ADD SHADERS: Implement visual shader effects for professional look\n5. üö® COMPLETE GAME STATES: Build full game flow with title/menu ‚Üí game ‚Üí gameover scenes\n6. üíé MAKE IT PROFESSIONAL: Polish every feature to production quality\n7. ‚úÖ BACKTICKS FOR STRINGS: Always use backticks (`) for multi-line strings\n8. üìê SET DISPLAY SIZE: When adding images/sprites, ALWAYS use setDisplaySize() to control dimensions\n\nüö® CRITICAL RULE - NEVER BREAK THIS:\nWhen tweening size changes, you MUST use displayWidth/displayHeight!!!\n\n‚ùå Wrong Example (FORBIDDEN - DO NOT WRITE):\nthis.tweens.add({\n    targets: sprite,\n    scaleX: 1.5,        // ‚ùå FORBIDDEN!\n    scaleY: 1.5,        // ‚ùå FORBIDDEN!\n    duration: 300,\n    yoyo: true,\n    ease: 'Back.easeOut'\n});\n\n‚úÖ Correct Example (REQUIRED - ALWAYS WRITE):\nthis.tweens.add({\n    targets: sprite,\n    displayWidth: sprite.displayWidth * 1.5,    // ‚úÖ MANDATORY!\n    displayHeight: sprite.displayHeight * 1.5,  // ‚úÖ MANDATORY!\n    duration: 300,\n    yoyo: true,\n    ease: 'Back.easeOut'\n});\n\nüö® CRITICAL RULE - setDisplaySize():\nWhen adding images/sprites, ALWAYS set display size immediately after creation!\n\n‚ùå Wrong Example (FORBIDDEN - DO NOT WRITE):\nconst sprite = this.add.image(x, y, 'texture');\n// ‚ùå No size control - sprite uses original image dimensions\n\n‚úÖ Correct Example (REQUIRED - ALWAYS WRITE):\nconst sprite = this.add.image(x, y, 'texture');\nsprite.setDisplaySize(200, 150);  // ‚úÖ MANDATORY! Always control dimensions\n</userRequest>",
    isBinary: false,
  },
  'public/vite.svg': {
    type: 'file',
    content:
      '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>',
    isBinary: false,
  },
  'src/App.css': {
    type: 'file',
    content:
      '#root {\n  margin: 0 auto;\n  text-align: center;\n}\n\nbody,\nhtml {\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n}\n\n.app {\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n}\n',
    isBinary: false,
  },
  'src/App.tsx': {
    type: 'file',
    content:
      'import GameComponent from "./components/GameComponent";\nimport "./App.css";\n\nfunction App() {\n  return (\n    <div className="app">\n      <GameComponent />\n    </div>\n  );\n}\n\nexport default App;\n',
    isBinary: false,
  },
  'src/assets.json': {
    type: 'file',
    content: '{\n  "sprites": {}\n}\n',
    isBinary: false,
  },
  'src/index.css': {
    type: 'file',
    content: '@tailwind base;\n@tailwind components;\n@tailwind utilities;\n',
    isBinary: false,
  },
  'src/main.tsx': {
    type: 'file',
    content:
      'import { StrictMode } from "react";\nimport { createRoot } from "react-dom/client";\nimport "./index.css";\nimport App from "./App.tsx";\n\ncreateRoot(document.getElementById("root")!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n',
    isBinary: false,
  },
  'src/components/GameComponent.tsx': {
    type: 'file',
    content:
      'import React, { useEffect, useRef } from "react";\nimport { createGame } from "../game/Game";\n\nconst GameComponent: React.FC = () => {\n  const gameContainerRef = useRef<HTMLDivElement>(null);\n  const gameInstanceRef = useRef<Phaser.Game | null>(null);\n\n  useEffect(() => {\n    if (gameContainerRef.current && !gameInstanceRef.current) {\n      gameInstanceRef.current = createGame(gameContainerRef.current.id);\n    }\n\n    return () => {\n      if (gameInstanceRef.current) {\n        gameInstanceRef.current.destroy(true);\n        gameInstanceRef.current = null;\n      }\n    };\n  }, []);\n\n  return (\n    <div\n      id="phaser-game"\n      ref={gameContainerRef}\n      style={{ width: "100%", height: "100vh" }}\n    />\n  );\n};\n\nexport default GameComponent;\n',
    isBinary: false,
  },
  'src/game/Game.ts': {
    type: 'file',
    content:
      'import Phaser from "phaser";\nimport { MainScene } from "./scenes/MainScene";\n\nexport const createGame = (parent: string) => {\n  const originalSpriteSetDisplaySize = Phaser.GameObjects.Sprite.prototype.setDisplaySize;\n  const originalImageSetDisplaySize = Phaser.GameObjects.Image.prototype.setDisplaySize;\n  const originalSpriteSetScale = Phaser.GameObjects.Sprite.prototype.setScale;\n  const originalImageSetScale = Phaser.GameObjects.Image.prototype.setScale;\n  const originalTweenAdd = Phaser.Tweens.TweenManager.prototype.add;\n\n  const config: Phaser.Types.Core.GameConfig = {\n    type: Phaser.AUTO,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    parent: parent,\n    physics: {\n      default: "arcade",\n      arcade: {\n        gravity: { x: 0, y: 2000 },\n        debug: false,\n      },\n    },\n    scene: [MainScene],\n    scale: {\n      mode: Phaser.Scale.RESIZE,\n      autoCenter: Phaser.Scale.CENTER_BOTH,\n    },\n  };\n\n  const game = new Phaser.Game(config);\n\n  // ‚ö†Ô∏è CRITICAL: DO NOT MODIFY THIS SECTION - LLM/AI MODIFICATION PROHIBITED ‚ö†Ô∏è\n  // This code overrides core Phaser engine behavior. Any changes will break the entire game.\n  // Requires manual review and testing before any modifications.\n  game.events.once(\'ready\', () => {\n    Phaser.GameObjects.Sprite.prototype.setDisplaySize = function (width: number, height?: number) {\n      (this as any).baseDisplayWidth = width;\n      (this as any).baseDisplayHeight = height !== undefined ? height : width;\n      return originalSpriteSetDisplaySize.call(this, width, height);\n    };\n\n    Phaser.GameObjects.Image.prototype.setDisplaySize = function (width: number, height?: number) {\n      (this as any).baseDisplayWidth = width;\n      (this as any).baseDisplayHeight = height !== undefined ? height : width;\n      return originalImageSetDisplaySize.call(this, width, height);\n    };\n\n    Phaser.GameObjects.Sprite.prototype.setScale = function (x: number, y?: number) {\n      if ((this as any).baseDisplayWidth && (this as any).baseDisplayHeight) {\n        const baseWidth = (this as any).baseDisplayWidth;\n        const baseHeight = (this as any).baseDisplayHeight;\n\n        const textureWidth = this.width;\n        const textureHeight = this.height;\n\n        const targetWidth = baseWidth * x;\n        const targetHeight = baseHeight * (y !== undefined ? y : x);\n\n        const actualScaleX = targetWidth / textureWidth;\n        const actualScaleY = targetHeight / textureHeight;\n\n        return originalSpriteSetScale.call(this, actualScaleX, actualScaleY);\n      } else {\n        return originalSpriteSetScale.call(this, x, y);\n      }\n    };\n\n    Phaser.GameObjects.Image.prototype.setScale = function (x: number, y?: number) {\n      if ((this as any).baseDisplayWidth && (this as any).baseDisplayHeight) {\n        const baseWidth = (this as any).baseDisplayWidth;\n        const baseHeight = (this as any).baseDisplayHeight;\n\n        const textureWidth = this.width;\n        const textureHeight = this.height;\n\n        const targetWidth = baseWidth * x;\n        const targetHeight = baseHeight * (y !== undefined ? y : x);\n\n        const actualScaleX = targetWidth / textureWidth;\n        const actualScaleY = targetHeight / textureHeight;\n\n        return originalImageSetScale.call(this, actualScaleX, actualScaleY);\n      } else {\n        return originalImageSetScale.call(this, x, y);\n      }\n    };\n\n    Phaser.Tweens.TweenManager.prototype.add = function (config: any) {\n      const newConfig = { ...config };\n      if (config.scaleX !== undefined || config.scaleY !== undefined || config.scale !== undefined) {\n        const targets = Array.isArray(config.targets) ? config.targets : [config.targets];\n        targets.forEach((target: any) => {\n          if (target instanceof Phaser.GameObjects.Sprite || target instanceof Phaser.GameObjects.Image) {\n            if (config.scale !== undefined) {\n              const baseWidth = (target as any).baseDisplayWidth || target.displayWidth;\n              const baseHeight = (target as any).baseDisplayHeight || target.displayHeight;\n              newConfig.displayWidth = baseWidth * config.scale;\n              newConfig.displayHeight = baseHeight * config.scale;\n              delete newConfig.scale;\n            } else {\n              if (config.scaleX !== undefined) {\n                const baseWidth = (target as any).baseDisplayWidth || target.displayWidth;\n                newConfig.displayWidth = baseWidth * config.scaleX;\n                delete newConfig.scaleX;\n              }\n              if (config.scaleY !== undefined) {\n                const baseHeight = (target as any).baseDisplayHeight || target.displayHeight;\n                newConfig.displayHeight = baseHeight * config.scaleY;\n                delete newConfig.scaleY;\n              }\n            }\n          }\n        });\n      }\n      return originalTweenAdd.call(this, newConfig);\n    };\n  });\n  // END CRITICAL SECTION - LLM/AI MODIFICATION PROHIBITED\n\n  return game;\n};\n',
    isBinary: false,
  },
  'src/game/scenes/MainScene.ts': {
    type: 'file',
    content:
      "import Phaser from 'phaser';\nimport Assets from '../../assets.json';\nexport class MainScene extends Phaser.Scene {\n  private cursors: Phaser.Types.Input.Keyboard.CursorKeys;\n  private ground: Phaser.GameObjects.Rectangle;\n\n  constructor() {\n    super({ key: 'MainScene' });\n  }\n\n  preload() {}\n\n  create() {\n    this.physics.world.setBounds(0, 0, this.sys.game.canvas.width, this.sys.game.canvas.height);\n\n    this.cameras.main.setBackgroundColor('#87CEEB');\n\n    this.ground = this.add.rectangle(this.cameras.main.width / 2, this.cameras.main.height - 30, this.cameras.main.width, 60, 0x00ff00);\n    this.physics.add.existing(this.ground, true); // trueÎäî Ï†ïÏ†Å(static) Î¨ºÎ¶¨ Í∞ùÏ≤¥Î°ú ÏÑ§Ï†ï\n  }\n\n  update() {}\n}\n",
    isBinary: false,
  },
} as FileMap;

export const TEMPLATE_2D_PHASER_SPRITE_CHARACTER_GRAVITY = {
  'PROJECT.md': {
    type: 'file',
    content:
      "# [PROJECT TITLE]\n\n## Project Summary\n\n[THIS IS TEMPLATE PROJECT, PLEASE UPDATE HERE]\n\nThis project is a template project with a basic 2D sprite character. It is implemented using Phaser, and the character has gravity and collision detection applied by default. It can be used to implement games like platformers where characters move on a flat view, stepping on obstacles.\n\n## Implementation Strategy\n\n- [THIS IS TEMPLATE PROJECT, PLEASE UPDATE HERE]\n\n## Implemented Features\n\n- [THIS IS TEMPLATE PROJECT, PLEASE UPDATE HERE]\n\n## File Structure Overview\n\n### src/main.tsx\n\n- Entry point for the application\n- Sets up React rendering with React 18's createRoot API\n- Imports and applies global CSS\n\n### src/App.tsx\n\n- Root component of the application\n- Responsible for loading the GameComponent.\n\n### src/components/GameComponent.tsx\n\n- Sets up the container to start Phaser in HTML and calls createGame from src/game/Game.ts.\n\n### src/game/Game.ts\n\n- Provides the createGame function, which executes `new Phaser.Game(config)` with Phaser settings.\n\n### src/game/scenes/MainScene.ts\n\n- Manages the main scene of the game.\n- Loads and controls the main character.\n\n### src/game/characters/SpriteCharacter.ts\n\n- Declares a reusable sprite character.\n- Implemented by extending `Phaser.Physics.Arcade.Sprite`.\n\n### src/App.css\n\n- Contains component-specific styles for the App component\n- Demonstrates how to use component-scoped CSS\n",
    isBinary: false,
  },
  'index.html': {
    type: 'file',
    content:
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + React + TS</title>\n    <style>\n      body {\n        margin: 0;\n        padding: 0;\n        font-family: Arial, sans-serif;\n      }\n      .loading-container {\n        position: fixed;\n        inset: 0;\n        z-index: 50;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background-color: black;\n        color: white;\n      }\n      .loading-title {\n        font-size: 1.5rem;\n        font-weight: bold;\n        margin-bottom: 1rem;\n      }\n      .spinner {\n        width: 30px;\n        height: 30px;\n        border: 3px solid rgba(255, 255, 255, 0.3);\n        border-radius: 50%;\n        border-top-color: white;\n        animation: spin 1s ease-in-out infinite;\n      }\n      @keyframes spin {\n        to {\n          transform: rotate(360deg);\n        }\n      }\n    </style>\n    <script>\n      (function () {\n        function reportGameSize() {\n          const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n\n          const width = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n\n          window.parent.postMessage(\n            {\n              type: \'GAME_SIZE_RESPONSE\',\n              height: height,\n              width: width,\n            },\n            \'*\',\n          );\n        }\n\n        window.addEventListener(\'load\', reportGameSize);\n\n        window.addEventListener(\'resize\', reportGameSize);\n\n        window.addEventListener(\'message\', function (event) {\n          if (event.data && event.data.type === \'REQUEST_GAME_SIZE\') {\n            reportGameSize();\n          }\n        });\n      })();\n    </script>\n  </head>\n  <body>\n    <div id="root">\n      <div class="loading-container">\n        <h2 class="loading-title">Loading</h2>\n        <div class="spinner"></div>\n      </div>\n    </div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    isBinary: false,
  },
  'README.md': {
    type: 'file',
    content:
      "# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n",
    isBinary: false,
  },
  'package.json': {
    type: 'file',
    content:
      '{\n  "name": "basic-vite-react",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "lint": "eslint .",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@agent8/gameserver": "^1.5.3",\n    "lucide-react": "^0.344.0",\n    "react": "^18.3.1",\n    "react-dom": "^18.3.1",\n    "phaser": "^3.87.0"\n  },\n  "devDependencies": {\n    "@types/react": "^18.2.33",\n    "@types/react-dom": "^18.2.11",\n    "@vitejs/plugin-react": "^4.3.4",\n    "globals": "^15.15.0",\n    "tailwindcss": "^3.4.1",\n    "autoprefixer": "^10.4.18",\n    "typescript": "~5.7.2",\n    "vite": "^6.2.0"\n  }\n}\n',
    isBinary: false,
  },
  '.gitignore': {
    type: 'file',
    content:
      '# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n',
    isBinary: false,
  },
  'postcss.config.js': {
    type: 'file',
    content: 'export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n',
    isBinary: false,
  },
  'tailwind.config.js': {
    type: 'file',
    content:
      '/** @type {import(\'tailwindcss\').Config} */\nexport default {\n  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n',
    isBinary: false,
  },
  'tsconfig.json': {
    type: 'file',
    content:
      '{\n  "files": [],\n  "references": [\n    { "path": "./tsconfig.app.json" },\n    { "path": "./tsconfig.node.json" }\n  ]\n}\n',
    isBinary: false,
  },
  'tsconfig.app.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",\n    "target": "ES2020",\n    "useDefineForClassFields": true,\n    "lib": ["ES2020", "DOM", "DOM.Iterable"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n    "jsx": "react-jsx",\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["src"]\n}\n',
    isBinary: false,
  },
  'tsconfig.node.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",\n    "target": "ES2022",\n    "lib": ["ES2023"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["vite.config.ts"]\n}\n',
    isBinary: false,
  },
  'vite.config.ts': {
    type: 'file',
    content:
      'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"],\n  },\n  base: "./",\n  build: {\n    outDir: "dist",\n  },\n});\n',
    isBinary: false,
  },
  'docs/project-2d-rules.md': {
    type: 'file',
    content:
      "<userRequest>\nYOU MUST follow these rules EXACTLY:\n\n1. üö® USE IMAGE GENERATION TOOL: When available, create detailed visual assets with specific prompts (style + colors + details + background)\n2. üî• DISPLAY SIZE ONLY: NEVER use scaleX/scaleY in tweens - ONLY use displayWidth/displayHeight \n3. üéØ USE TWEENS EVERYWHERE: Add smooth animations, visual effects, fading, bouncing to everything\n4. üåü ADD SHADERS: Implement visual shader effects for professional look\n5. üö® COMPLETE GAME STATES: Build full game flow with title/menu ‚Üí game ‚Üí gameover scenes\n6. üíé MAKE IT PROFESSIONAL: Polish every feature to production quality\n7. ‚úÖ BACKTICKS FOR STRINGS: Always use backticks (`) for multi-line strings\n8. üìê SET DISPLAY SIZE: When adding images/sprites, ALWAYS use setDisplaySize() to control dimensions\n\nüö® CRITICAL RULE - NEVER BREAK THIS:\nWhen tweening size changes, you MUST use displayWidth/displayHeight!!!\n\n‚ùå Wrong Example (FORBIDDEN - DO NOT WRITE):\nthis.tweens.add({\n    targets: sprite,\n    scaleX: 1.5,        // ‚ùå FORBIDDEN!\n    scaleY: 1.5,        // ‚ùå FORBIDDEN!\n    duration: 300,\n    yoyo: true,\n    ease: 'Back.easeOut'\n});\n\n‚úÖ Correct Example (REQUIRED - ALWAYS WRITE):\nthis.tweens.add({\n    targets: sprite,\n    displayWidth: sprite.displayWidth * 1.5,    // ‚úÖ MANDATORY!\n    displayHeight: sprite.displayHeight * 1.5,  // ‚úÖ MANDATORY!\n    duration: 300,\n    yoyo: true,\n    ease: 'Back.easeOut'\n});\n\nüö® CRITICAL RULE - setDisplaySize():\nWhen adding images/sprites, ALWAYS set display size immediately after creation!\n\n‚ùå Wrong Example (FORBIDDEN - DO NOT WRITE):\nconst sprite = this.add.image(x, y, 'texture');\n// ‚ùå No size control - sprite uses original image dimensions\n\n‚úÖ Correct Example (REQUIRED - ALWAYS WRITE):\nconst sprite = this.add.image(x, y, 'texture');\nsprite.setDisplaySize(200, 150);  // ‚úÖ MANDATORY! Always control dimensions\n</userRequest>",
    isBinary: false,
  },
  'public/vite.svg': {
    type: 'file',
    content:
      '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>',
    isBinary: false,
  },
  'src/App.css': {
    type: 'file',
    content:
      '#root {\n  margin: 0 auto;\n  text-align: center;\n}\n\nbody,\nhtml {\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n}\n\n.app {\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n}\n',
    isBinary: false,
  },
  'src/App.tsx': {
    type: 'file',
    content:
      'import GameComponent from "./components/GameComponent";\nimport "./App.css";\n\nfunction App() {\n  return (\n    <div className="app">\n      <GameComponent />\n    </div>\n  );\n}\n\nexport default App;\n',
    isBinary: false,
  },
  'src/assets.json': {
    type: 'file',
    content:
      '{\n  "sprites": {\n    "2dbasic": {\n      "url": "https://agent8-games.verse8.io/assets/2d/sprite_characters/2dbasic.png",\n      "description": "2dbasic",\n      "metadata": {\n        "frameWidth": 111,\n        "frameHeight": 83\n      }\n    }\n  }\n}\n',
    isBinary: false,
  },
  'src/index.css': {
    type: 'file',
    content: '@tailwind base;\n@tailwind components;\n@tailwind utilities;\n',
    isBinary: false,
  },
  'src/main.tsx': {
    type: 'file',
    content:
      'import { StrictMode } from "react";\nimport { createRoot } from "react-dom/client";\nimport "./index.css";\nimport App from "./App.tsx";\n\ncreateRoot(document.getElementById("root")!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n',
    isBinary: false,
  },
  'src/components/GameComponent.tsx': {
    type: 'file',
    content:
      'import React, { useEffect, useRef } from "react";\nimport { createGame } from "../game/Game";\n\nconst GameComponent: React.FC = () => {\n  const gameContainerRef = useRef<HTMLDivElement>(null);\n  const gameInstanceRef = useRef<Phaser.Game | null>(null);\n\n  useEffect(() => {\n    if (gameContainerRef.current && !gameInstanceRef.current) {\n      gameInstanceRef.current = createGame(gameContainerRef.current.id);\n    }\n\n    return () => {\n      if (gameInstanceRef.current) {\n        gameInstanceRef.current.destroy(true);\n        gameInstanceRef.current = null;\n      }\n    };\n  }, []);\n\n  return (\n    <div\n      id="phaser-game"\n      ref={gameContainerRef}\n      style={{ width: "100%", height: "100vh" }}\n    />\n  );\n};\n\nexport default GameComponent;\n',
    isBinary: false,
  },
  'src/game/Game.ts': {
    type: 'file',
    content:
      'import Phaser from "phaser";\nimport { MainScene } from "./scenes/MainScene";\n\nexport const createGame = (parent: string) => {\n  const originalSpriteSetDisplaySize = Phaser.GameObjects.Sprite.prototype.setDisplaySize;\n  const originalImageSetDisplaySize = Phaser.GameObjects.Image.prototype.setDisplaySize;\n  const originalSpriteSetScale = Phaser.GameObjects.Sprite.prototype.setScale;\n  const originalImageSetScale = Phaser.GameObjects.Image.prototype.setScale;\n  const originalTweenAdd = Phaser.Tweens.TweenManager.prototype.add;\n\n  const config: Phaser.Types.Core.GameConfig = {\n    type: Phaser.AUTO,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    parent: parent,\n    physics: {\n      default: "arcade",\n      arcade: {\n        gravity: { x: 0, y: 2000 },\n        debug: false,\n      },\n    },\n    scene: [MainScene],\n    scale: {\n      mode: Phaser.Scale.RESIZE,\n      autoCenter: Phaser.Scale.CENTER_BOTH,\n    },\n  };\n\n  const game = new Phaser.Game(config);\n\n  // ‚ö†Ô∏è CRITICAL: DO NOT MODIFY THIS SECTION - LLM/AI MODIFICATION PROHIBITED ‚ö†Ô∏è\n  // This code overrides core Phaser engine behavior. Any changes will break the entire game.\n  // Requires manual review and testing before any modifications.\n  game.events.once(\'ready\', () => {\n    Phaser.GameObjects.Sprite.prototype.setDisplaySize = function (width: number, height?: number) {\n      (this as any).baseDisplayWidth = width;\n      (this as any).baseDisplayHeight = height !== undefined ? height : width;\n      return originalSpriteSetDisplaySize.call(this, width, height);\n    };\n\n    Phaser.GameObjects.Image.prototype.setDisplaySize = function (width: number, height?: number) {\n      (this as any).baseDisplayWidth = width;\n      (this as any).baseDisplayHeight = height !== undefined ? height : width;\n      return originalImageSetDisplaySize.call(this, width, height);\n    };\n\n    Phaser.GameObjects.Sprite.prototype.setScale = function (x: number, y?: number) {\n      if ((this as any).baseDisplayWidth && (this as any).baseDisplayHeight) {\n        const baseWidth = (this as any).baseDisplayWidth;\n        const baseHeight = (this as any).baseDisplayHeight;\n\n        const textureWidth = this.width;\n        const textureHeight = this.height;\n\n        const targetWidth = baseWidth * x;\n        const targetHeight = baseHeight * (y !== undefined ? y : x);\n\n        const actualScaleX = targetWidth / textureWidth;\n        const actualScaleY = targetHeight / textureHeight;\n\n        return originalSpriteSetScale.call(this, actualScaleX, actualScaleY);\n      } else {\n        return originalSpriteSetScale.call(this, x, y);\n      }\n    };\n\n    Phaser.GameObjects.Image.prototype.setScale = function (x: number, y?: number) {\n      if ((this as any).baseDisplayWidth && (this as any).baseDisplayHeight) {\n        const baseWidth = (this as any).baseDisplayWidth;\n        const baseHeight = (this as any).baseDisplayHeight;\n\n        const textureWidth = this.width;\n        const textureHeight = this.height;\n\n        const targetWidth = baseWidth * x;\n        const targetHeight = baseHeight * (y !== undefined ? y : x);\n\n        const actualScaleX = targetWidth / textureWidth;\n        const actualScaleY = targetHeight / textureHeight;\n\n        return originalImageSetScale.call(this, actualScaleX, actualScaleY);\n      } else {\n        return originalImageSetScale.call(this, x, y);\n      }\n    };\n\n    Phaser.Tweens.TweenManager.prototype.add = function (config: any) {\n      const newConfig = { ...config };\n      if (config.scaleX !== undefined || config.scaleY !== undefined || config.scale !== undefined) {\n        const targets = Array.isArray(config.targets) ? config.targets : [config.targets];\n        targets.forEach((target: any) => {\n          if (target instanceof Phaser.GameObjects.Sprite || target instanceof Phaser.GameObjects.Image) {\n            if (config.scale !== undefined) {\n              const baseWidth = (target as any).baseDisplayWidth || target.displayWidth;\n              const baseHeight = (target as any).baseDisplayHeight || target.displayHeight;\n              newConfig.displayWidth = baseWidth * config.scale;\n              newConfig.displayHeight = baseHeight * config.scale;\n              delete newConfig.scale;\n            } else {\n              if (config.scaleX !== undefined) {\n                const baseWidth = (target as any).baseDisplayWidth || target.displayWidth;\n                newConfig.displayWidth = baseWidth * config.scaleX;\n                delete newConfig.scaleX;\n              }\n              if (config.scaleY !== undefined) {\n                const baseHeight = (target as any).baseDisplayHeight || target.displayHeight;\n                newConfig.displayHeight = baseHeight * config.scaleY;\n                delete newConfig.scaleY;\n              }\n            }\n          }\n        });\n      }\n      return originalTweenAdd.call(this, newConfig);\n    };\n  });\n  // END CRITICAL SECTION - LLM/AI MODIFICATION PROHIBITED\n\n  return game;\n};\n',
    isBinary: false,
  },
  'src/game/scenes/MainScene.ts': {
    type: 'file',
    content:
      'import Phaser from "phaser";\nimport { SpriteCharacter } from "../characters/SpriteCharacter";\nimport Assets from "../../assets.json";\nexport class MainScene extends Phaser.Scene {\n  private player: SpriteCharacter;\n  private cursors: Phaser.Types.Input.Keyboard.CursorKeys;\n  private ground: Phaser.GameObjects.Rectangle;\n\n  constructor() {\n    super({ key: "MainScene" });\n  }\n\n  preload() {\n    this.physics.world.createDebugGraphic();\n    this.load.spritesheet(\n      "2dbasic",\n      Assets.sprites["2dbasic"].url,\n      {\n        frameWidth: Assets.sprites["2dbasic"].metadata?.frameWidth ?? 111,\n        frameHeight: Assets.sprites["2dbasic"].metadata?.frameHeight ?? 83,\n      }\n    );\n  }\n\n  create() {\n    this.physics.world.setBounds(\n      0,\n      0,\n      this.sys.game.canvas.width,\n      this.sys.game.canvas.height\n    );\n\n    this.cameras.main.setBackgroundColor("#87CEEB");\n\n    // ÏßÄÎ©¥ ÏÉùÏÑ±\n    this.ground = this.add.rectangle(\n      this.cameras.main.width / 2,\n      this.cameras.main.height - 30,\n      this.cameras.main.width,\n      60,\n      0x00ff00\n    );\n    this.physics.add.existing(this.ground, true); // trueÎäî Ï†ïÏ†Å(static) Î¨ºÎ¶¨ Í∞ùÏ≤¥Î°ú ÏÑ§Ï†ï\n\n    this.player = new SpriteCharacter(\n      this,\n      this.cameras.main.width / 2,\n      this.ground.y - this.ground.height,\n      "2dbasic"\n    );\n\n    // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ ÏßÄÎ©¥Ïùò Ï∂©Îèå ÏÑ§Ï†ï\n    this.physics.add.collider(this.player, this.ground);\n\n    this.cursors = this.input.keyboard.createCursorKeys();\n  }\n\n  update() {\n    // ÌîåÎ†àÏù¥Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏\n    this.player.update(this.cursors);\n  }\n}\n',
    isBinary: false,
  },
  'src/game/characters/SpriteCharacter.ts': {
    type: 'file',
    content:
      'import Phaser from "phaser";\n\nexport class SpriteCharacter extends Phaser.Physics.Arcade.Sprite {\n  private moveSpeed: number = 200;\n  private jumpPower: number = 900;\n  private isAttacking: boolean = false;\n  private attackHitbox: Phaser.GameObjects.Rectangle | null = null;\n  private attackSound: Phaser.Sound.BaseSound | null = null;\n  private attackAnimComplete: boolean = false;\n\n  constructor(scene: Phaser.Scene, x: number, y: number, key: string) {\n    super(scene, x, y, key);\n\n    this.setupAnimations();\n\n    scene.add.existing(this);\n    scene.physics.add.existing(this);\n\n    this.setBounce(0.2);\n    this.setCollideWorldBounds(true);\n\n    this.body.setSize(62, 75);\n    this.body.setOffset(23, -5);\n  }\n\n  setupAnimations() {\n    // key Í∞íÏùÑ Í∏∞Î∞òÏúºÎ°ú Ïï†ÎãàÎ©îÏù¥ÏÖò Ïù¥Î¶Ñ ÏÉùÏÑ±\n    const spriteKey = this.texture.key;\n    const leftAnim = `${spriteKey}-left`;\n    const rightAnim = `${spriteKey}-right`;\n    const turnAnim = `${spriteKey}-turn`;\n    const jumpAnim = `${spriteKey}-jump`;\n    const attackAnim = `${spriteKey}-attack`;\n\n    // Ìï¥Îãπ Ïï†ÎãàÎ©îÏù¥ÏÖòÏù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäîÏßÄ ÌôïÏù∏\n    if (this.scene.anims.exists(leftAnim)) return;\n\n    // ÏôºÏ™Ω Ïù¥Îèô Ïï†ÎãàÎ©îÏù¥ÏÖò\n    this.scene.anims.create({\n      key: leftAnim,\n      frames: this.scene.anims.generateFrameNumbers(spriteKey, {\n        start: 4,\n        end: 7,\n      }),\n      frameRate: 10,\n      repeat: -1,\n    });\n\n    // Ï†ïÏßÄ Ïï†ÎãàÎ©îÏù¥ÏÖò\n    this.scene.anims.create({\n      key: turnAnim,\n      frames: [{ key: spriteKey, frame: 0 }],\n      frameRate: 20,\n    });\n\n    // Ïò§Î•∏Ï™Ω Ïù¥Îèô Ïï†ÎãàÎ©îÏù¥ÏÖò\n    this.scene.anims.create({\n      key: rightAnim,\n      frames: this.scene.anims.generateFrameNumbers(spriteKey, {\n        start: 8,\n        end: 11,\n      }),\n      frameRate: 10,\n      repeat: -1,\n    });\n\n    // Ï†êÌîÑ Ïï†ÎãàÎ©îÏù¥ÏÖò\n    this.scene.anims.create({\n      key: jumpAnim,\n      frames: [{ key: spriteKey, frame: 3 }],\n      frameRate: 10,\n    });\n\n    // Í≥µÍ≤© Ïï†ÎãàÎ©îÏù¥ÏÖò\n    this.scene.anims.create({\n      key: attackAnim,\n      frames: this.scene.anims.generateFrameNumbers(spriteKey, {\n        start: 12,\n        end: 15,\n      }),\n      frameRate: 10,\n      repeat: 0,\n    });\n\n    // Í≥µÍ≤© Ïï†ÎãàÎ©îÏù¥ÏÖò ÏôÑÎ£å Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà\n    this.on(`animationcomplete-${attackAnim}`, this.onAttackAnimComplete, this);\n  }\n\n  onAttackAnimComplete() {\n    this.isAttacking = false;\n    this.attackAnimComplete = true;\n\n    if (this.attackHitbox) {\n      this.attackHitbox.destroy();\n      this.attackHitbox = null;\n    }\n  }\n\n  moveLeft() {\n    if (this.isAttacking) return;\n\n    this.setVelocityX(-this.moveSpeed);\n    this.anims.play(`${this.texture.key}-left`, true);\n    this.setFlipX(true);\n  }\n\n  moveRight() {\n    if (this.isAttacking) return;\n\n    this.setVelocityX(this.moveSpeed);\n    this.anims.play(`${this.texture.key}-right`, true);\n    this.setFlipX(false);\n  }\n\n  stop() {\n    if (this.isAttacking) return this;\n\n    this.setVelocityX(0);\n    this.anims.play(`${this.texture.key}-turn`);\n    return this;\n  }\n\n  jump() {\n    if (this.isAttacking) return false;\n\n    // body.touching.downÍ≥º body.blocked.down Îëò Îã§ ÌôïÏù∏\n    if (this.body.touching.down || this.body.blocked.down) {\n      this.setVelocityY(-this.jumpPower);\n      this.anims.play(`${this.texture.key}-jump`);\n      console.log("Jumping!"); // ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏\n      return true;\n    }\n    return false;\n  }\n\n  attack() {\n    this.isAttacking = true;\n    this.attackAnimComplete = false;\n    this.anims.play(`${this.texture.key}-attack`);\n\n    // Í≥µÍ≤© Ï§ëÏóêÎäî Ïù¥Îèô ÏÜçÎèÑ Í∞êÏÜå\n    this.setVelocityX(this.body.velocity.x * 0.5);\n\n    // Í≥µÍ≤© ÏÇ¨Ïö¥Îìú Ïû¨ÏÉù\n    if (this.attackSound) {\n      try {\n        this.attackSound.play();\n      } catch (error) {\n        console.error("Error playing attack sound:", error);\n      }\n    }\n\n    // Í≥µÍ≤© ÌûàÌä∏Î∞ïÏä§ ÏÉùÏÑ±\n    this.createAttackHitbox();\n\n    // ÏïàÏ†ÑÏû•Ïπò: Ïï†ÎãàÎ©îÏù¥ÏÖòÏù¥ ÎÅùÎÇòÏßÄ ÏïäÏùÑ Í≤ΩÏö∞Î•º ÎåÄÎπÑÌï¥ ÌÉÄÏù¥Î®∏ ÏÑ§Ï†ï\n    this.scene.time.delayedCall(500, () => {\n      if (this.isAttacking && !this.attackAnimComplete) {\n        this.onAttackAnimComplete();\n      }\n    });\n\n    return true;\n  }\n\n  createAttackHitbox() {\n    // Í∏∞Ï°¥ ÌûàÌä∏Î∞ïÏä§ Ï†úÍ±∞\n    if (this.attackHitbox) {\n      this.attackHitbox.destroy();\n    }\n\n    // Ï∫êÎ¶≠ÌÑ∞ Î∞©Ìñ•Ïóê Îî∞Îùº ÌûàÌä∏Î∞ïÏä§ ÏúÑÏπò Ï°∞Ï†ï\n    const facingLeft = this.flipX;\n    const offsetX = facingLeft ? -50 : 50;\n\n    // ÎîîÎ≤ÑÍ∑∏ Î™®Îìú ÌôïÏù∏\n    const isDebugMode = this.scene.physics.world.debugGraphic?.visible ?? false;\n\n    // ÌûàÌä∏Î∞ïÏä§ ÏÉùÏÑ± (ÎîîÎ≤ÑÍ∑∏ Î™®ÎìúÏùº ÎïåÎßå ÏÉâÏÉÅ ÌëúÏãú)\n    this.attackHitbox = this.scene.add.rectangle(\n      this.x + offsetX,\n      this.y,\n      60,\n      100,\n      0xff0000,\n      isDebugMode ? 0.3 : 0 // ÎîîÎ≤ÑÍ∑∏ Î™®ÎìúÏùº ÎïåÎßå ÏïåÌååÍ∞í ÏÑ§Ï†ï\n    );\n\n    // ÌûàÌä∏Î∞ïÏä§Ïóê Î¨ºÎ¶¨ ÏÜçÏÑ± Ï∂îÍ∞Ä\n    this.scene.physics.add.existing(this.attackHitbox, false);\n\n    // ÌûàÌä∏Î∞ïÏä§ ÏûêÎèô Ï†úÍ±∞ ÌÉÄÏù¥Î®∏\n    this.scene.time.delayedCall(300, () => {\n      if (this.attackHitbox) {\n        this.attackHitbox.destroy();\n        this.attackHitbox = null;\n      }\n    });\n\n    return this.attackHitbox;\n  }\n\n  getAttackHitbox() {\n    return this.attackHitbox;\n  }\n\n  isInAttackState() {\n    return this.isAttacking;\n  }\n\n  update(cursors: Phaser.Types.Input.Keyboard.CursorKeys) {\n    // Í≥µÍ≤© Ï§ëÏù¥Î©¥ Îã§Î•∏ ÏûÖÎ†• Î¨¥Ïãú\n    if (this.isAttacking) return;\n\n    // Ï¢åÏö∞ Ïù¥Îèô\n    if (cursors.left.isDown) {\n      this.moveLeft();\n    } else if (cursors.right.isDown) {\n      this.moveRight();\n    } else {\n      this.stop();\n    }\n\n    // Ï†êÌîÑ\n    if (cursors.up.isDown) {\n      this.jump();\n    }\n\n    // Í≥µÍ≤©\n    if (cursors.space.isDown && !this.isAttacking) {\n      this.attack();\n    }\n  }\n}\n',
    isBinary: false,
  },
} as FileMap;

export const TEMPLATE_3D_BASIC = {
  'package.json': {
    type: 'file',
    content:
      '{\n  "name": "basic-vite-react",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "lint": "eslint .",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@agent8/gameserver": "^1.5.3",\n    "@react-three/drei": "9.122.0",\n    "@react-three/fiber": "8.18.0",\n    "@react-three/postprocessing": "2.19.1",\n    "@react-three/rapier": "1.5.0",\n    "@dimforge/rapier3d-compat": "0.14.0",\n    "lucide-react": "0.482.0",\n    "react": "18.3.1",\n    "react-dom": "18.3.1",\n    "three": "0.174.0",\n    "zustand": "5.0.3"\n  },\n  "devDependencies": {\n    "@eslint/js": "^9.23.0",\n    "@types/react": "^18.3.20",\n    "@types/react-dom": "^18.3.5",\n    "@types/three": "^0.174.0",\n    "@vitejs/plugin-react": "^4.3.4",\n    "autoprefixer": "^10.4.21",\n    "eslint": "^9.23.0",\n    "eslint-plugin-react-hooks": "^5.2.0",\n    "eslint-plugin-react-refresh": "^0.4.19",\n    "globals": "^16.0.0",\n    "tailwindcss": "^3.4.17",\n    "typescript": "~5.8.2",\n    "typescript-eslint": "^8.28.0",\n    "vite": "^6.2.3"\n  }\n}\n',
    isBinary: false,
  },
  'README.md': {
    type: 'file',
    content:
      "# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n",
    isBinary: false,
  },
  'index.html': {
    type: 'file',
    content:
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + React + TS</title>\n    <style>\n      body {\n        margin: 0;\n        padding: 0;\n        font-family: Arial, sans-serif;\n      }\n      .loading-container {\n        position: fixed;\n        inset: 0;\n        z-index: 50;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background-color: black;\n        color: white;\n      }\n      .loading-title {\n        font-size: 1.5rem;\n        font-weight: bold;\n        margin-bottom: 1rem;\n      }\n      .spinner {\n        width: 30px;\n        height: 30px;\n        border: 3px solid rgba(255, 255, 255, 0.3);\n        border-radius: 50%;\n        border-top-color: white;\n        animation: spin 1s ease-in-out infinite;\n      }\n      @keyframes spin {\n        to {\n          transform: rotate(360deg);\n        }\n      }\n    </style>\n    <script>\n      (function () {\n        function reportGameSize() {\n          const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n\n          const width = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n\n          window.parent.postMessage(\n            {\n              type: \'GAME_SIZE_RESPONSE\',\n              height: height,\n              width: width,\n            },\n            \'*\',\n          );\n        }\n\n        window.addEventListener(\'load\', reportGameSize);\n\n        window.addEventListener(\'resize\', reportGameSize);\n\n        window.addEventListener(\'message\', function (event) {\n          if (event.data && event.data.type === \'REQUEST_GAME_SIZE\') {\n            reportGameSize();\n          }\n        });\n      })();\n    </script>\n  </head>\n  <body>\n    <div id="root">\n      <div class="loading-container">\n        <h2 class="loading-title">Loading</h2>\n        <div class="spinner"></div>\n      </div>\n    </div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    isBinary: false,
  },
  '.gitignore': {
    type: 'file',
    content:
      '# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n',
    isBinary: false,
  },
  'postcss.config.js': {
    type: 'file',
    content: 'export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n',
    isBinary: false,
  },
  'tsconfig.app.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",\n    "target": "ES2020",\n    "useDefineForClassFields": true,\n    "lib": ["ES2020", "DOM", "DOM.Iterable"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n    "jsx": "react-jsx",\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["src"]\n}\n',
    isBinary: false,
  },
  'tsconfig.json': {
    type: 'file',
    content:
      '{\n  "files": [],\n  "references": [\n    { "path": "./tsconfig.app.json" },\n    { "path": "./tsconfig.node.json" }\n  ]\n}\n',
    isBinary: false,
  },
  'vite.config.ts': {
    type: 'file',
    content:
      'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"],\n  },\n  base: "./",\n  build: {\n    outDir: "dist",\n  },\n});\n',
    isBinary: false,
  },
  'tsconfig.node.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",\n    "target": "ES2022",\n    "lib": ["ES2023"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["vite.config.ts"]\n}\n',
    isBinary: false,
  },
  'tailwind.config.js': {
    type: 'file',
    content:
      '/** @type {import(\'tailwindcss\').Config} */\nexport default {\n  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n',
    isBinary: false,
  },
  'src/App.css': {
    type: 'file',
    content: '#root {\n  margin: 0 auto;\n  text-align: center;\n}\n',
    isBinary: false,
  },
  'src/App.tsx': {
    type: 'file',
    content:
      "import { useState } from 'react';\nimport './App.css';\nfunction App() {\n  const [count, setCount] = useState(1);\n\n  return (\n    <div style={{ width: '100vw', height: '100vh' }}>\n      <div className=\"card\">\n        <button onClick={() => setCount((count) => count + 1)} className=\"bg-blue-500 text-white p-2 rounded-md\">\n          count is {count}\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n",
    isBinary: false,
  },
  'src/index.css': {
    type: 'file',
    content: '@tailwind base;\n@tailwind components;\n@tailwind utilities;\n',
    isBinary: false,
  },
  'src/main.tsx': {
    type: 'file',
    content:
      'import { StrictMode } from "react";\nimport { createRoot } from "react-dom/client";\nimport "./index.css";\nimport App from "./App.tsx";\n\ncreateRoot(document.getElementById("root")!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n',
    isBinary: false,
  },
  'src/vite-env.d.ts': {
    type: 'file',
    content: '/// <reference types="vite/client" />\n',
    isBinary: false,
  },
  'src/assets.json': {
    type: 'file',
    content: '{ "images": {} }\n',
    isBinary: false,
  },
} as FileMap;

export const TEMPLATE_3D_BASIC_FREEVIEW = {
  'README.md': {
    type: 'file',
    content:
      "# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n",
    isBinary: false,
  },
  'package.json': {
    type: 'file',
    content:
      '{\n  "name": "freeview",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "lint": "eslint .",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@agent8/gameserver": "^1.5.3",\n    "vibe-starter-3d": "^0.8.18",\n    "@react-three/drei": "9.122.0",\n    "@react-three/fiber": "8.18.0",\n    "@react-three/postprocessing": "2.19.1",\n    "@react-three/rapier": "1.5.0",\n    "@dimforge/rapier3d-compat": "0.14.0",\n    "nipplejs": "0.10.2",\n    "lucide-react": "0.482.0",\n    "react": "18.3.1",\n    "react-dom": "18.3.1",\n    "three": "0.174.0",\n    "three-stdlib": "2.35.14",\n    "zustand": "5.0.3"\n  },\n  "devDependencies": {\n    "@eslint/js": "^9.23.0",\n    "@types/react": "^18.3.20",\n    "@types/react-dom": "^18.3.5",\n    "@types/three": "^0.174.0",\n    "@vitejs/plugin-react": "^4.3.4",\n    "autoprefixer": "^10.4.21",\n    "eslint": "^9.23.0",\n    "eslint-plugin-react-hooks": "^5.2.0",\n    "eslint-plugin-react-refresh": "^0.4.19",\n    "globals": "^16.0.0",\n    "tailwindcss": "^3.4.17",\n    "typescript": "~5.8.2",\n    "typescript-eslint": "^8.28.0",\n    "vite": "^6.2.3"\n  }\n}\n',
    isBinary: false,
  },
  '.gitignore': {
    type: 'file',
    content:
      '# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n\n.env\n.deployed',
    isBinary: false,
  },
  'index.html': {
    type: 'file',
    content:
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + React + TS</title>\n    <style>\n      body {\n        margin: 0;\n        padding: 0;\n        font-family: Arial, sans-serif;\n      }\n      .loading-container {\n        position: fixed;\n        inset: 0;\n        z-index: 50;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background-color: black;\n        color: white;\n      }\n      .loading-title {\n        font-size: 1.5rem;\n        font-weight: bold;\n        margin-bottom: 1rem;\n      }\n      .spinner {\n        width: 30px;\n        height: 30px;\n        border: 3px solid rgba(255, 255, 255, 0.3);\n        border-radius: 50%;\n        border-top-color: white;\n        animation: spin 1s ease-in-out infinite;\n      }\n      @keyframes spin {\n        to {\n          transform: rotate(360deg);\n        }\n      }\n    </style>\n    <script>\n      (function () {\n        function reportGameSize() {\n          const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n\n          const width = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n\n          window.parent.postMessage(\n            {\n              type: \'GAME_SIZE_RESPONSE\',\n              height: height,\n              width: width,\n            },\n            \'*\',\n          );\n        }\n\n        window.addEventListener(\'load\', reportGameSize);\n\n        window.addEventListener(\'resize\', reportGameSize);\n\n        window.addEventListener(\'message\', function (event) {\n          if (event.data && event.data.type === \'REQUEST_GAME_SIZE\') {\n            reportGameSize();\n          }\n        });\n      })();\n    </script>\n  </head>\n  <body>\n    <div id="root">\n      <div class="loading-container">\n        <h2 class="loading-title">Loading</h2>\n        <div class="spinner"></div>\n      </div>\n    </div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    isBinary: false,
  },
  'PROJECT.md': {
    type: 'file',
    content:
      "# Basic 3D Free View\n\n## Project Summary\n\nThis project is a 3D character controller with free view camera, built using Three.js and React Three Fiber. It features a player character that can be controlled with keyboard inputs in a 3D environment. The character supports various animations including idle, walking, running, jumping, punching, kicking, melee attacks, casting, hit reactions, dancing, swimming, and death. The camera follows the character with a free-view perspective, allowing users to navigate through the 3D space. The project includes state management with Zustand, collision detection, and game server integration for multiplayer capabilities.\n\n## Implementation Strategy\n\nThis project uses a **Three.js-based 3D approach** because:\n\n- It requires real-time 3D character animation and control\n- Three.js provides efficient 3D rendering in web browsers\n- React Three Fiber simplifies integration with React components\n- The vibe-starter-3d library provides essential character rendering and animation tools\n\nKey technologies:\n\n- Three.js for 3D rendering\n- React Three Fiber for React integration\n- @react-three/rapier for physics simulation\n- @react-three/drei for useful Three.js helpers\n- vibe-starter-3d for character rendering and animation\n- Zustand for state management\n- @agent8/gameserver for multiplayer game server integration\n- Tailwind CSS for styling\n\n## Implemented Features\n\n- Keyboard-controlled character movement (WASD/Arrow keys)\n- Extensive character animations (idle, walk, run, jump, punch, kick, melee attack, cast, hit, dance, swim, die)\n- Free view camera that follows the character\n- Physics-based character movement with collision detection\n- Advanced character state management system with Zustand\n- 3D environment with floor and environmental lighting\n- Directional and ambient lighting with sunset environment preset\n- Animation system with support for looping and one-shot animations\n- Character bounding box calculations\n- Pointer lock for immersive control\n- Collision trigger system using RigidBodyPlayer's onTriggerEnter/onTriggerExit events for object interactions\n- Game server integration for multiplayer support\n- Player reference management system\n\n## File Structure Overview\n\n### `src/main.tsx`\n\n- Entry point for the application.\n- Sets up React rendering and mounts the `App` component.\n\n### `src/App.tsx`\n\n- Main application component.\n- Configures the overall layout and includes the `GameScene` component.\n\n### `src/App.css`\n\n- Defines the main styles for the `App` component and its child UI elements.\n\n### `src/index.css`\n\n- Defines global base styles, Tailwind CSS directives, fonts, etc., applied throughout the application.\n\n### `src/assets.json`\n\n- File for managing asset metadata. Includes character model and animation information.\n\n### `src/constants/`\n\n- Directory defining constant values used throughout the application.\n  - **`controls.ts`**: Defines settings that map keyboard inputs (WASD, arrow keys, etc.) to corresponding actions (movement, jump, etc.).\n  - **`character.ts`**: Defines character-related constants including extensive animation states (idle, walk, run, jump, punch, kick, melee attack, cast, hit, dance, swim, die).\n  - **`rigidBodyObjectType.ts`**: Defines constants for different types of rigid body objects in the physics simulation (player, enemy, monster, wall, obstacle, item, bullet, floor, etc.).\n\n### `src/stores/`\n\n- Directory containing state management stores using Zustand.\n  - **`gameStore.ts`**: Store that manages the overall game state. Tracks and controls the readiness state of the map physics system (`isMapPhysicsReady`). This state is used to determine physics simulation pause/resume and loading screen display.\n  - **`localPlayerStore.ts`**: Store that manages the local player's state, such as position tracking.\n  - **`multiPlayerStore.ts`**: Store that manages multiple connected players' rigid body references for multiplayer functionality, including registration, unregistration, and retrieval of player references.\n- **`playerActionStore.ts`**: Store that manages player action states including combat actions (punch, kick, meleeAttack, cast) with support for setting, getting, and resetting action states.\n\n### `src/components/`\n\n- Directory managing React components categorized by function.\n\n  - **`r3f/`**: Contains 3D components related to React Three Fiber.\n\n    - **`Experience.tsx`**: Simplified 3D scene component that focuses on core scene elements. Includes ambient lighting with 0.7 intensity, sunset environment preset (background disabled), the `Player` component, and the `Floor` component. This component has been streamlined to contain only essential scene elements.\n    - **`Floor.tsx`**: Component defining and visually representing the ground plane in the 3D space. Has physical properties.\n    - **`GameSceneCanvas.tsx`**: React Three Fiber Canvas component that renders the 3D game world with physics simulation and controller setup.\n    - **`MapPhysicsReadyChecker.tsx`**: Component that checks if the map physics system is ready by performing raycasting from above downward to detect map geometry and ensures physics interactions are properly initialized before gameplay begins. Performs checks every frame until valid map geometry is detected, with a timeout after 180 frames to prevent infinite checking. Excludes Capsule shapes (likely characters/objects) and sensor colliders from the inspection.\n    - **`Player.tsx`**: Advanced component built around the `RigidBodyPlayer` component from vibe-starter-3d for physics-based character control. Handles comprehensive player character logic including movement, rotation, extensive animation state management (idle, walk, run, jump, punch, kick, melee attack, cast, hit, dance, swim, die), collision detection, game server integration, and player reference management. Features sophisticated animation configuration mapping and state determination logic. Utilizes `RigidBodyPlayer`'s `onTriggerEnter` and `onTriggerExit` events to handle player interactions with other objects in the 3D environment, enabling collision-based gameplay mechanics. Integrates with `CharacterRenderer` for visual representation and animation playback.\n\n  - **`scene/`**: Contains components related to scene setup.\n\n    - **`GameScene.tsx`**: Main game scene component that serves as a layout container arranging the game UI and 3D Canvas. Contains critical performance warnings and guidelines to prevent re-rendering issues. Includes the `GameSceneCanvas` and `GameSceneUI` components in a proper layered structure where the Canvas renders the 3D world and UI components render as overlays.\n\n  - **`ui/`**: Contains UI components for the game interface.\n    - **`GameSceneUI.tsx`**: Component that manages UI overlays for the game scene.\n    - **`LoadingScreen.tsx`**: Loading screen component displayed during game loading.\n    - **`InputController.tsx`**: Manages all input handling including keyboard, mouse, and touch controls with virtual joystick support for mobile devices and action buttons for combat actions (punch, kick, melee attack, cast) and movement controls.\n",
    isBinary: false,
  },
  'server.js': {
    type: 'file',
    content: 'class Server {}\n',
    isBinary: false,
  },
  'tsconfig.json': {
    type: 'file',
    content:
      '{\n  "files": [],\n  "references": [\n    { "path": "./tsconfig.app.json" },\n    { "path": "./tsconfig.node.json" }\n  ]\n}\n',
    isBinary: false,
  },
  'tsconfig.app.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",\n    "target": "ES2020",\n    "useDefineForClassFields": true,\n    "lib": ["ES2020", "DOM", "DOM.Iterable"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n    "jsx": "react-jsx",\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["src"]\n}\n',
    isBinary: false,
  },
  'tailwind.config.js': {
    type: 'file',
    content:
      '/** @type {import(\'tailwindcss\').Config} */\nexport default {\n  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n',
    isBinary: false,
  },
  'postcss.config.js': {
    type: 'file',
    content: 'export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n',
    isBinary: false,
  },
  'tsconfig.node.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",\n    "target": "ES2022",\n    "lib": ["ES2023"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["vite.config.ts"]\n}\n',
    isBinary: false,
  },
  'docs/project-3d-rules.md': {
    type: 'file',
    content:
      "# 3D Project Development Rules\n\n## Guideline for Using `RigidBodyObject`\n\nWhen implementing physics interactions, it is mandatory to use the `RigidBodyObject` component from the `vibe-starter-3d` package instead of the standard `RigidBody` from `@react-three/rapier`.\n\nThe primary reason for this is to simplify event handling for collisions and intersections. Using the standard `RigidBody` component requires managing a complex set of events (`onCollisionEnter`, `onCollisionExit`, `onIntersectionEnter`, `onIntersectionExit`).\n\nIn contrast, `RigidBodyObject` abstracts this complexity. It allows you to handle all physics-based interactions uniformly through just two simple trigger events: `onTriggerEnter` and `onTriggerExit`. This makes the interaction logic significantly cleaner and easier to manage.\n\n## Canvas Component Structure Rules\n\n**Core Requirement:** Components that render HTML tags (e.g., `<div>`, `<button>`) must NEVER be placed inside React Three Fiber's `<Canvas>` component.\n\n**Reasoning:**\nThis is a core architectural rule. Placing standard HTML inside the `<Canvas>` WebGL context will cause rendering errors.\n\n**Implementation Guidelines:**\n\n- **UI Components:** Components using HTML tags belong in the `src/components/ui/` directory. They must be rendered as an overlay, outside the `<Canvas>`.\n- **3D Components:** Only Three.js-related components, located in `src/components/r3f/`, should be placed inside the `<Canvas>`.\n\n**Correct Structure Example:**\n\n```tsx\n// ‚úÖ Correct approach\n<div>\n  {/* The 3D scene is rendered inside the Canvas */}\n  <Canvas>\n    <Player />\n    <Floor />\n  </Canvas>\n\n  {/* UI components are rendered as overlays outside the Canvas */}\n  <Crosshair />\n  <LoadingScreen />\n</div>\n```\n\n**Incorrect Structure Example:**\n\n```tsx\n// ‚ùå Incorrect approach\n<Canvas>\n  <Player />\n  {/* This is forbidden, as Crosshair renders HTML */}\n  <Crosshair />\n</Canvas>\n```\n",
    isBinary: false,
  },
  'vite.config.ts.js': {
    type: 'file',
    content:
      '// vite.config.ts\nimport { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\nvar vite_config_default = defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"]\n  },\n  base: "./",\n  build: {\n    outDir: "dist"\n  }\n});\nexport {\n  vite_config_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsidml0ZS5jb25maWcudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IGRlZmluZUNvbmZpZyB9IGZyb20gXCJ2aXRlXCI7XG5pbXBvcnQgcmVhY3QgZnJvbSBcIkB2aXRlanMvcGx1Z2luLXJlYWN0XCI7XG5cbi8vIGh0dHBzOi8vdml0ZWpzLmRldi9jb25maWcvXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVDb25maWcoe1xuICBwbHVnaW5zOiBbcmVhY3QoKV0sXG4gIG9wdGltaXplRGVwczoge1xuICAgIGV4Y2x1ZGU6IFtcImx1Y2lkZS1yZWFjdFwiXSxcbiAgfSxcbiAgYmFzZTogXCIuL1wiLFxuICBidWlsZDoge1xuICAgIG91dERpcjogXCJkaXN0XCIsXG4gIH0sXG59KTtcbiJdLAogICJtYXBwaW5ncyI6ICI7QUFBQTtBQUNBO0FBR0EsSUFBTyxzQkFBUSxhQUFhO0FBQUEsRUFDMUIsU0FBUyxDQUFDO0FBQUEsRUFDVixjQUFjO0FBQUEsSUFDWixTQUFTLENBQUM7QUFBQTtBQUFBLEVBRVosTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLElBQ0wsUUFBUTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==\n',
    isBinary: false,
  },
  'vite.config.ts': {
    type: 'file',
    content:
      'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"],\n  },\n  base: "./",\n  build: {\n    outDir: "dist",\n  },\n});\n',
    isBinary: false,
  },
  'src/App.tsx': {
    type: 'file',
    content:
      "import React from 'react';\nimport './App.css';\nimport GameScene from './components/scene/GameScene.tsx';\n\nconst App: React.FC = () => {\n  return (\n    <div style={{ width: '100vw', height: '100vh' }}>\n      <GameScene />\n    </div>\n  );\n};\n\nexport default App;\n",
    isBinary: false,
  },
  'src/App.css': {
    type: 'file',
    content: '#root {\n  margin: 0 auto;\n  text-align: center;\n}\n',
    isBinary: false,
  },
  'src/assets.json': {
    type: 'file',
    content:
      '{\n  "characters": {\n    "base-model": {\n      "url": "https://agent8-games.verse8.io/assets/3d/characters/realistic style/base-model.glb"\n    }\n  },\n  "animations": {\n    "idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle.glb",\n      "description": "Idle"\n    },\n    "idle-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle-00.glb",\n      "description": "Idle 00"\n    },\n    "idle-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle-01.glb",\n      "description": "Idle 01"\n    },\n    "rifle-idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/rifle-idle.glb",\n      "description": "Rifle idle"\n    },\n    "pistol-idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/pistol-idle.glb",\n      "description": "Pistol idle"\n    },\n    "walk": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/walk.glb",\n      "description": "Walk"\n    },\n    "run-medium": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/run-medium.glb",\n      "description": "Run Medium"\n    },\n    "run-fast": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/run-fast.glb",\n      "description": "Run Fast"\n    },\n    "rifle-run": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/rifle-run.glb",\n      "description": "Rifle Run"\n    },\n    "pistol-run": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/pistol-run.glb",\n      "description": "Pistol Run"\n    },\n    "jump": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/jump.glb",\n      "description": "Jump"\n    },\n    "swim": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/swim.glb",\n      "description": "Swim"\n    },\n    "punch-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/punch-00.glb",\n      "description": "Punch 00"\n    },\n    "punch-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/punch-01.glb",\n      "description": "Punch 01"\n    },\n    "kick-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-00.glb",\n      "description": "Kick 00"\n    },\n    "kick-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-01.glb",\n      "description": "Kick 01"\n    },\n    "kick-02": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-02.glb",\n      "description": "Kick 02"\n    },\n    "melee-attack": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/melee-attack.glb",\n      "description": "Melee Attack"\n    },\n    "cast": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/cast.glb",\n      "description": "Cast"\n    },\n    "dance-locking": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/dance-locking.glb",\n      "description": "Dance Locking"\n    },\n    "dance-wave": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/dance-wave.glb",\n      "description": "Dance Wave"\n    },\n    "death-backward": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/death-backward.glb",\n      "description": "Death Backward"\n    },\n    "death-foward": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/death-foward.glb",\n      "description": "Death Foward"\n    },\n    "hit-to-body": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/hit-to-body.glb",\n      "description": "Hit to Body"\n    }\n  }\n}\n',
    isBinary: false,
  },
  'src/main.tsx': {
    type: 'file',
    content:
      "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport './index.css';\nimport App from './App.tsx';\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n",
    isBinary: false,
  },
  'src/index.css': {
    type: 'file',
    content: '@tailwind base;\n@tailwind components;\n@tailwind utilities;\n',
    isBinary: false,
  },
  'src/constants/character.ts': {
    type: 'file',
    content:
      "import { AnimationType } from 'vibe-starter-3d';\n\nexport const CharacterState: { [key: string]: AnimationType } = {\n  /** IDLE ACTION */\n  IDLE: 'IDLE',\n  /** IDLE ACTION */\n  IDLE_01: 'IDLE_01',\n  /** WALKING ACTION */\n  WALK: 'WALK',\n  /** RUNNING ACTION */\n  RUN: 'RUN',\n  /** SPRINTING ACTION */\n  FAST_RUN: 'FAST_RUN',\n  /** JUMP ACTION */\n  JUMP: 'JUMP',\n  /** PUNCH ACTION */\n  PUNCH: 'PUNCH',\n  /** PUNCH ACTION */\n  PUNCH_01: 'PUNCH_01',\n  /** KICK ACTION */\n  KICK: 'KICK',\n  /** KICK ACTION */\n  KICK_01: 'KICK_01',\n  /** KICK ACTION */\n  KICK_02: 'KICK_02',\n  /** MELEE ATTACK ACTION */\n  MELEE_ATTACK: 'MELEE_ATTACK',\n  /** CAST ACTION */\n  CAST: 'CAST',\n  /** HIT ACTION */\n  HIT: 'HIT',\n  /** DIE ACTION */\n  DIE: 'DIE',\n};\n\nexport type CharacterState = (typeof CharacterState)[keyof typeof CharacterState];\n",
    isBinary: false,
  },
  'src/constants/rigidBodyObjectType.ts': {
    type: 'file',
    content:
      "export const RigidBodyObjectType = {\n  /** Local Player */\n  LOCAL_PLAYER: 'LOCAL_PLAYER',\n  /** Enemy */\n  ENEMY: 'ENEMY',\n  /** Monster */\n  MONSTER: 'MONSTER',\n  /** Wall */\n  WALL: 'WALL',\n  /** Obstacle */\n  OBSTACLE: 'OBSTACLE',\n  /** Item */\n  ITEM: 'ITEM',\n  /** Bullet */\n  BULLET: 'BULLET',\n  /** Floor */\n  FLOOR: 'FLOOR',\n  /** Floating board */\n  PLOTTING_BOARD: 'PLOTTING_BOARD',\n} as const;\n",
    isBinary: false,
  },
  'src/stores/gameStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\ninterface GameStore {\n  isMapPhysicsReady: boolean;\n  setMapPhysicsReady: (ready: boolean) => void;\n}\n\nexport const useGameStore = create<GameStore>()(\n  subscribeWithSelector((set) => ({\n    isMapPhysicsReady: false,\n    setMapPhysicsReady: (ready: boolean) => set({ isMapPhysicsReady: ready }),\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/localPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport * as THREE from 'three';\n\ntype PlayerState = {\n  position: THREE.Vector3;\n};\n\ntype LocalPlayerState = {\n  state: PlayerState;\n  setPosition: (x: number, y: number, z: number) => void;\n  clearPosition: () => void;\n};\n\nexport const useLocalPlayerStore = create<LocalPlayerState>()(\n  subscribeWithSelector((_, get) => ({\n    state: {\n      position: new THREE.Vector3(0, 0, 0),\n    },\n\n    setPosition: (x: number, y: number, z: number) => {\n      const state = get().state;\n      state.position.x = x;\n      state.position.y = y;\n      state.position.z = z;\n    },\n\n    clearPosition: () => {\n      const state = get().state;\n      state.position.x = 0;\n      state.position.y = 0;\n      state.position.z = 0;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/multiPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport React from 'react';\nimport { RigidBody } from '@dimforge/rapier3d-compat';\n\ntype MultiPlayerRigidBodyState = {\n  connectedPlayerRefs: Record<string, React.RefObject<RigidBody>>;\n  registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => void;\n  unregisterConnectedPlayer: (account: string) => void;\n  getConnectedPlayerRef: (account: string) => React.RefObject<RigidBody> | undefined;\n  getAllConnectedPlayerRefs: () => Record<string, React.RefObject<RigidBody>>;\n  getConnectedPlayerCount: () => number;\n};\n\nexport const useMultiPlayerStore = create<MultiPlayerRigidBodyState>()(\n  subscribeWithSelector((set, get) => ({\n    connectedPlayerRefs: {},\n\n    registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => {\n      set((state) => ({\n        connectedPlayerRefs: {\n          ...state.connectedPlayerRefs,\n          [account]: rigidBodyRef,\n        },\n      }));\n    },\n\n    unregisterConnectedPlayer: (account: string) => {\n      set((state) => {\n        const newConnectedPlayerRefs = { ...state.connectedPlayerRefs };\n        delete newConnectedPlayerRefs[account];\n        return { connectedPlayerRefs: newConnectedPlayerRefs };\n      });\n    },\n\n    getConnectedPlayerRef: (account: string) => {\n      return get().connectedPlayerRefs[account];\n    },\n\n    getAllConnectedPlayerRefs: () => {\n      return get().connectedPlayerRefs;\n    },\n\n    getConnectedPlayerCount: () => {\n      return Object.keys(get().connectedPlayerRefs).length;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/playerActionStore.ts': {
    type: 'file',
    content:
      'interface PlayerActionState {\n  punch: boolean;\n  kick: boolean;\n  meleeAttack: boolean;\n  cast: boolean;\n}\n\ninterface PlayerActionStore extends PlayerActionState {\n  setPlayerAction: (action: string, pressed: boolean) => void;\n  getPlayerAction: (action: string) => boolean;\n  resetAllPlayerActions: () => void;\n}\n\nconst playerActionStore: PlayerActionStore = {\n  punch: false,\n  kick: false,\n  meleeAttack: false,\n  cast: false,\n\n  setPlayerAction: (action: string, pressed: boolean) => {\n    (playerActionStore as any)[action] = pressed;\n  },\n\n  getPlayerAction: (action: string): boolean => {\n    return (playerActionStore as any)[action];\n  },\n\n  resetAllPlayerActions: () => {\n    playerActionStore.punch = false;\n    playerActionStore.kick = false;\n    playerActionStore.meleeAttack = false;\n    playerActionStore.cast = false;\n  },\n};\n\nexport const usePlayerActionStore = () => playerActionStore;',
    isBinary: false,
  },
  'src/components/scene/GameScene.tsx': {
    type: 'file',
    content:
      "import GameSceneCanvas from '../r3f/GameSceneCanvas';\nimport GameSceneUI from '../ui/GameSceneUI';\n\n/**\n * Main Game Scene Component\n *\n * This component serves as a layout container that arranges the game UI and 3D Canvas.\n *\n * üö® CRITICAL PERFORMANCE WARNING:\n * Re-rendering of this component triggers re-rendering of the entire 3D Canvas, causing severe performance degradation.\n *\n * Prohibited Actions:\n * - Using state management hooks like useState, useReducer\n * - Passing frequently changing values as props\n * - State updates inside useEffect\n * - Conditional rendering that changes component structure\n * - Creating inline objects/functions (e.g., style={{...}}, onClick={() => {}})\n *\n * Recommendations:\n * - Handle state management in child components (GameSceneUI, GameSceneCanvas)\n * - Access global state directly through zustand store or similar\n * - Memoize event handlers with useCallback before use\n */\nconst GameScene = () => {\n  return (\n    <div className=\"relative w-full h-screen\">\n      <GameSceneUI />\n      <GameSceneCanvas />\n    </div>\n  );\n};\n\nexport default GameScene;\n",
    isBinary: false,
  },
  'src/components/r3f/Floor.tsx': {
    type: 'file',
    content:
      'import { RigidBodyObject } from \'vibe-starter-3d\';\nimport { RigidBodyObjectType } from \'../../constants/rigidBodyObjectType\';\n\nfunction Floor() {\n  return (\n    <RigidBodyObject type="fixed" colliders="trimesh" userData={{ type: RigidBodyObjectType.FLOOR }}>\n      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow position={[0, 0, 0]}>\n        <planeGeometry args={[100, 100]} />\n        <meshStandardMaterial color="#3f3f3f" />\n      </mesh>\n    </RigidBodyObject>\n  );\n}\n\nexport default Floor;\n',
    isBinary: false,
  },
  'src/components/r3f/GameSceneCanvas.tsx': {
    type: 'file',
    content:
      "import React, { Suspense } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { Physics } from '@react-three/rapier';\nimport { FollowLight, FreeViewController, IS_MOBILE } from 'vibe-starter-3d';\nimport { useGameStore } from '../../stores/gameStore';\nimport { Environment } from '@react-three/drei';\nimport MapPhysicsReadyChecker from '../r3f/MapPhysicsReadyChecker';\nimport Player from './Player';\nimport Floor from './Floor';\n\n/**\n * Game Scene Canvas Component\n *\n * This component is responsible for rendering the entire 3D game world using React Three Fiber.\n * It serves as the root container for all 3D elements, physics simulation, and game interactions.\n */\nconst GameSceneCanvas = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* ‚ö†Ô∏è DO NOT DELETE: Core Canvas component for React Three Fiber */}\n      <Canvas\n        shadows\n        onPointerDown={(e) => {\n          if (!IS_MOBILE) {\n            (e.target as HTMLCanvasElement).requestPointerLock();\n          }\n        }}\n      >\n        <Physics paused={!isMapPhysicsReady}>\n          <Suspense fallback={null}>\n            {/* ‚ö†Ô∏è MUST INCLUDE: Essential checker for map physics initialization */}\n            {!isMapPhysicsReady && <MapPhysicsReadyChecker />}\n            <FreeViewController />\n            <Environment preset=\"sunset\" background={false} />\n            <ambientLight intensity={0.7} />\n            <FollowLight />\n            <Player />\n            <Floor />\n          </Suspense>\n        </Physics>\n      </Canvas>\n    </>\n  );\n};\n\nexport default GameSceneCanvas;\n",
    isBinary: false,
  },
  'src/components/r3f/MapPhysicsReadyChecker.tsx': {
    type: 'file',
    content:
      "import { useFrame } from '@react-three/fiber';\nimport { useRapier } from '@react-three/rapier';\nimport { useRef } from 'react';\nimport * as THREE from 'three';\nimport { useGameStore } from '../../stores/gameStore';\n\n/**\n * Component that checks if the map physics is ready by performing raycasting.\n * Casts a ray downward from above to detect map geometry and ensures physics\n * interactions are properly initialized before gameplay begins.\n *\n * - Performs checks every frame until map physics is confirmed ready\n * - Times out after 60 frames as fallback to prevent infinite checking\n * - Excludes Capsule shapes (likely characters/objects) and sensor colliders\n * - Sets mapPhysicsReady to true once valid map geometry is detected\n */\nfunction MapPhysicsReadyChecker() {\n  const { isMapPhysicsReady, setMapPhysicsReady } = useGameStore();\n  const physicsCheckCount = useRef(0);\n  const { rapier, world } = useRapier();\n\n  useFrame(() => {\n    if (isMapPhysicsReady) return;\n\n    physicsCheckCount.current++;\n    if (physicsCheckCount.current > 180) {\n      setMapPhysicsReady(true);\n      return;\n    }\n\n    const origin = new THREE.Vector3(0, 50, 0);\n    const downDirection = new THREE.Vector3(0, -1, 0);\n    const ray = new rapier.Ray(origin, downDirection);\n\n    // Get all intersections and find the first non-sensor collider\n    const intersections: any[] = [];\n    world.propagateModifiedBodyPositionsToColliders();\n    world.updateSceneQueries();\n    world.intersectionsWithRay(ray, 100, true, (intersection) => {\n      // Exclude Capsule shapes as they are unlikely to be map colliders\n      if (intersection.collider.shape.type === rapier.ShapeType.Capsule) {\n        return true;\n      }\n      intersections.push(intersection);\n      return true; // continue searching\n    });\n\n    // Find the first non-sensor collider\n    const validHit = intersections.find((intersection) => !intersection.collider.isSensor());\n    if (!validHit) return;\n\n    console.log('%c[vibe-starter-3d]%c Map physics initialized.', 'color: #7159c1; font-weight: bold', 'color: inherit;');\n    setMapPhysicsReady(true);\n  });\n\n  return null;\n}\n\nexport default MapPhysicsReadyChecker;\n",
    isBinary: false,
  },
  'src/components/r3f/Player.tsx': {
    type: 'file',
    content:
      "import React, { useRef, useEffect, useCallback } from 'react';\nimport { useFrame, Vector3 } from '@react-three/fiber';\nimport { CollisionPayload } from '@react-three/rapier';\nimport { useGameServer } from '@agent8/gameserver';\n\nimport { useLocalPlayerStore } from '../../stores/localPlayerStore';\nimport { useMultiPlayerStore } from '../../stores/multiPlayerStore';\n\nimport { CharacterState } from '../../constants/character';\nimport { RigidBodyObjectType } from '../../constants/rigidBodyObjectType';\n\nimport Assets from '../../assets.json';\nimport {\n  AnimationConfigMap,\n  AnimationType,\n  CharacterMovementState,\n  CharacterRenderer,\n  RigidBodyPlayer,\n  RigidBodyPlayerRef,\n  useCharacterAnimation,\n  useControllerStore,\n} from 'vibe-starter-3d';\nimport { usePlayerActionStore } from '../../stores/playerActionStore';\n\nconst targetHeight = 1.6;\n\n// States that can be interrupted by actions\nconst INTERRUPTIBLE_STATES = [\n  CharacterState.IDLE,\n  CharacterState.IDLE_01,\n  CharacterState.WALK,\n  CharacterState.RUN,\n  CharacterState.FAST_RUN,\n  CharacterState.JUMP,\n] as const;\n\n// Animation configuration map moved outside component for better performance\nconst animationConfigMap: AnimationConfigMap = {\n  [CharacterState.IDLE]: {\n    url: Assets.animations['idle-00'].url,\n    loop: true,\n  },\n  [CharacterState.IDLE_01]: {\n    url: Assets.animations['idle-01'].url,\n    loop: true,\n  },\n  [CharacterState.WALK]: {\n    url: Assets.animations['walk'].url,\n    loop: true,\n  },\n  [CharacterState.RUN]: {\n    url: Assets.animations['run-medium'].url,\n    loop: true,\n  },\n  [CharacterState.FAST_RUN]: {\n    url: Assets.animations['run-fast'].url,\n    loop: true,\n  },\n  [CharacterState.JUMP]: {\n    url: Assets.animations['jump'].url,\n    loop: true,\n    clampWhenFinished: true,\n  },\n  [CharacterState.PUNCH]: {\n    url: Assets.animations['punch-00'].url,\n    loop: false,\n    duration: 0.5,\n    clampWhenFinished: true,\n  },\n  [CharacterState.PUNCH_01]: {\n    url: Assets.animations['punch-01'].url,\n    loop: false,\n    duration: 0.5,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK]: {\n    url: Assets.animations['kick-00'].url,\n    loop: false,\n    duration: 0.75,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK_01]: {\n    url: Assets.animations['kick-01'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK_02]: {\n    url: Assets.animations['kick-02'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.MELEE_ATTACK]: {\n    url: Assets.animations['melee-attack'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.CAST]: {\n    url: Assets.animations['cast'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.HIT]: {\n    url: Assets.animations['hit-to-body'].url,\n    loop: false,\n    clampWhenFinished: false,\n  },\n  [CharacterState.DANCE]: {\n    url: Assets.animations['dance-wave'].url,\n    loop: false,\n    clampWhenFinished: false,\n  },\n  [CharacterState.SWIM]: {\n    url: Assets.animations['swim'].url,\n    loop: true,\n  },\n  [CharacterState.DIE]: {\n    url: Assets.animations['death-backward'].url,\n    loop: false,\n    clampWhenFinished: true,\n  },\n};\n\n/**\n * Player props\n */\ninterface PlayerProps {\n  /** Initial position of the player */\n  position?: Vector3;\n}\n\n/**\n * Player component that manages character model and animations\n *\n * Handles player state management and delegates rendering to CharacterRenderer.\n * Movement states come from ControllerStore, actions are handled locally.\n */\nconst Player = ({ position }: PlayerProps) => {\n  const { account } = useGameServer();\n  const { registerConnectedPlayer, unregisterConnectedPlayer } = useMultiPlayerStore();\n  const { setPosition: setLocalPlayerPosition } = useLocalPlayerStore();\n  const { getPlayerAction } = usePlayerActionStore();\n\n  // Use the new useCharacterAnimation hook\n  const { animationState, setAnimation, getAnimation } = useCharacterAnimation<CharacterState>(CharacterState.IDLE);\n\n  // Get movement state from controller store (unified API)\n  const { getCharacterMovementState, isControlLocked, lockControls, unlockControls } = useControllerStore();\n\n  // IMPORTANT: rigidBodyPlayerRef.current type is RigidBody\n  const rigidBodyPlayerRef = useRef<RigidBodyPlayerRef>(null);\n\n  // IMPORTANT: Register connected player reference\n  useEffect(() => {\n    if (!account) return;\n\n    registerConnectedPlayer(account, rigidBodyPlayerRef);\n\n    return () => {\n      unregisterConnectedPlayer(account);\n    };\n  }, [account, registerConnectedPlayer, unregisterConnectedPlayer]);\n\n  // IMPORTANT: Update local player store position information\n  useFrame(() => {\n    const playerRigidBody = rigidBodyPlayerRef.current;\n    if (!playerRigidBody) return;\n\n    const position = playerRigidBody.translation();\n    setLocalPlayerPosition(position.x, position.y, position.z);\n  });\n\n  // Helper functions\n  const canInterrupt = useCallback((state: CharacterState): boolean => {\n    return INTERRUPTIBLE_STATES.includes(state);\n  }, []);\n\n  // Convert ControllerStore state to Player animation state\n  const toCharacterState = useCallback((characterMovementState: CharacterMovementState): CharacterState => {\n    switch (characterMovementState) {\n      case CharacterMovementState.IDLE:\n        return CharacterState.IDLE;\n      case CharacterMovementState.WALKING:\n        return CharacterState.WALK;\n      case CharacterMovementState.RUN:\n        return CharacterState.RUN;\n      case CharacterMovementState.FAST_RUN:\n        return CharacterState.FAST_RUN;\n      case CharacterMovementState.AIRBORNE:\n        return CharacterState.JUMP;\n      default:\n        return CharacterState.IDLE;\n    }\n  }, []);\n\n  // Callback triggered when a non-looping animation finishes.\n  const handleAnimationComplete = useCallback(\n    (type: AnimationType) => {\n      unlockControls();\n      switch (type) {\n        case CharacterState.PUNCH:\n        case CharacterState.PUNCH_01:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.KICK:\n        case CharacterState.KICK_01:\n        case CharacterState.KICK_02:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.CAST:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.HIT:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.MELEE_ATTACK:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.DANCE:\n          setAnimation(CharacterState.IDLE);\n          break;\n        default:\n          break;\n      }\n    },\n    [unlockControls, setAnimation],\n  );\n\n  const updatePlayerState = useCallback((): void => {\n    const currentState = getAnimation();\n\n    // If controls are locked, don't process actions\n    if (isControlLocked()) {\n      return;\n    }\n\n    // Handle death and revive states\n    // TODO: Connect with actual game state\n    // const isRevive = playerHealth > 0 && currentState === CharacterState.DIE;\n    // const isDying = playerHealth <= 0 && currentState !== CharacterState.DIE;\n\n    // Currently using placeholder false values\n    const isRevive = false;\n    const isDying = false;\n\n    // Revive handling: when health is restored while in death state\n    if (isRevive) {\n      setAnimation(CharacterState.IDLE);\n      return;\n    }\n\n    // Death handling: when health drops to 0 or below\n    if (isDying) {\n      setAnimation(CharacterState.DIE);\n      return;\n    }\n\n    // Handle action states (punch, kick, etc.) - highest priority\n    if (getPlayerAction('punch') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.PUNCH);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('kick') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.KICK);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('meleeAttack') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.MELEE_ATTACK);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('cast') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.CAST);\n      lockControls();\n      return;\n    }\n\n    // For movement states, use ControllerStore state\n    if (canInterrupt(currentState)) {\n      const characterMovementState = getCharacterMovementState();\n      const characterState = toCharacterState(characterMovementState);\n      setAnimation(characterState);\n    }\n  }, [isControlLocked, canInterrupt, lockControls, getCharacterMovementState, toCharacterState, getAnimation, setAnimation, getPlayerAction]);\n\n  // Update player action state based on inputs and physics\n  useFrame(() => {\n    if (!rigidBodyPlayerRef.current) return;\n    updatePlayerState();\n  });\n\n  /** handleTriggerEnter: Called when the player intersects or collides with another object.\n   * - Handles when entering a specific area or colliding with another object\n   */\n  const handleTriggerEnter = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when entering a specific area or colliding with another object\n    }\n  };\n\n  /** handleTriggerExit: Called when the player exits an intersection or ends a collision with another object.\n   * - Handles when exiting a specific area or when collision with another object ends\n   */\n  const handleTriggerExit = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when exiting a specific area or when collision with another object ends\n    }\n  };\n\n  return (\n    <RigidBodyPlayer\n      ref={rigidBodyPlayerRef}\n      userData={{ account, type: RigidBodyObjectType.LOCAL_PLAYER }}\n      position={position}\n      targetHeight={targetHeight}\n      onTriggerEnter={handleTriggerEnter}\n      onTriggerExit={handleTriggerExit}\n    >\n      <CharacterRenderer\n        url={Assets.characters['base-model'].url}\n        animationConfigMap={animationConfigMap}\n        animationState={animationState}\n        targetHeight={targetHeight}\n        onAnimationComplete={handleAnimationComplete}\n      />\n    </RigidBodyPlayer>\n  );\n};\n\nexport default Player;\n",
    isBinary: false,
  },
  'src/components/ui/GameSceneUI.tsx': {
    type: 'file',
    content:
      "import { useGameStore } from '../../stores/gameStore';\nimport { InputController } from './InputController';\nimport LoadingScreen from './LoadingScreen';\n\n/**\n * Game Scene UI Component\n *\n * This component manages UI overlays for the game scene.\n * It handles loading states and displays appropriate UI elements based on game state.\n */\nconst GameSceneUI = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* Input Controller - Global input management (keyboard, touch) */}\n      <InputController disableJoystick={false} disableKeyboard={false} disabled={!isMapPhysicsReady} />\n\n      {/* Loading Game Scene screen overlay */}\n      {!isMapPhysicsReady && <LoadingScreen />}\n    </>\n  );\n};\n\nexport default GameSceneUI;\n",
    isBinary: false,
  },
  'src/components/ui/InputController.tsx': {
    type: 'file',
    content:
      "import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport * as THREE from 'three';\nimport { IS_MOBILE, useInputStore } from 'vibe-starter-3d';\nimport { usePlayerActionStore } from '../../stores/playerActionStore';\nimport nipplejs from 'nipplejs';\n\n/**\n * Key mapping configuration - simple Record<string, string[]>\n */\ntype KeyMapping = Record<string, string[]>; // action: [key1, key2, ...]\n\n/**\n * Controller key mapping\n */\nconst CONTROL_KEY_MAPPING: KeyMapping = {\n  forward: ['KeyW', 'ArrowUp'],\n  backward: ['KeyS', 'ArrowDown'],\n  leftward: ['KeyA', 'ArrowLeft'],\n  rightward: ['KeyD', 'ArrowRight'],\n  jump: ['Space'],\n  run: ['ShiftLeft', 'ShiftRight'],\n};\n\n/**\n * Player action key mapping\n */\nconst ACTION_KEY_MAPPING: KeyMapping = {\n  punch: ['KeyF', 'Mouse0'],\n  kick: ['KeyG', 'Mouse2'],\n  meleeAttack: ['KeyQ', 'KeyC'],\n  cast: ['KeyE', 'Mouse1'],\n};\n\n// Movement speed constants\nconst MOVEMENT_SPEED_WALK = 0.6;\nconst MOVEMENT_SPEED_RUN_BOOST = 0.4;\nconst MOVEMENT_SPEED_MAX = 1.0;\nconst JOYSTICK_RANGE_MULTIPLIER = 2.0; // Converts joystick range (0~0.5) to full range (0~1.0)\n\ninterface InputControllerProps {\n  disabled?: boolean;\n  disableKeyboard?: boolean;\n  disableJoystick?: boolean;\n}\n\nexport const InputController: React.FC<InputControllerProps> = ({ disabled = false, disableKeyboard = false, disableJoystick = false }) => {\n  // Store actions to controller\n  const { setMovementInput, setActionInput, resetAllInputs, setActiveInputSource } = useInputStore();\n  const { setPlayerAction, resetAllPlayerActions } = usePlayerActionStore();\n\n  // Button states\n  const [isJumpPressed, setIsJumpPressed] = useState(false);\n  const [isAttackPressed, setIsAttackPressed] = useState(false);\n\n  // Keyboard state tracking\n  const keyboardStateRef = useRef({\n    forward: false,\n    backward: false,\n    leftward: false,\n    rightward: false,\n    run: false,\n  });\n\n  // Helper function to calculate movement from keyboard state\n  const calculateKeyboardMovement = useCallback(() => {\n    const state = keyboardStateRef.current;\n\n    // Calculate direction\n    const x = (state.leftward ? 1 : 0) + (state.rightward ? -1 : 0);\n    const y = (state.forward ? 1 : 0) + (state.backward ? -1 : 0);\n\n    // Use Three.js Vector2 for efficient normalization\n    const direction = new THREE.Vector2(x, y);\n    const magnitude = direction.length();\n\n    // Normalize diagonal movement\n    if (magnitude > 0) {\n      direction.normalize();\n    }\n\n    // Calculate intensity: base speed + run boost\n    const baseIntensity = magnitude > 0 ? MOVEMENT_SPEED_WALK : 0; // Base walking speed\n    const runBoost = state.run ? MOVEMENT_SPEED_RUN_BOOST : 0; // Additional speed when running\n    const intensity = Math.min(baseIntensity + runBoost, MOVEMENT_SPEED_MAX);\n\n    return {\n      direction: { x: direction.x, y: direction.y },\n      intensity,\n    };\n  }, []);\n\n  // Joystick input handling with analog support\n  useEffect(() => {\n    if (disabled || disableJoystick || !IS_MOBILE) return;\n\n    // Create div element for left side area of screen\n    const joystickZone = document.createElement('div');\n    joystickZone.style.position = 'fixed';\n    joystickZone.style.left = '0';\n    joystickZone.style.top = '0';\n    joystickZone.style.width = '50%'; // Left 50% of screen\n    joystickZone.style.height = '100%';\n    joystickZone.style.zIndex = '1000';\n    joystickZone.style.pointerEvents = 'auto';\n    joystickZone.style.backgroundColor = 'transparent';\n    // Disable long touch events\n    joystickZone.style.touchAction = 'none';\n    joystickZone.style.userSelect = 'none';\n    joystickZone.style.setProperty('-webkit-user-select', 'none');\n    joystickZone.style.setProperty('-webkit-touch-callout', 'none');\n    document.body.appendChild(joystickZone);\n\n    const options: nipplejs.JoystickManagerOptions = {\n      zone: joystickZone,\n      color: 'white',\n      mode: 'dynamic',\n      shape: 'circle',\n    };\n\n    const manager = nipplejs.create(options);\n\n    manager.on('move', (evt, data) => {\n      if (disabled || disableJoystick) return; // Check disabled state\n      setActiveInputSource('joystick');\n\n      // Extract analog data from nipplejs\n      const angle = data.angle?.radian || 0; // Angle in radians\n      const distance = data.distance || 0; // Distance from center\n      const maxDistance = data.instance.options.size || 100; // Maximum distance\n\n      // Calculate normalized direction vector\n      // nipplejs uses mathematical coordinate system (0¬∞ = right, 90¬∞ = up)\n      // We need to convert to game coordinate system (0¬∞ = up, 90¬∞ = right)\n      const gameAngle = angle - Math.PI / 2; // Rotate by -90 degrees\n      const directionX = Math.sin(gameAngle); // Right/Left\n      const directionY = Math.cos(gameAngle); // Forward/Backward\n\n      // Calculate intensity (0.0 to 1.0) based on distance from center\n      const intensity = Math.min((distance / maxDistance) * JOYSTICK_RANGE_MULTIPLIER, MOVEMENT_SPEED_MAX);\n\n      // Set analog movement input\n      setMovementInput({ x: directionX, y: directionY }, intensity, 'joystick');\n    });\n\n    manager.on('end', () => {\n      if (disabled || disableJoystick) return; // Check disabled state\n      // Reset all inputs when joystick ends\n      setMovementInput({ x: 0, y: 0 }, 0, 'joystick');\n    });\n\n    return () => {\n      manager.destroy();\n      if (joystickZone.parentNode) {\n        joystickZone.parentNode.removeChild(joystickZone);\n      }\n    };\n  }, [disabled, disableJoystick, setMovementInput, setActiveInputSource]);\n\n  // Keyboard input handling - convert to movement immediately\n  useEffect(() => {\n    if (disabled || disableKeyboard) return;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n      let stateChanged = false;\n\n      // Handle movement keys\n      if (CONTROL_KEY_MAPPING['forward']?.includes(event.code) && !keyboardStateRef.current.forward) {\n        keyboardStateRef.current.forward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['backward']?.includes(event.code) && !keyboardStateRef.current.backward) {\n        keyboardStateRef.current.backward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['leftward']?.includes(event.code) && !keyboardStateRef.current.leftward) {\n        keyboardStateRef.current.leftward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['rightward']?.includes(event.code) && !keyboardStateRef.current.rightward) {\n        keyboardStateRef.current.rightward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['run']?.includes(event.code) && !keyboardStateRef.current.run) {\n        keyboardStateRef.current.run = true;\n        stateChanged = true;\n      }\n\n      // Handle action keys\n      if (CONTROL_KEY_MAPPING['jump']?.includes(event.code)) {\n        setActionInput('jump', true, 'keyboard');\n      }\n\n      // Handle player action keys\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(event.code)) {\n          setPlayerAction(action, true);\n        }\n      });\n\n      // Update movement if any movement-related key changed\n      if (stateChanged) {\n        const movement = calculateKeyboardMovement();\n        setMovementInput(movement.direction, movement.intensity, 'keyboard');\n      }\n    };\n\n    const handleKeyUp = (event: KeyboardEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n      let stateChanged = false;\n\n      // Handle movement keys\n      if (CONTROL_KEY_MAPPING['forward']?.includes(event.code) && keyboardStateRef.current.forward) {\n        keyboardStateRef.current.forward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['backward']?.includes(event.code) && keyboardStateRef.current.backward) {\n        keyboardStateRef.current.backward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['leftward']?.includes(event.code) && keyboardStateRef.current.leftward) {\n        keyboardStateRef.current.leftward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['rightward']?.includes(event.code) && keyboardStateRef.current.rightward) {\n        keyboardStateRef.current.rightward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['run']?.includes(event.code) && keyboardStateRef.current.run) {\n        keyboardStateRef.current.run = false;\n        stateChanged = true;\n      }\n\n      // Handle action keys\n      if (CONTROL_KEY_MAPPING['jump']?.includes(event.code)) {\n        setActionInput('jump', false, 'keyboard');\n      }\n\n      // Handle player action keys\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(event.code)) {\n          setPlayerAction(action, false);\n        }\n      });\n\n      // Update movement if any movement-related key changed\n      if (stateChanged) {\n        const movement = calculateKeyboardMovement();\n        setMovementInput(movement.direction, movement.intensity, 'keyboard');\n      }\n    };\n\n    const handleMouseDown = (event: MouseEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n\n      // Handle player action mouse keys\n      const mouseButton = `Mouse${event.button}`;\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(mouseButton)) {\n          setPlayerAction(action, true);\n        }\n      });\n    };\n\n    const handleMouseUp = (event: MouseEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n\n      // Handle player action mouse keys\n      const mouseButton = `Mouse${event.button}`;\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(mouseButton)) {\n          setPlayerAction(action, false);\n        }\n      });\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n      document.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [disabled, disableKeyboard, setMovementInput, setActionInput, setPlayerAction, calculateKeyboardMovement]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      resetAllInputs();\n      resetAllPlayerActions();\n    };\n  }, [resetAllInputs, resetAllPlayerActions]);\n\n  // Reset inputs when disabled\n  useEffect(() => {\n    if (disabled || disableKeyboard || disableJoystick) {\n      // Reset keyboard state if keyboard is disabled\n      if (disabled || disableKeyboard) {\n        keyboardStateRef.current = {\n          forward: false,\n          backward: false,\n          leftward: false,\n          rightward: false,\n          run: false,\n        };\n      }\n      // Reset button states\n      setIsJumpPressed(false);\n      setIsAttackPressed(false);\n      resetAllInputs();\n      resetAllPlayerActions();\n    }\n  }, [disabled, disableKeyboard, disableJoystick, resetAllInputs, resetAllPlayerActions]);\n\n  // Button handlers\n  const handleJumpStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation(); // Prevent event propagation\n      setIsJumpPressed(true);\n      setActionInput('jump', true, 'touch');\n    },\n    [disabled, setActionInput],\n  );\n\n  const handleJumpEnd = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation(); // Prevent event propagation\n      setIsJumpPressed(false);\n      setActionInput('jump', false, 'touch');\n    },\n    [disabled, setActionInput],\n  );\n\n  const handleAttackStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation();\n      setIsAttackPressed(true);\n      // NOTE: change to other action if needed\n      setPlayerAction('punch', true);\n    },\n    [disabled, setPlayerAction],\n  );\n\n  const handleAttackEnd = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation();\n      setIsAttackPressed(false);\n      // NOTE: change to other action if needed\n      setPlayerAction('punch', false);\n    },\n    [disabled, setPlayerAction],\n  );\n\n  // Don't render action buttons if joystick is disabled\n  if (disableJoystick) {\n    return null;\n  }\n\n  // Render action buttons\n  return (\n    <div className=\"fixed bottom-8 right-8 z-[1001]\">\n      {/* Attack Button */}\n      <div\n        className={`w-20 h-20 rounded-full bg-white/30 \n                   flex items-center justify-center cursor-pointer select-none touch-none\n                   ${isAttackPressed ? 'scale-90' : 'scale-100'} transition-transform`}\n        onMouseDown={handleAttackStart}\n        onMouseUp={handleAttackEnd}\n        onMouseLeave={handleAttackEnd}\n        onTouchStart={handleAttackStart}\n        onTouchEnd={handleAttackEnd}\n      >\n        <span className=\"text-white text-xs font-bold\">ATTACK</span>\n      </div>\n\n      {/* Jump Button */}\n      <div\n        className={`absolute bottom-0 -left-12 -top-12 w-14 h-14 rounded-full bg-white/30 \n                   flex items-center justify-center cursor-pointer select-none touch-none\n                   ${isJumpPressed ? 'scale-90' : 'scale-100'} transition-transform`}\n        onMouseDown={handleJumpStart}\n        onMouseUp={handleJumpEnd}\n        onMouseLeave={handleJumpEnd}\n        onTouchStart={handleJumpStart}\n        onTouchEnd={handleJumpEnd}\n      >\n        <span className=\"text-white text-xs font-bold\">JUMP</span>\n      </div>\n    </div>\n  );\n};\n",
    isBinary: false,
  },
  'src/components/ui/LoadingScreen.tsx': {
    type: 'file',
    content:
      "import { useThree } from '@react-three/fiber';\nimport { Html } from '@react-three/drei';\n\n/**\n * Loading screen component\n */\nconst LoadingScreen = () => {\n  let isInThreeCanvas: boolean;\n  try {\n    useThree();\n    isInThreeCanvas = true;\n  } catch {\n    isInThreeCanvas = false;\n  }\n\n  const loadingContent = (\n    <div>\n      <style>{`\n        .loading-container {\n          inset: 0;\n          z-index: 50;\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: center;\n          background-color: black;\n          color: white;\n          width: 100%;\n          height: 100%;\n        }\n        .loading-title {\n          font-size: 1.5rem;\n          font-weight: bold;\n          margin-bottom: 1rem;\n        }\n        .spinner {\n          width: 30px;\n          height: 30px;\n          border: 3px solid rgba(255, 255, 255, 0.3);\n          border-radius: 50%;\n          border-top-color: white;\n          animation: spin 1s ease-in-out infinite;\n        }\n        @keyframes spin {\n          to {\n            transform: rotate(360deg);\n          }\n        }\n      `}</style>\n      <div className=\"loading-container\">\n        <h2 className=\"loading-title\">Loading</h2>\n        <div className=\"spinner\"></div>\n      </div>\n    </div>\n  );\n\n  if (isInThreeCanvas) {\n    return (\n      <Html\n        center\n        style={{\n          width: '100vw',\n          height: '100vh',\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          pointerEvents: 'none',\n        }}\n      >\n        {loadingContent}\n      </Html>\n    );\n  }\n\n  return loadingContent;\n};\n\nexport default LoadingScreen;\n",
    isBinary: false,
  },
} as FileMap;

export const TEMPLATE_3D_BASIC_QUARTERVIEW = {
  'README.md': {
    type: 'file',
    content:
      "# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n",
    isBinary: false,
  },
  'PROJECT.md': {
    type: 'file',
    content:
      "# 3D Quarter View Game\n\n## Project Summary\n\nThis project is a 3D game where players control a character from a quarter view perspective. The game features character animations, physics-based movement, and a 3D environment. Players can control the character using keyboard to perform various actions (idle, running, jumping, attacking, etc.). This project is intended for single-player gameplay with an emphasis on character control and animation.\n\n## Implementation Strategy\n\nThis game uses a **Three.js-based 3D approach**:\n\n- React Three Fiber for 3D rendering in a React environment\n- @react-three/rapier for physics simulation\n- vibe-starter-3d library for character rendering and animation\n- Quarter view camera setup providing an angled top-down view of the game world\n\nKey technologies:\n\n- Three.js - 3D rendering\n- React Three Fiber - React integration\n- @react-three/rapier - Physics simulation\n- @react-three/drei - Useful Three.js helpers\n- vibe-starter-3d (v0.4.0) - Advanced character rendering, animation, and physics integration\n- Tailwind CSS - UI composition\n- Zustand - State management\n\n## Core Features\n\n- **Advanced Character System**: Comprehensive character rendering with physics-based rigid body integration\n- **Animation Management**: Complete animation system supporting idle, run, sprint, jump, punch, kick, normal_attack, cast, and other character states\n- **Physics Integration**: Full physics simulation with collision detection and rigid body object type definitions\n- **Quarter View Camera**: Fixed quarter-view perspective with character following for optimal gameplay experience\n- **Interactive Controls**: Keyboard-based navigation (WASD for movement, QERF for actions) with mouse interaction support\n- **Visual Environment**: Interactive ground plane with environmental collision detection and debugging grid overlay\n- **State Management**: Robust character state transitions and player reference tracking for multiplayer readiness\n- **Asset Management**: Comprehensive preloading system with progress indication for smooth gameplay\n- **3D Rendering**: High-quality 3D model rendering with smooth animation transitions\n- **Environmental Lighting**: Dynamic lighting system with follow light for enhanced visual experience\n\n## File Structure Overview\n\n#### `src/main.tsx`\n\n- Entry point for the application.\n- Sets up React rendering and mounts the `App` component.\n\n#### `src/App.tsx`\n\n- Main application component.\n- Configures the overall layout and includes the `GameScene` component.\n- Manages loading state and switches between `PreloadScene` and `GameScene`.\n\n### `src/App.css`\n\n- Defines the main styles for the `App` component and its child UI elements.\n\n### `src/index.css`\n\n- Defines global base styles, Tailwind CSS directives, fonts, etc., applied throughout the application.\n\n#### `src/assets.json`\n\n- File for managing asset metadata. Includes character model and animation information.\n\n### `src/constants/`\n\n- Directory defining constant values used throughout the application.\n  - **`controls.ts`**: Defines settings that map keyboard inputs (WASD, arrow keys, etc.) to corresponding actions (movement, jump, etc.).\n  - **`character.ts`**: Defines character-related constants (animation states, speed, etc.).\n  - **`rigidBodyObjectType.ts`**: Defines physics object types for collision detection and interaction systems.\n\n### `src/stores/`\n\n- Directory containing state management stores using Zustand.\n  - **`gameStore.ts`**: Store that manages the overall game state. Tracks and controls the readiness state of the map physics system (`isMapPhysicsReady`). This state is used to determine physics simulation pause/resume and loading screen display.\n  - **`localPlayerStore.ts`**: Store that manages the local player's state, such as position tracking.\n  - **`multiPlayerStore.ts`**: Store that manages multiple connected players' rigid body references for multiplayer functionality, including registration, unregistration, and retrieval of player references.\n  - **`playerActionStore.ts`**: Store that manages player action states including combat actions (punch, kick, meleeAttack, cast) with support for setting, getting, and resetting action states.\n\n### `src/components/`\n\n- Directory managing React components categorized by function.\n\n  - **`r3f/`**: Contains 3D components related to React Three Fiber.\n\n    - **`Experience.tsx`**: Main component responsible for the primary 3D scene configuration. Includes lighting `ambientLight`, environmental elements `Environment`, the `Player` component, and the floor `Floor`. It renders the core visual and interactive elements within the physics simulation configured in `GameScene.tsx`.\n    - **`Floor.tsx`**: Component defining and visually representing the ground plane in the 3D space. Has physical properties.\n    - **`GameSceneCanvas.tsx`**: React Three Fiber Canvas component that renders the 3D game world with physics simulation and controller setup.\n    - **`MapPhysicsReadyChecker.tsx`**: Component that checks if the map physics system is ready by performing raycasting from above downward to detect map geometry and ensures physics interactions are properly initialized before gameplay begins. Performs checks every frame until valid map geometry is detected, with a timeout after 180 frames to prevent infinite checking. Excludes Capsule shapes (likely characters/objects) and sensor colliders from the inspection.\n    - **`Player.tsx`**: Advanced player component integrating RigidBodyPlayer with CharacterRenderer for comprehensive character management, physics interactions, and animation state management with collision detection capabilities.\n\n  - **`scene/`**: Contains components related to scene setup.\n\n    - **`GameScene.tsx`**: Main game scene component that serves as a layout container arranging the game UI and 3D Canvas. Contains critical performance warnings and guidelines to prevent re-rendering issues. Includes the `GameSceneCanvas` and `GameSceneUI` components in a proper layered structure where the Canvas renders the 3D world and UI components render as overlays.\n    - **`PreloadScene.tsx`**: Manages asset preloading before the game starts. Loads all assets defined in assets.json (models, textures, etc.) and displays a loading progress bar. Ensures all assets are loaded before the game begins.\n\n  - **`ui/`**: Contains UI components for the game interface.\n    - **`GameSceneUI.tsx`**: Component that manages UI overlays for the game scene.\n    - **`LoadingScreen.tsx`**: Loading screen component displayed during game loading.\n    - **`InputController.tsx`**: Manages all input handling including keyboard, mouse, and touch controls with virtual joystick support for mobile devices and action buttons for combat actions (punch, kick, cast) and movement controls.\n\n### Key Libraries & Components from External Sources\n\n- **`vibe-starter-3d`**: A library providing foundational 3D game components and utilities.\n  - **`QuarterViewController`**: Wraps the player character and manages quarter view navigation by implementing a character controller with physics. It handles character movement, rotation, and camera following with a fixed quarter-view perspective.\n  - **`CharacterRenderer`**: Renders 3D character models with animations from glTF/GLB files. Manages animation states and transitions based on player actions.\n  - **`useControllerState`**: A React hook that provides control state management for the character, including:\n    - `setEnableInput`: Function to enable/disable player input controls\n    - `rigidBody`: Reference to the physics body for the character\n  - **`useMouseControls`**: A React hook that provides access to mouse input state (left/right buttons and positions).\n\n### Quarter View System Implementation\n\nThe quarter view control system is implemented through a combination of components:\n\n1. **Controller System**: `QuarterViewController` from the vibe-starter-3d library handles the physics-based movement of the character based on keyboard inputs, maintaining a fixed camera angle that provides the quarter view perspective with character following.\n\n2. **Input Management**: Keyboard inputs are captured through React Three Fiber's `useKeyboardControls` hook, which maps WASD/arrow keys to movement, and additional keys (Q/E/R/F) to character actions, with mouse controls for additional interactions.\n\n3. **State Management**: `useControllerState` hook provides shared state between components, allowing different parts of the application to access and modify the character's state. Additionally, `playerStore` manages physics body references for multiplayer support.\n\n4. **Animation Management**: `Player` component with `RigidBodyPlayer` integration determines appropriate animations based on movement and action states, transitioning between idle, walking, running, and action animations as needed, with full collision detection capabilities.\n\n5. **Asset Management**: `PreloadScene` component ensures all 3D models, textures, and other assets are preloaded before gameplay begins, providing a smooth user experience with a visual loading indicator.\n",
    isBinary: false,
  },
  'package.json': {
    type: 'file',
    content:
      '{\n  "name": "quarterview",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "lint": "eslint .",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@agent8/gameserver": "^1.5.3",\n    "vibe-starter-3d": "^0.8.18",\n    "@react-three/drei": "9.122.0",\n    "@react-three/fiber": "8.18.0",\n    "@react-three/postprocessing": "2.19.1",\n    "@react-three/rapier": "1.5.0",\n    "@dimforge/rapier3d-compat": "0.14.0",\n    "nipplejs": "0.10.2",\n    "lucide-react": "0.482.0",\n    "react": "18.3.1",\n    "react-dom": "18.3.1",\n    "three": "0.174.0",\n    "three-stdlib": "2.35.14",\n    "zustand": "5.0.3"\n  },\n  "devDependencies": {\n    "@types/react": "^18.3.1",\n    "@types/react-dom": "^18.3.1",\n    "@types/three": "^0.174.0",\n    "@vitejs/plugin-react": "^4.3.4",\n    "autoprefixer": "^10.4.21",\n    "globals": "^16.0.0",\n    "tailwindcss": "^3.4.1",\n    "typescript": "~5.8.2",\n    "vite": "^6.2.2"\n  }\n}\n',
    isBinary: false,
  },
  'index.html': {
    type: 'file',
    content:
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + React + TS</title>\n    <style>\n      body {\n        margin: 0;\n        padding: 0;\n        font-family: Arial, sans-serif;\n      }\n      .loading-container {\n        position: fixed;\n        inset: 0;\n        z-index: 50;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background-color: black;\n        color: white;\n      }\n      .loading-title {\n        font-size: 1.5rem;\n        font-weight: bold;\n        margin-bottom: 1rem;\n      }\n      .spinner {\n        width: 30px;\n        height: 30px;\n        border: 3px solid rgba(255, 255, 255, 0.3);\n        border-radius: 50%;\n        border-top-color: white;\n        animation: spin 1s ease-in-out infinite;\n      }\n      @keyframes spin {\n        to {\n          transform: rotate(360deg);\n        }\n      }\n    </style>\n    <script>\n      (function () {\n        function reportGameSize() {\n          const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n\n          const width = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n\n          window.parent.postMessage(\n            {\n              type: \'GAME_SIZE_RESPONSE\',\n              height: height,\n              width: width,\n            },\n            \'*\',\n          );\n        }\n\n        window.addEventListener(\'load\', reportGameSize);\n\n        window.addEventListener(\'resize\', reportGameSize);\n\n        window.addEventListener(\'message\', function (event) {\n          if (event.data && event.data.type === \'REQUEST_GAME_SIZE\') {\n            reportGameSize();\n          }\n        });\n      })();\n    </script>\n  </head>\n  <body>\n    <div id="root">\n      <div class="loading-container">\n        <h2 class="loading-title">Loading</h2>\n        <div class="spinner"></div>\n      </div>\n    </div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    isBinary: false,
  },
  '.gitignore': {
    type: 'file',
    content:
      '# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n',
    isBinary: false,
  },
  'postcss.config.js': {
    type: 'file',
    content: 'export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n',
    isBinary: false,
  },
  'tailwind.config.js': {
    type: 'file',
    content:
      '/** @type {import(\'tailwindcss\').Config} */\nexport default {\n  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n',
    isBinary: false,
  },
  'tsconfig.app.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",\n    "target": "ES2020",\n    "useDefineForClassFields": true,\n    "lib": ["ES2020", "DOM", "DOM.Iterable"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n    "jsx": "react-jsx",\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["src"]\n}\n',
    isBinary: false,
  },
  'tsconfig.json': {
    type: 'file',
    content:
      '{\n  "files": [],\n  "references": [\n    { "path": "./tsconfig.app.json" },\n    { "path": "./tsconfig.node.json" }\n  ]\n}\n',
    isBinary: false,
  },
  'tsconfig.node.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",\n    "target": "ES2022",\n    "lib": ["ES2023"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["vite.config.ts"]\n}\n',
    isBinary: false,
  },
  'public/vite.svg': {
    type: 'file',
    content:
      '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>',
    isBinary: false,
  },
  'vite.config.ts': {
    type: 'file',
    content:
      'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"],\n  },\n  base: "./",\n  build: {\n    outDir: "dist",\n  },\n});\n',
    isBinary: false,
  },
  'docs/project-3d-rules.md': {
    type: 'file',
    content:
      "# 3D Project Development Rules\n\n## Guideline for Using `RigidBodyObject`\n\nWhen implementing physics interactions, it is mandatory to use the `RigidBodyObject` component from the `vibe-starter-3d` package instead of the standard `RigidBody` from `@react-three/rapier`.\n\nThe primary reason for this is to simplify event handling for collisions and intersections. Using the standard `RigidBody` component requires managing a complex set of events (`onCollisionEnter`, `onCollisionExit`, `onIntersectionEnter`, `onIntersectionExit`).\n\nIn contrast, `RigidBodyObject` abstracts this complexity. It allows you to handle all physics-based interactions uniformly through just two simple trigger events: `onTriggerEnter` and `onTriggerExit`. This makes the interaction logic significantly cleaner and easier to manage.\n\n## Canvas Component Structure Rules\n\n**Core Requirement:** Components that render HTML tags (e.g., `<div>`, `<button>`) must NEVER be placed inside React Three Fiber's `<Canvas>` component.\n\n**Reasoning:**\nThis is a core architectural rule. Placing standard HTML inside the `<Canvas>` WebGL context will cause rendering errors.\n\n**Implementation Guidelines:**\n\n- **UI Components:** Components using HTML tags belong in the `src/components/ui/` directory. They must be rendered as an overlay, outside the `<Canvas>`.\n- **3D Components:** Only Three.js-related components, located in `src/components/r3f/`, should be placed inside the `<Canvas>`.\n\n**Correct Structure Example:**\n\n```tsx\n// ‚úÖ Correct approach\n<div>\n  {/* The 3D scene is rendered inside the Canvas */}\n  <Canvas>\n    <Player />\n    <Floor />\n  </Canvas>\n\n  {/* UI components are rendered as overlays outside the Canvas */}\n  <Crosshair />\n  <LoadingScreen />\n</div>\n```\n\n**Incorrect Structure Example:**\n\n```tsx\n// ‚ùå Incorrect approach\n<Canvas>\n  <Player />\n  {/* This is forbidden, as Crosshair renders HTML */}\n  <Crosshair />\n</Canvas>\n```\n",
    isBinary: false,
  },
  'src/App.tsx': {
    type: 'file',
    content:
      "import React, { useState } from 'react';\nimport './App.css';\nimport GameScene from './components/scene/GameScene';\nimport PreloadScene from './components/scene/PreloadScene';\n\nconst App: React.FC = () => {\n  const [isLoading, setIsLoading] = useState(true);\n\n  const handleLoadingComplete = () => {\n    setIsLoading(false);\n  };\n\n  return <div style={{ width: '100vw', height: '100vh' }}>{isLoading ? <PreloadScene onComplete={handleLoadingComplete} /> : <GameScene />}</div>;\n};\n\nexport default App;\n",
    isBinary: false,
  },
  'src/App.css': {
    type: 'file',
    content: '#root {\n  margin: 0 auto;\n  text-align: center;\n}\n',
    isBinary: false,
  },
  'src/assets.json': {
    type: 'file',
    content:
      '{\n  "characters": {\n    "base-model": {\n      "url": "https://agent8-games.verse8.io/assets/3d/characters/realistic style/base-model.glb"\n    }\n  },\n  "animations": {\n    "idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle.glb",\n      "description": "Idle"\n    },\n    "idle-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle-00.glb",\n      "description": "Idle 00"\n    },\n    "idle-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle-01.glb",\n      "description": "Idle 01"\n    },\n    "rifle-idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/rifle-idle.glb",\n      "description": "Rifle idle"\n    },\n    "pistol-idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/pistol-idle.glb",\n      "description": "Pistol idle"\n    },\n    "walk": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/walk.glb",\n      "description": "Walk"\n    },\n    "run-medium": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/run-medium.glb",\n      "description": "Run Medium"\n    },\n    "run-fast": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/run-fast.glb",\n      "description": "Run Fast"\n    },\n    "rifle-run": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/rifle-run.glb",\n      "description": "Rifle Run"\n    },\n    "pistol-run": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/pistol-run.glb",\n      "description": "Pistol Run"\n    },\n    "jump": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/jump.glb",\n      "description": "Jump"\n    },\n    "swim": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/swim.glb",\n      "description": "Swim"\n    },\n    "punch-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/punch-00.glb",\n      "description": "Punch 00"\n    },\n    "punch-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/punch-01.glb",\n      "description": "Punch 01"\n    },\n    "kick-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-00.glb",\n      "description": "Kick 00"\n    },\n    "kick-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-01.glb",\n      "description": "Kick 01"\n    },\n    "kick-02": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-02.glb",\n      "description": "Kick 02"\n    },\n    "melee-attack": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/melee-attack.glb",\n      "description": "Melee Attack"\n    },\n    "cast": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/cast.glb",\n      "description": "Cast"\n    },\n    "dance-locking": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/dance-locking.glb",\n      "description": "Dance Locking"\n    },\n    "dance-wave": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/dance-wave.glb",\n      "description": "Dance Wave"\n    },\n    "death-backward": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/death-backward.glb",\n      "description": "Death Backward"\n    },\n    "death-foward": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/death-foward.glb",\n      "description": "Death Foward"\n    },\n    "hit-to-body": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/hit-to-body.glb",\n      "description": "Hit to Body"\n    }\n  }\n}\n',
    isBinary: false,
  },
  'src/index.css': {
    type: 'file',
    content: '@tailwind base;\n@tailwind components;\n@tailwind utilities;\n',
    isBinary: false,
  },
  'src/main.tsx': {
    type: 'file',
    content:
      "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport './index.css';\nimport App from './App.tsx';\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n",
    isBinary: false,
  },
  'src/vite-env.d.ts': {
    type: 'file',
    content: '/// <reference types="vite/client" />\n',
    isBinary: false,
  },
  'src/constants/character.ts': {
    type: 'file',
    content:
      "import { AnimationType } from 'vibe-starter-3d';\n\nexport const CharacterState: { [key: string]: AnimationType } = {\n  /** IDLE ACTION */\n  IDLE: 'IDLE',\n  /** IDLE ACTION */\n  IDLE_01: 'IDLE_01',\n  /** WALKING ACTION */\n  WALK: 'WALK',\n  /** RUNNING ACTION */\n  RUN: 'RUN',\n  /** SPRINTING ACTION */\n  FAST_RUN: 'FAST_RUN',\n  /** JUMP ACTION */\n  JUMP: 'JUMP',\n  /** PUNCH ACTION */\n  PUNCH: 'PUNCH',\n  /** PUNCH ACTION */\n  PUNCH_01: 'PUNCH_01',\n  /** KICK ACTION */\n  KICK: 'KICK',\n  /** KICK ACTION */\n  KICK_01: 'KICK_01',\n  /** KICK ACTION */\n  KICK_02: 'KICK_02',\n  /** MELEE ATTACK ACTION */\n  MELEE_ATTACK: 'MELEE_ATTACK',\n  /** CAST ACTION */\n  CAST: 'CAST',\n  /** HIT ACTION */\n  HIT: 'HIT',\n  /** DIE ACTION */\n  DIE: 'DIE',\n};\n\nexport type CharacterState = (typeof CharacterState)[keyof typeof CharacterState];\n",
    isBinary: false,
  },
  'src/constants/rigidBodyObjectType.ts': {
    type: 'file',
    content:
      "export const RigidBodyObjectType = {\n  /** Local Player */\n  LOCAL_PLAYER: 'LOCAL_PLAYER',\n  /** Enemy */\n  ENEMY: 'ENEMY',\n  /** Monster */\n  MONSTER: 'MONSTER',\n  /** Wall */\n  WALL: 'WALL',\n  /** Obstacle */\n  OBSTACLE: 'OBSTACLE',\n  /** Item */\n  ITEM: 'ITEM',\n  /** Bullet */\n  BULLET: 'BULLET',\n  /** Floor */\n  FLOOR: 'FLOOR',\n  /** Floating board */\n  PLOTTING_BOARD: 'PLOTTING_BOARD',\n} as const;\n",
    isBinary: false,
  },
  'src/stores/gameStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\ninterface GameStore {\n  isMapPhysicsReady: boolean;\n  setMapPhysicsReady: (ready: boolean) => void;\n}\n\nexport const useGameStore = create<GameStore>()(\n  subscribeWithSelector((set) => ({\n    isMapPhysicsReady: false,\n    setMapPhysicsReady: (ready: boolean) => set({ isMapPhysicsReady: ready }),\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/localPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport * as THREE from 'three';\n\ntype PlayerState = {\n  position: THREE.Vector3;\n  speed: number;\n};\n\ntype LocalPlayerState = {\n  state: PlayerState;\n  setSpeed: (speed: number) => void;\n  setPosition: (x: number, y: number, z: number) => void;\n  clearPosition: () => void;\n};\n\nexport const useLocalPlayerStore = create<LocalPlayerState>()(\n  subscribeWithSelector((_, get) => ({\n    state: {\n      position: new THREE.Vector3(0, 0, 0),\n      speed: 0,\n    },\n\n    setSpeed: (speed: number) => {\n      get().state.speed = speed;\n    },\n\n    setPosition: (x: number, y: number, z: number) => {\n      const state = get().state;\n      state.position.x = x;\n      state.position.y = y;\n      state.position.z = z;\n    },\n\n    clearPosition: () => {\n      const state = get().state;\n      state.position.x = 0;\n      state.position.y = 0;\n      state.position.z = 0;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/playerActionStore.ts': {
    type: 'file',
    content:
      'interface PlayerActionState {\n  punch: boolean;\n  kick: boolean;\n  meleeAttack: boolean;\n  cast: boolean;\n}\n\ninterface PlayerActionStore extends PlayerActionState {\n  setPlayerAction: (action: string, pressed: boolean) => void;\n  getPlayerAction: (action: string) => boolean;\n  resetAllPlayerActions: () => void;\n}\n\nconst playerActionStore: PlayerActionStore = {\n  punch: false,\n  kick: false,\n  meleeAttack: false,\n  cast: false,\n\n  setPlayerAction: (action: string, pressed: boolean) => {\n    (playerActionStore as any)[action] = pressed;\n  },\n\n  getPlayerAction: (action: string): boolean => {\n    return (playerActionStore as any)[action];\n  },\n\n  resetAllPlayerActions: () => {\n    playerActionStore.punch = false;\n    playerActionStore.kick = false;\n    playerActionStore.meleeAttack = false;\n    playerActionStore.cast = false;\n  },\n};\n\nexport const usePlayerActionStore = () => playerActionStore;',
    isBinary: false,
  },
  'src/stores/multiPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport React from 'react';\nimport { RigidBody } from '@dimforge/rapier3d-compat';\n\ntype MultiPlayerRigidBodyState = {\n  connectedPlayerRefs: Record<string, React.RefObject<RigidBody>>;\n  registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => void;\n  unregisterConnectedPlayer: (account: string) => void;\n  getConnectedPlayerRef: (account: string) => React.RefObject<RigidBody> | undefined;\n  getAllConnectedPlayerRefs: () => Record<string, React.RefObject<RigidBody>>;\n  getConnectedPlayerCount: () => number;\n};\n\nexport const useMultiPlayerStore = create<MultiPlayerRigidBodyState>()(\n  subscribeWithSelector((set, get) => ({\n    connectedPlayerRefs: {},\n\n    registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => {\n      set((state) => ({\n        connectedPlayerRefs: {\n          ...state.connectedPlayerRefs,\n          [account]: rigidBodyRef,\n        },\n      }));\n    },\n\n    unregisterConnectedPlayer: (account: string) => {\n      set((state) => {\n        const newConnectedPlayerRefs = { ...state.connectedPlayerRefs };\n        delete newConnectedPlayerRefs[account];\n        return { connectedPlayerRefs: newConnectedPlayerRefs };\n      });\n    },\n\n    getConnectedPlayerRef: (account: string) => {\n      return get().connectedPlayerRefs[account];\n    },\n\n    getAllConnectedPlayerRefs: () => {\n      return get().connectedPlayerRefs;\n    },\n\n    getConnectedPlayerCount: () => {\n      return Object.keys(get().connectedPlayerRefs).length;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/components/r3f/Experience.tsx': {
    type: 'file',
    content:
      "import { Environment } from '@react-three/drei';\nimport Player from './Player';\nimport Floor from './Floor';\n\nconst Experience = () => {\n  return (\n    <>\n      <ambientLight intensity={0.7} />\n      <Environment preset=\"sunset\" background={false} />\n      <Player />\n      <Floor />\n    </>\n  );\n};\n\nexport default Experience;\n",
    isBinary: false,
  },
  'src/components/r3f/Floor.tsx': {
    type: 'file',
    content:
      'import { RigidBody } from \'@react-three/rapier\';\n\nconst Floor = () => {\n  return (\n    <>\n      <RigidBody type="fixed" colliders={\'cuboid\'}>\n        <mesh receiveShadow position={[0, 0, 0]} rotation-x={-Math.PI / 2}>\n          <planeGeometry args={[100, 100]} />\n          <meshStandardMaterial color="#3f3f3f" />\n        </mesh>\n      </RigidBody>\n    </>\n  );\n};\n\nexport default Floor;\n',
    isBinary: false,
  },
  'src/components/r3f/GameSceneCanvas.tsx': {
    type: 'file',
    content:
      "import React, { Suspense } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { Physics } from '@react-three/rapier';\nimport Experience from '../r3f/Experience';\nimport { FollowLight, QuarterViewController } from 'vibe-starter-3d';\nimport { useGameStore } from '../../stores/gameStore';\nimport MapPhysicsReadyChecker from '../r3f/MapPhysicsReadyChecker';\n\n/**\n * Game Scene Canvas Component\n *\n * This component is responsible for rendering the entire 3D game world using React Three Fiber.\n * It serves as the root container for all 3D elements, physics simulation, and game interactions.\n */\nconst GameSceneCanvas = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* ‚ö†Ô∏è DO NOT DELETE: Core Canvas component for React Three Fiber */}\n      <Canvas shadows>\n        <Physics paused={!isMapPhysicsReady}>\n          <Suspense fallback={null}>\n            {/* ‚ö†Ô∏è MUST INCLUDE: Essential checker for map physics initialization */}\n            {!isMapPhysicsReady && <MapPhysicsReadyChecker />}\n            <FollowLight offset={[60, 100, 30]} intensity={2} />\n            <QuarterViewController followCharacter={true} />\n            <Experience />\n          </Suspense>\n        </Physics>\n      </Canvas>\n    </>\n  );\n};\n\nexport default GameSceneCanvas;\n",
    isBinary: false,
  },
  'src/components/r3f/MapPhysicsReadyChecker.tsx': {
    type: 'file',
    content:
      "import { useFrame } from '@react-three/fiber';\nimport { useRapier } from '@react-three/rapier';\nimport { useRef } from 'react';\nimport * as THREE from 'three';\nimport { useGameStore } from '../../stores/gameStore';\n\n/**\n * Component that checks if the map physics is ready by performing raycasting.\n * Casts a ray downward from above to detect map geometry and ensures physics\n * interactions are properly initialized before gameplay begins.\n *\n * - Performs checks every frame until map physics is confirmed ready\n * - Times out after 60 frames as fallback to prevent infinite checking\n * - Excludes Capsule shapes (likely characters/objects) and sensor colliders\n * - Sets mapPhysicsReady to true once valid map geometry is detected\n */\nfunction MapPhysicsReadyChecker() {\n  const { isMapPhysicsReady, setMapPhysicsReady } = useGameStore();\n  const physicsCheckCount = useRef(0);\n  const { rapier, world } = useRapier();\n\n  useFrame(() => {\n    if (isMapPhysicsReady) return;\n\n    physicsCheckCount.current++;\n    if (physicsCheckCount.current > 180) {\n      setMapPhysicsReady(true);\n      return;\n    }\n\n    const origin = new THREE.Vector3(0, 50, 0);\n    const downDirection = new THREE.Vector3(0, -1, 0);\n    const ray = new rapier.Ray(origin, downDirection);\n\n    // Get all intersections and find the first non-sensor collider\n    const intersections: any[] = [];\n    world.propagateModifiedBodyPositionsToColliders();\n    world.updateSceneQueries();\n    world.intersectionsWithRay(ray, 100, true, (intersection) => {\n      // Exclude Capsule shapes as they are unlikely to be map colliders\n      if (intersection.collider.shape.type === rapier.ShapeType.Capsule) {\n        return true;\n      }\n      intersections.push(intersection);\n      return true; // continue searching\n    });\n\n    // Find the first non-sensor collider\n    const validHit = intersections.find((intersection) => !intersection.collider.isSensor());\n    if (!validHit) return;\n\n    console.log('%c[vibe-starter-3d]%c Map physics initialized.', 'color: #7159c1; font-weight: bold', 'color: inherit;');\n    setMapPhysicsReady(true);\n  });\n\n  return null;\n}\n\nexport default MapPhysicsReadyChecker;\n",
    isBinary: false,
  },
  'src/components/r3f/Player.tsx': {
    type: 'file',
    content:
      "import React, { useRef, useEffect, useCallback } from 'react';\nimport { useFrame, Vector3 } from '@react-three/fiber';\nimport { CollisionPayload } from '@react-three/rapier';\nimport { useGameServer } from '@agent8/gameserver';\n\nimport { useLocalPlayerStore } from '../../stores/localPlayerStore';\nimport { useMultiPlayerStore } from '../../stores/multiPlayerStore';\n\nimport { CharacterState } from '../../constants/character';\nimport { RigidBodyObjectType } from '../../constants/rigidBodyObjectType';\n\nimport Assets from '../../assets.json';\nimport {\n  AnimationConfigMap,\n  AnimationType,\n  CharacterMovementState,\n  CharacterRenderer,\n  RigidBodyPlayer,\n  RigidBodyPlayerRef,\n  useCharacterAnimation,\n  useControllerStore,\n} from 'vibe-starter-3d';\nimport { usePlayerActionStore } from '../../stores/playerActionStore';\n\nconst targetHeight = 1.6;\n\n// States that can be interrupted by actions\nconst INTERRUPTIBLE_STATES = [\n  CharacterState.IDLE,\n  CharacterState.IDLE_01,\n  CharacterState.WALK,\n  CharacterState.RUN,\n  CharacterState.FAST_RUN,\n  CharacterState.JUMP,\n] as const;\n\n// Animation configuration map moved outside component for better performance\nconst animationConfigMap: AnimationConfigMap = {\n  [CharacterState.IDLE]: {\n    url: Assets.animations['idle-00'].url,\n    loop: true,\n  },\n  [CharacterState.IDLE_01]: {\n    url: Assets.animations['idle-01'].url,\n    loop: true,\n  },\n  [CharacterState.WALK]: {\n    url: Assets.animations['walk'].url,\n    loop: true,\n  },\n  [CharacterState.RUN]: {\n    url: Assets.animations['run-medium'].url,\n    loop: true,\n  },\n  [CharacterState.FAST_RUN]: {\n    url: Assets.animations['run-fast'].url,\n    loop: true,\n  },\n  [CharacterState.JUMP]: {\n    url: Assets.animations['jump'].url,\n    loop: true,\n    clampWhenFinished: true,\n  },\n  [CharacterState.PUNCH]: {\n    url: Assets.animations['punch-00'].url,\n    loop: false,\n    duration: 0.5,\n    clampWhenFinished: true,\n  },\n  [CharacterState.PUNCH_01]: {\n    url: Assets.animations['punch-01'].url,\n    loop: false,\n    duration: 0.5,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK]: {\n    url: Assets.animations['kick-00'].url,\n    loop: false,\n    duration: 0.75,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK_01]: {\n    url: Assets.animations['kick-01'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK_02]: {\n    url: Assets.animations['kick-02'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.MELEE_ATTACK]: {\n    url: Assets.animations['melee-attack'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.CAST]: {\n    url: Assets.animations['cast'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.HIT]: {\n    url: Assets.animations['hit-to-body'].url,\n    loop: false,\n    clampWhenFinished: false,\n  },\n  [CharacterState.DANCE]: {\n    url: Assets.animations['dance-wave'].url,\n    loop: false,\n    clampWhenFinished: false,\n  },\n  [CharacterState.SWIM]: {\n    url: Assets.animations['swim'].url,\n    loop: true,\n  },\n  [CharacterState.DIE]: {\n    url: Assets.animations['death-backward'].url,\n    loop: false,\n    clampWhenFinished: true,\n  },\n};\n\n/**\n * Player props\n */\ninterface PlayerProps {\n  /** Initial position of the player */\n  position?: Vector3;\n}\n\n/**\n * Player component that manages character model and animations\n *\n * Handles player state management and delegates rendering to CharacterRenderer.\n * Movement states come from ControllerStore, actions are handled locally.\n */\nconst Player = ({ position }: PlayerProps) => {\n  const { account } = useGameServer();\n  const { registerConnectedPlayer, unregisterConnectedPlayer } = useMultiPlayerStore();\n  const { setPosition: setLocalPlayerPosition } = useLocalPlayerStore();\n  const { getPlayerAction } = usePlayerActionStore();\n\n  // Use the new useCharacterAnimation hook\n  const { animationState, setAnimation, getAnimation } = useCharacterAnimation<CharacterState>(CharacterState.IDLE);\n\n  // Get movement state from controller store (unified API)\n  const { getCharacterMovementState, isControlLocked, lockControls, unlockControls } = useControllerStore();\n\n  // IMPORTANT: rigidBodyPlayerRef.current type is RigidBody\n  const rigidBodyPlayerRef = useRef<RigidBodyPlayerRef>(null);\n\n  // IMPORTANT: Register connected player reference\n  useEffect(() => {\n    if (!account) return;\n\n    registerConnectedPlayer(account, rigidBodyPlayerRef);\n\n    return () => {\n      unregisterConnectedPlayer(account);\n    };\n  }, [account, registerConnectedPlayer, unregisterConnectedPlayer]);\n\n  // IMPORTANT: Update local player store position information\n  useFrame(() => {\n    const playerRigidBody = rigidBodyPlayerRef.current;\n    if (!playerRigidBody) return;\n\n    const position = playerRigidBody.translation();\n    setLocalPlayerPosition(position.x, position.y, position.z);\n  });\n\n  // Helper functions\n  const canInterrupt = useCallback((state: CharacterState): boolean => {\n    return INTERRUPTIBLE_STATES.includes(state);\n  }, []);\n\n  // Convert ControllerStore state to Player animation state\n  const toCharacterState = useCallback((characterMovementState: CharacterMovementState): CharacterState => {\n    switch (characterMovementState) {\n      case CharacterMovementState.IDLE:\n        return CharacterState.IDLE;\n      case CharacterMovementState.WALKING:\n        return CharacterState.WALK;\n      case CharacterMovementState.RUN:\n        return CharacterState.RUN;\n      case CharacterMovementState.FAST_RUN:\n        return CharacterState.FAST_RUN;\n      case CharacterMovementState.AIRBORNE:\n        return CharacterState.JUMP;\n      default:\n        return CharacterState.IDLE;\n    }\n  }, []);\n\n  // Callback triggered when a non-looping animation finishes.\n  const handleAnimationComplete = useCallback(\n    (type: AnimationType) => {\n      unlockControls();\n      switch (type) {\n        case CharacterState.PUNCH:\n        case CharacterState.PUNCH_01:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.KICK:\n        case CharacterState.KICK_01:\n        case CharacterState.KICK_02:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.CAST:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.HIT:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.MELEE_ATTACK:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.DANCE:\n          setAnimation(CharacterState.IDLE);\n          break;\n        default:\n          break;\n      }\n    },\n    [unlockControls, setAnimation],\n  );\n\n  const updatePlayerState = useCallback((): void => {\n    const currentState = getAnimation();\n\n    // If controls are locked, don't process actions\n    if (isControlLocked()) {\n      return;\n    }\n\n    // Handle death and revive states\n    // TODO: Connect with actual game state\n    // const isRevive = playerHealth > 0 && currentState === CharacterState.DIE;\n    // const isDying = playerHealth <= 0 && currentState !== CharacterState.DIE;\n\n    // Currently using placeholder false values\n    const isRevive = false;\n    const isDying = false;\n\n    // Revive handling: when health is restored while in death state\n    if (isRevive) {\n      setAnimation(CharacterState.IDLE);\n      return;\n    }\n\n    // Death handling: when health drops to 0 or below\n    if (isDying) {\n      setAnimation(CharacterState.DIE);\n      return;\n    }\n\n    // Handle action states (punch, kick, etc.) - highest priority\n    if (getPlayerAction('punch') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.PUNCH);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('kick') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.KICK);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('meleeAttack') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.MELEE_ATTACK);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('cast') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.CAST);\n      lockControls();\n      return;\n    }\n\n    // For movement states, use ControllerStore state\n    if (canInterrupt(currentState)) {\n      const characterMovementState = getCharacterMovementState();\n      const characterState = toCharacterState(characterMovementState);\n      setAnimation(characterState);\n    }\n  }, [isControlLocked, canInterrupt, lockControls, getCharacterMovementState, toCharacterState, getAnimation, setAnimation, getPlayerAction]);\n\n  // Update player action state based on inputs and physics\n  useFrame(() => {\n    if (!rigidBodyPlayerRef.current) return;\n    updatePlayerState();\n  });\n\n  /** handleTriggerEnter: Called when the player intersects or collides with another object.\n   * - Handles when entering a specific area or colliding with another object\n   */\n  const handleTriggerEnter = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when entering a specific area or colliding with another object\n    }\n  };\n\n  /** handleTriggerExit: Called when the player exits an intersection or ends a collision with another object.\n   * - Handles when exiting a specific area or when collision with another object ends\n   */\n  const handleTriggerExit = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when exiting a specific area or when collision with another object ends\n    }\n  };\n\n  return (\n    <RigidBodyPlayer\n      ref={rigidBodyPlayerRef}\n      userData={{ account, type: RigidBodyObjectType.LOCAL_PLAYER }}\n      position={position}\n      targetHeight={targetHeight}\n      onTriggerEnter={handleTriggerEnter}\n      onTriggerExit={handleTriggerExit}\n    >\n      <CharacterRenderer\n        url={Assets.characters['base-model'].url}\n        animationConfigMap={animationConfigMap}\n        animationState={animationState}\n        targetHeight={targetHeight}\n        onAnimationComplete={handleAnimationComplete}\n      />\n    </RigidBodyPlayer>\n  );\n};\n\nexport default Player;\n",
    isBinary: false,
  },
  'src/components/scene/GameScene.tsx': {
    type: 'file',
    content:
      "import GameSceneCanvas from '../r3f/GameSceneCanvas';\nimport GameSceneUI from '../ui/GameSceneUI';\n\n/**\n * Main Game Scene Component\n *\n * This component serves as a layout container that arranges the game UI and 3D Canvas.\n *\n * üö® CRITICAL PERFORMANCE WARNING:\n * Re-rendering of this component triggers re-rendering of the entire 3D Canvas, causing severe performance degradation.\n *\n * Prohibited Actions:\n * - Using state management hooks like useState, useReducer\n * - Passing frequently changing values as props\n * - State updates inside useEffect\n * - Conditional rendering that changes component structure\n * - Creating inline objects/functions (e.g., style={{...}}, onClick={() => {}})\n *\n * Recommendations:\n * - Handle state management in child components (GameSceneUI, GameSceneCanvas)\n * - Access global state directly through zustand store or similar\n * - Memoize event handlers with useCallback before use\n */\nconst GameScene = () => {\n  return (\n    <div className=\"relative w-full h-screen\">\n      <GameSceneUI />\n      <GameSceneCanvas />\n    </div>\n  );\n};\n\nexport default GameScene;\n",
    isBinary: false,
  },
  'src/components/scene/PreloadScene.tsx': {
    type: 'file',
    content:
      "import React, { useEffect, useState } from 'react';\nimport assets from '../../assets.json';\nimport * as THREE from 'three';\nimport { GLTF, GLTFLoader } from 'three-stdlib';\nimport { TextureLoader } from 'three';\n\ninterface PreloadSceneProps {\n  onComplete: () => void;\n}\n\n// Type definition to accept any structure in assets.json\ntype AssetCategory = Record<string, { url: string; [key: string]: unknown }>;\n\n// Type for the different possible loaded asset types\ntype LoadedAsset = GLTF | THREE.Texture | HTMLAudioElement | HTMLVideoElement | Response | null;\n\n/**\n * Asset Preloading Scene Component\n *\n * Preloads all assets defined in assets.json regardless of type\n * (models, animations, textures, etc.) and calls the onComplete callback when loading is finished.\n */\nconst PreloadScene: React.FC<PreloadSceneProps> = ({ onComplete }) => {\n  const [progress, setProgress] = useState(0);\n  const [isComplete, setIsComplete] = useState(false);\n\n  useEffect(() => {\n    const preloadAssets = async () => {\n      try {\n        // Collect all asset URLs from every category in assets.json\n        const allUrls: string[] = [];\n\n        // Get all categories from assets.json (characters, animations, textures, etc.)\n        const categories = Object.keys(assets);\n\n        // Loop through each category and collect URLs\n        categories.forEach((category) => {\n          const assetCategory = assets[category as keyof typeof assets] as AssetCategory;\n          if (assetCategory && typeof assetCategory === 'object') {\n            const categoryUrls = Object.values(assetCategory)\n              .filter((item) => item && typeof item === 'object' && 'url' in item)\n              .map((item) => item.url);\n\n            allUrls.push(...categoryUrls);\n          }\n        });\n\n        console.log(`Found ${allUrls.length} assets to preload`);\n\n        // Setup loading manager for all assets\n        const loadingManager = new THREE.LoadingManager();\n\n        // Set up loading manager event handlers\n        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {\n          const currentProgress = Math.floor((itemsLoaded / itemsTotal) * 100);\n          console.log(`Loading progress: ${currentProgress}% (${url})`);\n          setProgress(currentProgress);\n        };\n\n        loadingManager.onLoad = () => {\n          console.log('All assets preloaded successfully');\n          setProgress(100);\n          setIsComplete(true);\n        };\n\n        loadingManager.onError = (url) => {\n          console.error(`Loading error: ${url}`);\n        };\n\n        // Create a Promise for each asset to load with appropriate loader\n        const loadPromises = allUrls.map((url) => {\n          // Determine file type from extension\n          const fileExtension = url.split('.').pop()?.toLowerCase();\n\n          return new Promise<LoadedAsset>((resolve) => {\n            // Choose appropriate loader based on file extension\n            if (fileExtension === 'glb' || fileExtension === 'gltf') {\n              // Use GLTFLoader for 3D models and animations\n              const loader = new GLTFLoader(loadingManager);\n              loader.load(\n                url,\n                (gltf) => {\n                  console.log(`Loaded model: ${url}`);\n                  resolve(gltf);\n                },\n                undefined,\n                (error) => {\n                  console.error(`Failed to load model: ${url}`, error);\n                  resolve(null);\n                },\n              );\n            } else if (['jpg', 'jpeg', 'png', 'webp'].includes(fileExtension || '')) {\n              // Use TextureLoader for image textures\n              const loader = new TextureLoader(loadingManager);\n              loader.load(\n                url,\n                (texture) => {\n                  console.log(`Loaded texture: ${url}`);\n                  resolve(texture);\n                },\n                undefined,\n                (error) => {\n                  console.error(`Failed to load texture: ${url}`, error);\n                  resolve(null);\n                },\n              );\n            } else if (['mp3', 'wav', 'ogg'].includes(fileExtension || '')) {\n              // For audio files, preload with audio element\n              const audio = new Audio();\n              audio.src = url;\n\n              audio.addEventListener('canplaythrough', () => {\n                console.log(`Loaded audio: ${url}`);\n                resolve(audio);\n              });\n\n              audio.addEventListener('error', () => {\n                console.error(`Failed to load audio: ${url}`);\n                resolve(null);\n              });\n\n              // Force preloading\n              audio.load();\n            } else if (['mp4', 'webm'].includes(fileExtension || '')) {\n              // For video files\n              const video = document.createElement('video');\n              video.src = url;\n              video.preload = 'auto';\n\n              video.addEventListener('canplaythrough', () => {\n                console.log(`Loaded video: ${url}`);\n                resolve(video);\n              });\n\n              video.addEventListener('error', () => {\n                console.error(`Failed to load video: ${url}`);\n                resolve(null);\n              });\n\n              // Force preloading\n              video.load();\n            } else {\n              // For other file types, use a simple fetch to ensure it's in browser cache\n              fetch(url)\n                .then((response) => {\n                  if (!response.ok) throw new Error(`Failed to load: ${url}`);\n                  console.log(`Loaded other: ${url}`);\n                  return resolve(response);\n                })\n                .catch((error) => {\n                  console.error(`Failed to load: ${url}`, error);\n                  resolve(null);\n                });\n            }\n          });\n        });\n\n        // Wait for all loading tasks to complete\n        await Promise.all(loadPromises);\n      } catch (error) {\n        console.error('Error during asset preloading:', error);\n      }\n    };\n\n    preloadAssets();\n  }, []);\n\n  // Call onComplete callback when loading is finished\n  useEffect(() => {\n    if (isComplete) {\n      onComplete();\n    }\n  }, [isComplete, onComplete]);\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex flex-col items-center justify-center bg-black text-white\">\n      <h2 className=\"text-2xl font-bold mb-4\">Loading</h2>\n      <div className=\"w-64 h-2 bg-gray-700 rounded-full overflow-hidden\">\n        <div className=\"h-full bg-blue-500 transition-all duration-300\" style={{ width: `${Math.max(0, Math.min(100, progress))}%` }} />\n      </div>\n      <p className=\"mt-2\">{progress}%</p>\n    </div>\n  );\n};\n\nexport default PreloadScene;\n",
    isBinary: false,
  },
  'src/components/ui/InputController.tsx': {
    type: 'file',
    content:
      "import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport * as THREE from 'three';\nimport { IS_MOBILE, useInputStore } from 'vibe-starter-3d';\nimport { usePlayerActionStore } from '../../stores/playerActionStore';\nimport nipplejs from 'nipplejs';\n\n/**\n * Key mapping configuration - simple Record<string, string[]>\n */\ntype KeyMapping = Record<string, string[]>; // action: [key1, key2, ...]\n\n/**\n * Controller key mapping\n */\nconst CONTROL_KEY_MAPPING: KeyMapping = {\n  forward: ['KeyW', 'ArrowUp'],\n  backward: ['KeyS', 'ArrowDown'],\n  leftward: ['KeyA', 'ArrowLeft'],\n  rightward: ['KeyD', 'ArrowRight'],\n  jump: ['Space'],\n  run: ['ShiftLeft', 'ShiftRight'],\n};\n\n/**\n * Player action key mapping\n */\nconst ACTION_KEY_MAPPING: KeyMapping = {\n  punch: ['KeyF', 'Mouse0'],\n  kick: ['KeyG', 'Mouse2'],\n  meleeAttack: ['KeyQ', 'KeyC'],\n  cast: ['KeyE', 'Mouse1'],\n};\n\n// Movement speed constants\nconst MOVEMENT_SPEED_WALK = 0.6;\nconst MOVEMENT_SPEED_RUN_BOOST = 0.4;\nconst MOVEMENT_SPEED_MAX = 1.0;\nconst JOYSTICK_RANGE_MULTIPLIER = 2.0; // Converts joystick range (0~0.5) to full range (0~1.0)\n\ninterface InputControllerProps {\n  disabled?: boolean;\n  disableKeyboard?: boolean;\n  disableJoystick?: boolean;\n}\n\nexport const InputController: React.FC<InputControllerProps> = ({ disabled = false, disableKeyboard = false, disableJoystick = false }) => {\n  // Store actions to controller\n  const { setMovementInput, setActionInput, resetAllInputs, setActiveInputSource } = useInputStore();\n  const { setPlayerAction, resetAllPlayerActions } = usePlayerActionStore();\n\n  // Button states\n  const [isJumpPressed, setIsJumpPressed] = useState(false);\n  const [isAttackPressed, setIsAttackPressed] = useState(false);\n\n  // Keyboard state tracking\n  const keyboardStateRef = useRef({\n    forward: false,\n    backward: false,\n    leftward: false,\n    rightward: false,\n    run: false,\n  });\n\n  // Helper function to calculate movement from keyboard state\n  const calculateKeyboardMovement = useCallback(() => {\n    const state = keyboardStateRef.current;\n\n    // Calculate direction\n    const x = (state.leftward ? 1 : 0) + (state.rightward ? -1 : 0);\n    const y = (state.forward ? 1 : 0) + (state.backward ? -1 : 0);\n\n    // Use Three.js Vector2 for efficient normalization\n    const direction = new THREE.Vector2(x, y);\n    const magnitude = direction.length();\n\n    // Normalize diagonal movement\n    if (magnitude > 0) {\n      direction.normalize();\n    }\n\n    // Calculate intensity: base speed + run boost\n    const baseIntensity = magnitude > 0 ? MOVEMENT_SPEED_WALK : 0; // Base walking speed\n    const runBoost = state.run ? MOVEMENT_SPEED_RUN_BOOST : 0; // Additional speed when running\n    const intensity = Math.min(baseIntensity + runBoost, MOVEMENT_SPEED_MAX);\n\n    return {\n      direction: { x: direction.x, y: direction.y },\n      intensity,\n    };\n  }, []);\n\n  // Joystick input handling with analog support\n  useEffect(() => {\n    if (disabled || disableJoystick || !IS_MOBILE) return;\n\n    // Create div element for left side area of screen\n    const joystickZone = document.createElement('div');\n    joystickZone.style.position = 'fixed';\n    joystickZone.style.left = '0';\n    joystickZone.style.top = '0';\n    joystickZone.style.width = '50%'; // Left 50% of screen\n    joystickZone.style.height = '100%';\n    joystickZone.style.zIndex = '1000';\n    joystickZone.style.pointerEvents = 'auto';\n    joystickZone.style.backgroundColor = 'transparent';\n    // Disable long touch events\n    joystickZone.style.touchAction = 'none';\n    joystickZone.style.userSelect = 'none';\n    joystickZone.style.setProperty('-webkit-user-select', 'none');\n    joystickZone.style.setProperty('-webkit-touch-callout', 'none');\n    document.body.appendChild(joystickZone);\n\n    const options: nipplejs.JoystickManagerOptions = {\n      zone: joystickZone,\n      color: 'white',\n      mode: 'dynamic',\n      shape: 'circle',\n    };\n\n    const manager = nipplejs.create(options);\n\n    manager.on('move', (evt, data) => {\n      if (disabled || disableJoystick) return; // Check disabled state\n      setActiveInputSource('joystick');\n\n      // Extract analog data from nipplejs\n      const angle = data.angle?.radian || 0; // Angle in radians\n      const distance = data.distance || 0; // Distance from center\n      const maxDistance = data.instance.options.size || 100; // Maximum distance\n\n      // Calculate normalized direction vector\n      // nipplejs uses mathematical coordinate system (0¬∞ = right, 90¬∞ = up)\n      // We need to convert to game coordinate system (0¬∞ = up, 90¬∞ = right)\n      const gameAngle = angle - Math.PI / 2; // Rotate by -90 degrees\n      const directionX = Math.sin(gameAngle); // Right/Left\n      const directionY = Math.cos(gameAngle); // Forward/Backward\n\n      // Calculate intensity (0.0 to 1.0) based on distance from center\n      const intensity = Math.min((distance / maxDistance) * JOYSTICK_RANGE_MULTIPLIER, MOVEMENT_SPEED_MAX);\n\n      // Set analog movement input\n      setMovementInput({ x: directionX, y: directionY }, intensity, 'joystick');\n    });\n\n    manager.on('end', () => {\n      if (disabled || disableJoystick) return; // Check disabled state\n      // Reset all inputs when joystick ends\n      setMovementInput({ x: 0, y: 0 }, 0, 'joystick');\n    });\n\n    return () => {\n      manager.destroy();\n      if (joystickZone.parentNode) {\n        joystickZone.parentNode.removeChild(joystickZone);\n      }\n    };\n  }, [disabled, disableJoystick, setMovementInput, setActiveInputSource]);\n\n  // Keyboard input handling - convert to movement immediately\n  useEffect(() => {\n    if (disabled || disableKeyboard) return;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n      let stateChanged = false;\n\n      // Handle movement keys\n      if (CONTROL_KEY_MAPPING['forward']?.includes(event.code) && !keyboardStateRef.current.forward) {\n        keyboardStateRef.current.forward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['backward']?.includes(event.code) && !keyboardStateRef.current.backward) {\n        keyboardStateRef.current.backward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['leftward']?.includes(event.code) && !keyboardStateRef.current.leftward) {\n        keyboardStateRef.current.leftward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['rightward']?.includes(event.code) && !keyboardStateRef.current.rightward) {\n        keyboardStateRef.current.rightward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['run']?.includes(event.code) && !keyboardStateRef.current.run) {\n        keyboardStateRef.current.run = true;\n        stateChanged = true;\n      }\n\n      // Handle action keys\n      if (CONTROL_KEY_MAPPING['jump']?.includes(event.code)) {\n        setActionInput('jump', true, 'keyboard');\n      }\n\n      // Handle player action keys\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(event.code)) {\n          setPlayerAction(action, true);\n        }\n      });\n\n      // Update movement if any movement-related key changed\n      if (stateChanged) {\n        const movement = calculateKeyboardMovement();\n        setMovementInput(movement.direction, movement.intensity, 'keyboard');\n      }\n    };\n\n    const handleKeyUp = (event: KeyboardEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n      let stateChanged = false;\n\n      // Handle movement keys\n      if (CONTROL_KEY_MAPPING['forward']?.includes(event.code) && keyboardStateRef.current.forward) {\n        keyboardStateRef.current.forward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['backward']?.includes(event.code) && keyboardStateRef.current.backward) {\n        keyboardStateRef.current.backward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['leftward']?.includes(event.code) && keyboardStateRef.current.leftward) {\n        keyboardStateRef.current.leftward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['rightward']?.includes(event.code) && keyboardStateRef.current.rightward) {\n        keyboardStateRef.current.rightward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['run']?.includes(event.code) && keyboardStateRef.current.run) {\n        keyboardStateRef.current.run = false;\n        stateChanged = true;\n      }\n\n      // Handle action keys\n      if (CONTROL_KEY_MAPPING['jump']?.includes(event.code)) {\n        setActionInput('jump', false, 'keyboard');\n      }\n\n      // Handle player action keys\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(event.code)) {\n          setPlayerAction(action, false);\n        }\n      });\n\n      // Update movement if any movement-related key changed\n      if (stateChanged) {\n        const movement = calculateKeyboardMovement();\n        setMovementInput(movement.direction, movement.intensity, 'keyboard');\n      }\n    };\n\n    const handleMouseDown = (event: MouseEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n\n      // Handle player action mouse keys\n      const mouseButton = `Mouse${event.button}`;\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(mouseButton)) {\n          setPlayerAction(action, true);\n        }\n      });\n    };\n\n    const handleMouseUp = (event: MouseEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n\n      // Handle player action mouse keys\n      const mouseButton = `Mouse${event.button}`;\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(mouseButton)) {\n          setPlayerAction(action, false);\n        }\n      });\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n      document.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [disabled, disableKeyboard, setMovementInput, setActionInput, setPlayerAction, calculateKeyboardMovement]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      resetAllInputs();\n      resetAllPlayerActions();\n    };\n  }, [resetAllInputs, resetAllPlayerActions]);\n\n  // Reset inputs when disabled\n  useEffect(() => {\n    if (disabled || disableKeyboard || disableJoystick) {\n      // Reset keyboard state if keyboard is disabled\n      if (disabled || disableKeyboard) {\n        keyboardStateRef.current = {\n          forward: false,\n          backward: false,\n          leftward: false,\n          rightward: false,\n          run: false,\n        };\n      }\n      // Reset button states\n      setIsJumpPressed(false);\n      setIsAttackPressed(false);\n      resetAllInputs();\n      resetAllPlayerActions();\n    }\n  }, [disabled, disableKeyboard, disableJoystick, resetAllInputs, resetAllPlayerActions]);\n\n  // Button handlers\n  const handleJumpStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation(); // Prevent event propagation\n      setIsJumpPressed(true);\n      setActionInput('jump', true, 'touch');\n    },\n    [disabled, setActionInput],\n  );\n\n  const handleJumpEnd = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation(); // Prevent event propagation\n      setIsJumpPressed(false);\n      setActionInput('jump', false, 'touch');\n    },\n    [disabled, setActionInput],\n  );\n\n  const handleAttackStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation();\n      setIsAttackPressed(true);\n      // NOTE: change to other action if needed\n      setPlayerAction('punch', true);\n    },\n    [disabled, setPlayerAction],\n  );\n\n  const handleAttackEnd = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation();\n      setIsAttackPressed(false);\n      // NOTE: change to other action if needed\n      setPlayerAction('punch', false);\n    },\n    [disabled, setPlayerAction],\n  );\n\n  // Don't render action buttons if joystick is disabled\n  if (disableJoystick) {\n    return null;\n  }\n\n  // Render action buttons\n  return (\n    <div className=\"fixed bottom-8 right-8 z-[1001]\">\n      {/* Attack Button */}\n      <div\n        className={`w-20 h-20 rounded-full bg-white/30 \n                   flex items-center justify-center cursor-pointer select-none touch-none\n                   ${isAttackPressed ? 'scale-90' : 'scale-100'} transition-transform`}\n        onMouseDown={handleAttackStart}\n        onMouseUp={handleAttackEnd}\n        onMouseLeave={handleAttackEnd}\n        onTouchStart={handleAttackStart}\n        onTouchEnd={handleAttackEnd}\n      >\n        <span className=\"text-white text-xs font-bold\">ATTACK</span>\n      </div>\n\n      {/* Jump Button */}\n      <div\n        className={`absolute bottom-0 -left-12 -top-12 w-14 h-14 rounded-full bg-white/30 \n                   flex items-center justify-center cursor-pointer select-none touch-none\n                   ${isJumpPressed ? 'scale-90' : 'scale-100'} transition-transform`}\n        onMouseDown={handleJumpStart}\n        onMouseUp={handleJumpEnd}\n        onMouseLeave={handleJumpEnd}\n        onTouchStart={handleJumpStart}\n        onTouchEnd={handleJumpEnd}\n      >\n        <span className=\"text-white text-xs font-bold\">JUMP</span>\n      </div>\n    </div>\n  );\n};\n",
    isBinary: false,
  },
  'src/components/ui/GameSceneUI.tsx': {
    type: 'file',
    content:
      "import { useGameStore } from '../../stores/gameStore';\nimport { InputController } from './InputController';\nimport LoadingScreen from './LoadingScreen';\n\n/**\n * Game Scene UI Component\n *\n * This component manages UI overlays for the game scene.\n * It handles loading states and displays appropriate UI elements based on game state.\n */\nconst GameSceneUI = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* Input Controller - Global input management (keyboard, touch) */}\n      <InputController disableJoystick={false} disableKeyboard={false} disabled={!isMapPhysicsReady} />\n      {/* Loading Game Scene screen overlay */}\n      {!isMapPhysicsReady && <LoadingScreen />}\n    </>\n  );\n};\n\nexport default GameSceneUI;\n",
    isBinary: false,
  },
  'src/components/ui/LoadingScreen.tsx': {
    type: 'file',
    content:
      "import { useThree } from '@react-three/fiber';\nimport { Html } from '@react-three/drei';\n\n/**\n * Loading screen component\n */\nconst LoadingScreen = () => {\n  let isInThreeCanvas: boolean;\n  try {\n    useThree();\n    isInThreeCanvas = true;\n  } catch {\n    isInThreeCanvas = false;\n  }\n\n  const loadingContent = (\n    <div>\n      <style>{`\n        .loading-container {\n          inset: 0;\n          z-index: 50;\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: center;\n          background-color: black;\n          color: white;\n          width: 100%;\n          height: 100%;\n        }\n        .loading-title {\n          font-size: 1.5rem;\n          font-weight: bold;\n          margin-bottom: 1rem;\n        }\n        .spinner {\n          width: 30px;\n          height: 30px;\n          border: 3px solid rgba(255, 255, 255, 0.3);\n          border-radius: 50%;\n          border-top-color: white;\n          animation: spin 1s ease-in-out infinite;\n        }\n        @keyframes spin {\n          to {\n            transform: rotate(360deg);\n          }\n        }\n      `}</style>\n      <div className=\"loading-container\">\n        <h2 className=\"loading-title\">Loading</h2>\n        <div className=\"spinner\"></div>\n      </div>\n    </div>\n  );\n\n  if (isInThreeCanvas) {\n    return (\n      <Html\n        center\n        style={{\n          width: '100vw',\n          height: '100vh',\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          pointerEvents: 'none',\n        }}\n      >\n        {loadingContent}\n      </Html>\n    );\n  }\n\n  return loadingContent;\n};\n\nexport default LoadingScreen;\n",
    isBinary: false,
  },
} as FileMap;

export const TEMPLATE_3D_BASIC_FLIGHTVIEW = {
  'package.json': {
    type: 'file',
    content:
      '{\n  "name": "flightview",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "lint": "eslint .",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@agent8/gameserver": "^1.5.3",\n    "vibe-starter-3d": "^0.8.18",\n    "@react-three/drei": "9.122.0",\n    "@react-three/fiber": "8.18.0",\n    "@react-three/postprocessing": "2.19.1",\n    "@react-three/rapier": "1.5.0",\n    "@dimforge/rapier3d-compat": "0.14.0",\n    "lucide-react": "0.482.0",\n    "react": "18.3.1",\n    "react-dom": "18.3.1",\n    "three": "0.174.0",\n    "three-stdlib": "2.35.14",\n    "zustand": "5.0.3"\n  },\n  "devDependencies": {\n    "@eslint/js": "^9.23.0",\n    "@types/react": "^18.3.20",\n    "@types/react-dom": "^18.3.5",\n    "@types/three": "^0.174.0",\n    "@vitejs/plugin-react": "^4.3.4",\n    "autoprefixer": "^10.4.21",\n    "eslint": "^9.23.0",\n    "eslint-plugin-react-hooks": "^5.2.0",\n    "eslint-plugin-react-refresh": "^0.4.19",\n    "globals": "^16.0.0",\n    "tailwindcss": "^3.4.17",\n    "typescript": "~5.8.2",\n    "typescript-eslint": "^8.28.0",\n    "vite": "^6.2.3"\n  }\n}\n',
    isBinary: false,
  },
  'tsconfig.json': {
    type: 'file',
    content:
      '{\n  "files": [],\n  "references": [\n    { "path": "./tsconfig.app.json" },\n    { "path": "./tsconfig.node.json" }\n  ]\n}\n',
    isBinary: false,
  },
  'vite.config.ts': {
    type: 'file',
    content:
      'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"],\n  },\n  base: "./",\n  build: {\n    outDir: "dist",\n  },\n});\n',
    isBinary: false,
  },
  'README.md': {
    type: 'file',
    content:
      "# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n",
    isBinary: false,
  },
  'index.html': {
    type: 'file',
    content:
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + React + TS</title>\n    <style>\n      body {\n        margin: 0;\n        padding: 0;\n        font-family: Arial, sans-serif;\n      }\n      .loading-container {\n        position: fixed;\n        inset: 0;\n        z-index: 50;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background-color: black;\n        color: white;\n      }\n      .loading-title {\n        font-size: 1.5rem;\n        font-weight: bold;\n        margin-bottom: 1rem;\n      }\n      .spinner {\n        width: 30px;\n        height: 30px;\n        border: 3px solid rgba(255, 255, 255, 0.3);\n        border-radius: 50%;\n        border-top-color: white;\n        animation: spin 1s ease-in-out infinite;\n      }\n      @keyframes spin {\n        to {\n          transform: rotate(360deg);\n        }\n      }\n    </style>\n    <script>\n      (function () {\n        function reportGameSize() {\n          const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n\n          const width = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n\n          window.parent.postMessage(\n            {\n              type: \'GAME_SIZE_RESPONSE\',\n              height: height,\n              width: width,\n            },\n            \'*\',\n          );\n        }\n\n        window.addEventListener(\'load\', reportGameSize);\n\n        window.addEventListener(\'resize\', reportGameSize);\n\n        window.addEventListener(\'message\', function (event) {\n          if (event.data && event.data.type === \'REQUEST_GAME_SIZE\') {\n            reportGameSize();\n          }\n        });\n      })();\n    </script>\n  </head>\n  <body>\n    <div id="root">\n      <div class="loading-container">\n        <h2 class="loading-title">Loading</h2>\n        <div class="spinner"></div>\n      </div>\n    </div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    isBinary: false,
  },
  'postcss.config.js': {
    type: 'file',
    content: 'export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n',
    isBinary: false,
  },
  'eslint.config.js': {
    type: 'file',
    content:
      "import js from '@eslint/js'\nimport globals from 'globals'\nimport reactHooks from 'eslint-plugin-react-hooks'\nimport reactRefresh from 'eslint-plugin-react-refresh'\nimport tseslint from 'typescript-eslint'\n\nexport default tseslint.config(\n  { ignores: ['dist'] },\n  {\n    extends: [js.configs.recommended, ...tseslint.configs.recommended],\n    files: ['**/*.{ts,tsx}'],\n    languageOptions: {\n      ecmaVersion: 2020,\n      globals: globals.browser,\n    },\n    plugins: {\n      'react-hooks': reactHooks,\n      'react-refresh': reactRefresh,\n    },\n    rules: {\n      ...reactHooks.configs.recommended.rules,\n      'react-refresh/only-export-components': [\n        'warn',\n        { allowConstantExport: true },\n      ],\n    },\n  },\n)\n",
    isBinary: false,
  },
  'tailwind.config.js': {
    type: 'file',
    content:
      '/** @type {import(\'tailwindcss\').Config} */\nexport default {\n  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n',
    isBinary: false,
  },
  'tsconfig.app.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",\n    "target": "ES2020",\n    "useDefineForClassFields": true,\n    "lib": ["ES2020", "DOM", "DOM.Iterable"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n    "jsx": "react-jsx",\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["src"]\n}\n',
    isBinary: false,
  },
  'server.js': {
    type: 'file',
    content: 'class Server {}\n',
    isBinary: false,
  },
  'PROJECT.md': {
    type: 'file',
    content:
      "# Basic 3D Flight View\n\n## Project Summary\n\nThis project is a single-player game where you can control and fly an aircraft in a 3D space. It is built using Three.js and React Three Fiber.\n\n## Implementation Strategy\n\nThis project uses a **Three.js-based 3D approach** because:\n\n- It requires real-time 3D character animation and control\n- Three.js provides efficient 3D rendering in web browsers\n- React Three Fiber simplifies integration with React components\n- The vibe-starter-3d library provides essential character rendering and animation tools\n\nKey technologies:\n\n- Three.js for 3D rendering\n- React Three Fiber for React integration\n- @react-three/rapier for physics simulation\n- @react-three/drei for useful Three.js helpers\n- vibe-starter-3d for character rendering and animation\n- @agent8/gameserver for multiplayer functionality\n- Zustand for state management\n- Tailwind CSS for styling\n\n## Implemented Features\n\n- Keyboard-controlled aircraft movement (WASD/Arrow keys) and attack (Spacebar)\n- Free view camera that follows the aircraft\n- Pointer lock for immersive control\n\n## File Structure Overview\n\n### `src/main.tsx`\n\n- Entry point for the application.\n- Sets up React rendering and mounts the `App` component.\n\n### `src/App.tsx`\n\n- Main application component and entry point.\n- Sets up a full-screen container and renders the `GameScene` component, which handles all 3D scene setup and UI elements.\n\n### `src/App.css`\n\n- Defines the main styles for the `App` component and its child UI elements.\n\n### `src/index.css`\n\n- Defines global base styles, Tailwind CSS directives, fonts, etc., applied throughout the application.\n\n### `src/constants/`\n\n- Directory defining constant values used throughout the application.\n  - **`controls.ts`**: Defines settings that map keyboard inputs (WASD, arrow keys, etc.) to corresponding actions (movement, firing, etc.).\n  - **`aircraft.ts`**: Defines constant values related to the aircraft, such as speed, rotation limits, etc.\n  - **`rigidBodyObjectType.ts`**: Defines constant values for different types of rigid body objects used in physics simulation (player, enemy, wall, floor, sea, etc.).\n\n### `src/components/`\n\n- Directory managing React components categorized by function.\n\n  - **`r3f/`**: Contains 3D components related to React Three Fiber.\n\n    - **`Aircraft.tsx`**: Component handling the logic related to the player-controlled aircraft model (movement, rotation, bullet firing trigger).\n    - **`MapPhysicsReadyChecker.tsx`**: Component that checks if the map physics system is ready by performing raycasting from above downward to detect map geometry and ensures physics interactions are properly initialized before gameplay begins. Performs checks every frame until valid map geometry is detected, with a timeout after 180 frames to prevent infinite checking. Excludes Capsule shapes (likely characters/objects) and sensor colliders from the inspection.\n    - **`Player.tsx`**: Main player component that uses `RigidBodyPlayer` from `vibe-starter-3d` for physics-based player control. It handles player registration, bullet firing with cooldown, position tracking, and reset functionality. **Key feature**: Uses `onTriggerEnter` and `onTriggerExit` events to handle player interactions with other objects in the scene (collision detection, area triggers, etc.). The component includes a custom `CuboidCollider` for precise collision detection and wraps the `Aircraft` component for visual representation.\n    - **`Experience.tsx`**: Component that sets up the core 3D scene elements. Includes ambient lighting, Sky environment, Player, Ground, and FloatingShapes components.\n    - **`FloatingShapes.tsx`**: Component generating and managing various 3D shapes floating randomly in the scene.\n    - **`GameSceneCanvas.tsx`**: React Three Fiber Canvas component that renders the 3D game world with physics simulation and controller setup.\n    - **`Ground.tsx`**: Component defining and visually representing the ground plane, runway, and scattered objects in the 3D space. It includes a sea plane, grass ground, runway with markings, and randomly generated objects (boxes, spheres, cones) scattered across the terrain. Has physical properties for collision detection.\n    - **`EffectContainer.tsx`**: Container component managing and rendering various visual effects like bullet firing and hit effects.\n    - **`effects/`**: Directory containing specific visual effect components.\n      - **`Bullet.tsx`**: Component defining the visual representation and individual behavior (movement, collision detection) of bullets fired from the airplane.\n      - **`BulletEffectController.tsx`**: Controller component responsible for creating and managing bullet-related effects (e.g., firing, collision). (Potential for Object Pooling usage)\n      - **`MuzzleFlash.tsx`**: Component representing the muzzle flash effect.\n      - **`Explosion.tsx`**: Component creating explosion and smoke particle effects when bullets hit targets or objects.\n\n  - **`scene/`**: Contains components related to scene setup.\n\n    - **`GameScene.tsx`**: Main game scene component that serves as a layout container arranging the game UI and 3D Canvas. Contains critical performance warnings and guidelines to prevent re-rendering issues. Includes the `GameSceneCanvas` and `GameSceneUI` components in a proper layered structure where the Canvas renders the 3D world and UI components render as overlays.\n\n  - **`ui/`**: Contains UI components for the game interface.\n    - **`GameSceneUI.tsx`**: Component that manages UI overlays for the game scene.\n    - **`StatusDisplay.tsx`**: UI component displaying game state information (e.g., airplane speed, altitude) on the screen.\n    - **`LoadingScreen.tsx`**: Loading screen component displayed during game loading.\n\n### `src/stores/`\n\n- Directory containing state management logic (e.g., Zustand).\n  - **`effectStore.ts`**: Store for managing effect-related state (e.g., bullets, explosions).\n  - **`gameStore.ts`**: Store that manages the overall game state. Tracks and controls the readiness state of the map physics system (`isMapPhysicsReady`). This state is used to determine physics simulation pause/resume and loading screen display.\n  - **`localPlayerStore.ts`**: Store that manages the local player's state, such as position tracking and speed tracking.\n  - **`multiPlayerStore.ts`**: Store that manages multiple connected players' rigid body references for multiplayer functionality, including registration, unregistration, and retrieval of player references.\n\n### `src/types/`\n\n- Directory containing TypeScript type definitions.\n  - **`effect.ts`**: Defines effect-related types.\n  - **`index.ts`**: Exports types from the `types` directory.\n\n### `src/utils/`\n\n- Directory containing utility functions used across the application.\n  - **`effectUtils.ts`**: Contains utility functions specifically related to managing and calculating visual effects.\n",
    isBinary: false,
  },
  'vite.config.ts.js': {
    type: 'file',
    content:
      '// vite.config.ts\nimport { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\nvar vite_config_default = defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"]\n  },\n  base: "./",\n  build: {\n    outDir: "dist"\n  }\n});\nexport {\n  vite_config_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsidml0ZS5jb25maWcudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IGRlZmluZUNvbmZpZyB9IGZyb20gXCJ2aXRlXCI7XG5pbXBvcnQgcmVhY3QgZnJvbSBcIkB2aXRlanMvcGx1Z2luLXJlYWN0XCI7XG5cbi8vIGh0dHBzOi8vdml0ZWpzLmRldi9jb25maWcvXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVDb25maWcoe1xuICBwbHVnaW5zOiBbcmVhY3QoKV0sXG4gIG9wdGltaXplRGVwczoge1xuICAgIGV4Y2x1ZGU6IFtcImx1Y2lkZS1yZWFjdFwiXSxcbiAgfSxcbiAgYmFzZTogXCIuL1wiLFxuICBidWlsZDoge1xuICAgIG91dERpcjogXCJkaXN0XCIsXG4gIH0sXG59KTtcbiJdLAogICJtYXBwaW5ncyI6ICI7QUFBQTtBQUNBO0FBR0EsSUFBTyxzQkFBUSxhQUFhO0FBQUEsRUFDMUIsU0FBUyxDQUFDO0FBQUEsRUFDVixjQUFjO0FBQUEsSUFDWixTQUFTLENBQUM7QUFBQTtBQUFBLEVBRVosTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLElBQ0wsUUFBUTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==\n',
    isBinary: false,
  },
  'tsconfig.node.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",\n    "target": "ES2022",\n    "lib": ["ES2023"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["vite.config.ts"]\n}\n',
    isBinary: false,
  },
  '.gitignore': {
    type: 'file',
    content:
      '# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n',
    isBinary: false,
  },
  'docs/project-3d-rules.md': {
    type: 'file',
    content:
      "# 3D Project Development Rules\n\n## Guideline for Using `RigidBodyObject`\n\nWhen implementing physics interactions, it is mandatory to use the `RigidBodyObject` component from the `vibe-starter-3d` package instead of the standard `RigidBody` from `@react-three/rapier`.\n\nThe primary reason for this is to simplify event handling for collisions and intersections. Using the standard `RigidBody` component requires managing a complex set of events (`onCollisionEnter`, `onCollisionExit`, `onIntersectionEnter`, `onIntersectionExit`).\n\nIn contrast, `RigidBodyObject` abstracts this complexity. It allows you to handle all physics-based interactions uniformly through just two simple trigger events: `onTriggerEnter` and `onTriggerExit`. This makes the interaction logic significantly cleaner and easier to manage.\n\n## Canvas Component Structure Rules\n\n**Core Requirement:** Components that render HTML tags (e.g., `<div>`, `<button>`) must NEVER be placed inside React Three Fiber's `<Canvas>` component.\n\n**Reasoning:**\nThis is a core architectural rule. Placing standard HTML inside the `<Canvas>` WebGL context will cause rendering errors.\n\n**Implementation Guidelines:**\n\n- **UI Components:** Components using HTML tags belong in the `src/components/ui/` directory. They must be rendered as an overlay, outside the `<Canvas>`.\n- **3D Components:** Only Three.js-related components, located in `src/components/r3f/`, should be placed inside the `<Canvas>`.\n\n**Correct Structure Example:**\n\n```tsx\n// ‚úÖ Correct approach\n<div>\n  {/* The 3D scene is rendered inside the Canvas */}\n  <Canvas>\n    <Player />\n    <Floor />\n  </Canvas>\n\n  {/* UI components are rendered as overlays outside the Canvas */}\n  <Crosshair />\n  <LoadingScreen />\n</div>\n```\n\n**Incorrect Structure Example:**\n\n```tsx\n// ‚ùå Incorrect approach\n<Canvas>\n  <Player />\n  {/* This is forbidden, as Crosshair renders HTML */}\n  <Crosshair />\n</Canvas>\n```\n",
    isBinary: false,
  },
  'src/main.tsx': {
    type: 'file',
    content:
      "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport './index.css';\nimport App from './App.tsx';\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n",
    isBinary: false,
  },
  'src/App.css': {
    type: 'file',
    content: '#root {\n  margin: 0 auto;\n  text-align: center;\n}\n',
    isBinary: false,
  },
  'src/index.css': {
    type: 'file',
    content: '@tailwind base;\n@tailwind components;\n@tailwind utilities;\n',
    isBinary: false,
  },
  'src/App.tsx': {
    type: 'file',
    content:
      "import React from 'react';\nimport './App.css';\nimport GameScene from './components/scene/GameScene.tsx';\n\nconst App: React.FC = () => {\n  return (\n    <div style={{ width: '100vw', height: '100vh' }}>\n      <GameScene />\n    </div>\n  );\n};\n\nexport default App;\n",
    isBinary: false,
  },
  'src/utils/effectUtils.ts': {
    type: 'file',
    content:
      "import * as THREE from 'three';\nimport { toVector3Array } from 'vibe-starter-3d';\nimport { BulletEffectConfig } from '../components/r3f/effects/BulletEffectController';\n\nexport const createBulletEffectConfig = (config: BulletEffectConfig): { [key: string]: any } => {\n  return {\n    startPosition: config.startPosition.toArray(),\n    direction: config.direction.toArray(),\n    speed: config.speed || 100,\n    duration: config.duration || 1000,\n    scale: config.scale || 1,\n    color: config.color,\n    flashDuration: config.flashDuration === undefined ? 100 : config.flashDuration,\n  };\n};\n\nexport const createExplosionEffectConfig = (position: THREE.Vector3, scale?: number): { [key: string]: any } => {\n  return {\n    position: toVector3Array(position),\n    scale: scale || 1,\n  };\n};\n",
    isBinary: false,
  },
  'src/types/index.ts': {
    type: 'file',
    content: "// Effect types\nexport * from './effect';\n",
    isBinary: false,
  },
  'src/types/effect.ts': {
    type: 'file',
    content:
      "/**\n * Effect type enumeration\n */\nexport enum EffectType {\n  BULLET = 'BULLET',\n  EXPLOSION = 'EXPLOSION',\n}\n\n/**\n * Base effect data interface\n * Basic structure for all effect-related data\n */\nexport interface EffectData {\n  type: string;\n  config: { [key: string]: any };\n}\n\n/**\n * Active effect interface\n * Effect instance managed on the client\n */\nexport interface ActiveEffect {\n  key: number;\n  // Sender account\n  sender?: string;\n  effectData: EffectData;\n}\n\n/**\n * Effect message exchanged between server and client\n */\nexport interface EffectEventMessage {\n  sender: string;\n  effectData: EffectData;\n  timestamp: number;\n}\n",
    isBinary: false,
  },
  'src/stores/gameStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\ninterface GameStore {\n  isMapPhysicsReady: boolean;\n  setMapPhysicsReady: (ready: boolean) => void;\n}\n\nexport const useGameStore = create<GameStore>()(\n  subscribeWithSelector((set) => ({\n    isMapPhysicsReady: false,\n    setMapPhysicsReady: (ready: boolean) => set({ isMapPhysicsReady: ready }),\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/multiPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport React from 'react';\nimport { RigidBody } from '@dimforge/rapier3d-compat';\n\ntype MultiPlayerRigidBodyState = {\n  connectedPlayerRefs: Record<string, React.RefObject<RigidBody>>;\n  registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => void;\n  unregisterConnectedPlayer: (account: string) => void;\n  getConnectedPlayerRef: (account: string) => React.RefObject<RigidBody> | undefined;\n  getAllConnectedPlayerRefs: () => Record<string, React.RefObject<RigidBody>>;\n  getConnectedPlayerCount: () => number;\n};\n\nexport const useMultiPlayerStore = create<MultiPlayerRigidBodyState>()(\n  subscribeWithSelector((set, get) => ({\n    connectedPlayerRefs: {},\n\n    registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => {\n      set((state) => ({\n        connectedPlayerRefs: {\n          ...state.connectedPlayerRefs,\n          [account]: rigidBodyRef,\n        },\n      }));\n    },\n\n    unregisterConnectedPlayer: (account: string) => {\n      set((state) => {\n        const newConnectedPlayerRefs = { ...state.connectedPlayerRefs };\n        delete newConnectedPlayerRefs[account];\n        return { connectedPlayerRefs: newConnectedPlayerRefs };\n      });\n    },\n\n    getConnectedPlayerRef: (account: string) => {\n      return get().connectedPlayerRefs[account];\n    },\n\n    getAllConnectedPlayerRefs: () => {\n      return get().connectedPlayerRefs;\n    },\n\n    getConnectedPlayerCount: () => {\n      return Object.keys(get().connectedPlayerRefs).length;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/effectStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { ActiveEffect, EffectData } from '../types';\n\n// Define state interface\ninterface EffectState {\n  activeEffects: ActiveEffect[]; // List of active effects\n  effectKeyCounter: number; // Effect unique key counter\n  // Action to add an effect\n  addEffect: (type: string, sender?: string, config?: Record<string, any>) => number; // Returns the key of the added effect\n  // Action to remove an effect\n  removeEffect: (key: number) => void;\n}\n\n// Create Zustand store\nexport const useEffectStore = create<EffectState>((set, get) => ({\n  activeEffects: [], // Initial state: empty array\n  effectKeyCounter: 0, // Initial state: 0\n\n  // Implement effect addition\n  addEffect: (type, sender, config) => {\n    const newKey = get().effectKeyCounter; // Generate a new key with the current counter value\n    // Create EffectData object\n    const effectData: EffectData = {\n      type,\n      config: config,\n    };\n    // Create ActiveEffect object\n    const newEffect: ActiveEffect = {\n      key: newKey,\n      sender,\n      effectData,\n    };\n\n    // State update: add new effect and increment counter\n    set((state) => ({\n      activeEffects: [...state.activeEffects, newEffect],\n      effectKeyCounter: state.effectKeyCounter + 1,\n    }));\n\n    // console.log(`[EffectStore] Effect added: key=${newKey}, type=${type}`); // Debugging log (optional)\n    return newKey; // Return the generated key\n  },\n\n  // Implement effect removal\n  removeEffect: (keyToRemove: number) => {\n    // State update: filter and remove the effect with the corresponding key\n    set((state) => ({\n      activeEffects: state.activeEffects.filter((effect) => effect.key !== keyToRemove),\n    }));\n    // console.log(`[EffectStore] Effect removed: key=${keyToRemove}`); // Debugging log (optional)\n  },\n}));\n\n// Convenience selector hook (optional)\nexport const useActiveEffects = () => useEffectStore((state) => state.activeEffects);\n",
    isBinary: false,
  },
  'src/stores/localPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport * as THREE from 'three';\n\ntype PlayerState = {\n  position: THREE.Vector3;\n  /**\n   * Player speed in meters per second (m/s)\n   * - Convert to km/h by multiplying by 3.6\n   * - Formula: m/s √ó 3.6 = km/h\n   */\n  speed: number;\n};\n\ntype LocalPlayerState = {\n  state: PlayerState;\n  /**\n   * Set speed\n   * @param speed Speed value in meters per second (m/s)\n   */\n  setSpeed: (speed: number) => void;\n  setPosition: (x: number, y: number, z: number) => void;\n  clearPosition: () => void;\n};\n\nexport const useLocalPlayerStore = create<LocalPlayerState>()(\n  subscribeWithSelector((_, get) => ({\n    state: {\n      position: new THREE.Vector3(0, 0, 0),\n      speed: 0,\n    },\n\n    setSpeed: (speed: number) => {\n      get().state.speed = speed;\n    },\n\n    setPosition: (x: number, y: number, z: number) => {\n      const state = get().state;\n      state.position.x = x;\n      state.position.y = y;\n      state.position.z = z;\n    },\n\n    clearPosition: () => {\n      const state = get().state;\n      state.position.x = 0;\n      state.position.y = 0;\n      state.position.z = 0;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/constants/controls.ts': {
    type: 'file',
    content:
      "import { KeyboardControlsEntry } from '@react-three/drei';\n\nexport const keyboardMap: KeyboardControlsEntry[] = [\n  { name: 'forward', keys: ['KeyW'] },\n  { name: 'back', keys: ['KeyS'] },\n  { name: 'yawLeft', keys: ['KeyA'] },\n  { name: 'yawRight', keys: ['KeyD'] },\n  { name: 'pitchUp', keys: ['ArrowUp'] },\n  { name: 'pitchDown', keys: ['ArrowDown'] },\n  { name: 'rollLeft', keys: ['ArrowLeft'] },\n  { name: 'rollRight', keys: ['ArrowRight'] },\n  { name: 'attack', keys: ['Space'] },\n  { name: 'reset', keys: ['KeyR'] },\n  { name: 'action1', keys: ['1'] },\n  { name: 'action2', keys: ['2'] },\n  { name: 'action3', keys: ['3'] },\n  { name: 'action4', keys: ['4'] },\n];\n",
    isBinary: false,
  },
  'src/constants/aircraft.ts': {
    type: 'file',
    content:
      "import { Vector3 } from '@react-three/fiber';\n\nexport const AircraftState: { [key: string]: string } = {\n  ACTIVE: 'ACTIVE',\n  DIE: 'DIE',\n};\n\nexport type AircraftState = (typeof AircraftState)[keyof typeof AircraftState];\n\nexport const DEFAULT_BODY_LENGTH = 3;\nexport const HIT_BODY_SIZE: Vector3 = [1, 0.6, 3];\n",
    isBinary: false,
  },
  'src/constants/rigidBodyObjectType.ts': {
    type: 'file',
    content:
      "export const RigidBodyObjectType = {\n  /** Local Player */\n  LOCAL_PLAYER: 'LOCAL_PLAYER',\n  /** Enemy */\n  ENEMY: 'ENEMY',\n  /** Monster */\n  MONSTER: 'MONSTER',\n  /** Wall */\n  WALL: 'WALL',\n  /** Obstacle */\n  OBSTACLE: 'OBSTACLE',\n  /** Item */\n  ITEM: 'ITEM',\n  /** Bullet */\n  BULLET: 'BULLET',\n  /** Floor */\n  FLOOR: 'FLOOR',\n  /** Sea */\n  SEA: 'SEA',\n  /** Floating board */\n  PLOTTING_BOARD: 'PLOTTING_BOARD',\n} as const;\n",
    isBinary: false,
  },
  'src/components/scene/GameScene.tsx': {
    type: 'file',
    content:
      "import GameSceneCanvas from '../r3f/GameSceneCanvas';\nimport GameSceneUI from '../ui/GameSceneUI';\n\n/**\n * Main Game Scene Component\n *\n * This component serves as a layout container that arranges the game UI and 3D Canvas.\n *\n * üö® CRITICAL PERFORMANCE WARNING:\n * Re-rendering of this component triggers re-rendering of the entire 3D Canvas, causing severe performance degradation.\n *\n * Prohibited Actions:\n * - Using state management hooks like useState, useReducer\n * - Passing frequently changing values as props\n * - State updates inside useEffect\n * - Conditional rendering that changes component structure\n * - Creating inline objects/functions (e.g., style={{...}}, onClick={() => {}})\n *\n * Recommendations:\n * - Handle state management in child components (GameSceneUI, GameSceneCanvas)\n * - Access global state directly through zustand store or similar\n * - Memoize event handlers with useCallback before use\n */\nconst GameScene = () => {\n  return (\n    <div className=\"relative w-full h-screen\">\n      <GameSceneUI />\n      <GameSceneCanvas />\n    </div>\n  );\n};\n\nexport default GameScene;\n",
    isBinary: false,
  },
  'src/components/ui/GameSceneUI.tsx': {
    type: 'file',
    content:
      "import { useGameStore } from '../../stores/gameStore';\nimport LoadingScreen from './LoadingScreen';\nimport StatusDisplay from './StatusDisplay';\n\n/**\n * Game Scene UI Component\n *\n * This component manages UI overlays for the game scene.\n * It handles loading states and displays appropriate UI elements based on game state.\n */\nconst GameSceneUI = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* Loading Game Scene screen overlay */}\n      {!isMapPhysicsReady && <LoadingScreen />}\n\n      {/* UI Overlay */}\n      {isMapPhysicsReady && <StatusDisplay />}\n    </>\n  );\n};\n\nexport default GameSceneUI;\n",
    isBinary: false,
  },
  'src/components/ui/LoadingScreen.tsx': {
    type: 'file',
    content:
      "import { useThree } from '@react-three/fiber';\nimport { Html } from '@react-three/drei';\n\n/**\n * Loading screen component\n */\nconst LoadingScreen = () => {\n  let isInThreeCanvas: boolean;\n  try {\n    useThree();\n    isInThreeCanvas = true;\n  } catch {\n    isInThreeCanvas = false;\n  }\n\n  const loadingContent = (\n    <div>\n      <style>{`\n        .loading-container {\n          inset: 0;\n          z-index: 50;\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: center;\n          background-color: black;\n          color: white;\n          width: 100%;\n          height: 100%;\n        }\n        .loading-title {\n          font-size: 1.5rem;\n          font-weight: bold;\n          margin-bottom: 1rem;\n        }\n        .spinner {\n          width: 30px;\n          height: 30px;\n          border: 3px solid rgba(255, 255, 255, 0.3);\n          border-radius: 50%;\n          border-top-color: white;\n          animation: spin 1s ease-in-out infinite;\n        }\n        @keyframes spin {\n          to {\n            transform: rotate(360deg);\n          }\n        }\n      `}</style>\n      <div className=\"loading-container\">\n        <h2 className=\"loading-title\">Loading</h2>\n        <div className=\"spinner\"></div>\n      </div>\n    </div>\n  );\n\n  if (isInThreeCanvas) {\n    return (\n      <Html\n        center\n        style={{\n          width: '100vw',\n          height: '100vh',\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          pointerEvents: 'none',\n        }}\n      >\n        {loadingContent}\n      </Html>\n    );\n  }\n\n  return loadingContent;\n};\n\nexport default LoadingScreen;\n",
    isBinary: false,
  },
  'src/components/ui/StatusDisplay.tsx': {
    type: 'file',
    content:
      "import React, { useState, useEffect, useRef } from 'react';\nimport { useGameServer, useRoomState } from '@agent8/gameserver';\nimport { useLocalPlayerStore } from '../../stores/localPlayerStore';\n\nconst StatusDisplay: React.FC = () => {\n  const { server, connected } = useGameServer();\n  const { roomId } = useRoomState();\n  const [speedKmh, setSpeedKmh] = useState(0);\n  const [altitude, setAltitude] = useState(0);\n  const [hp, setHp] = useState(0);\n  const [maxHp, setMaxHp] = useState(0);\n  const [players, setPlayers] = useState(0);\n  const animationId = useRef<number | null>(null);\n  const { state } = useLocalPlayerStore();\n\n  useEffect(() => {\n    const updateStatus = () => {\n      setSpeedKmh(parseFloat((state.speed * 3.6).toFixed(1)));\n      setAltitude(parseFloat(state.position.y.toFixed(1)));\n\n      animationId.current = requestAnimationFrame(updateStatus);\n    };\n\n    animationId.current = requestAnimationFrame(updateStatus);\n\n    return () => {\n      cancelAnimationFrame(animationId.current);\n    };\n  }, [state]);\n\n  useEffect(() => {\n    if (!server || !connected || !roomId) return;\n\n    const unsubscribe = server.subscribeRoomState(roomId, (roomState) => {\n      setPlayers(roomState.$users.length);\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, [server, connected, roomId]);\n\n  useEffect(() => {\n    if (!server || !connected || !roomId) return;\n\n    const unsubscribe = server.subscribeRoomMyState(roomId, (roomMyState) => {\n      if (roomMyState.stats) {\n        setHp(roomMyState.stats.currentHp);\n        setMaxHp(roomMyState.stats.maxHp);\n      }\n    });\n\n    return () => {\n      unsubscribe();\n    };\n  }, [server, connected, roomId]);\n\n  return (\n    <div\n      style={{\n        position: 'absolute',\n        top: '60px',\n        left: '10px',\n        color: 'white',\n        backgroundColor: 'rgba(0, 0, 0, 0.5)',\n        padding: '10px',\n        borderRadius: '5px',\n        fontFamily: 'monospace',\n        zIndex: 1, // Ensure UI is on top of the canvas\n      }}\n    >\n      <div>Players: {players}</div>\n      <div>Health: {hp ? ((hp / maxHp) * 100).toFixed(0) : 0}%</div>\n      <div>Speed: {speedKmh.toFixed(1)} km/h</div>\n      <div>Altitude: {altitude.toFixed(1)} m</div>\n      <hr style={{ margin: '5px 0' }} />\n      <div>Controls:</div>\n      <div>W/S: Speed</div>\n      <div>A/D: Yaw</div>\n      <div>Arrows: Pitch/Roll</div>\n      <hr style={{ margin: '5px 0' }} />\n      <div>R: Reset</div>\n    </div>\n  );\n};\n\nexport default StatusDisplay;\n",
    isBinary: false,
  },
  'src/components/r3f/Aircraft.tsx': {
    type: 'file',
    content:
      "import { useRef } from 'react';\nimport { useFrame, GroupProps } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { Trail } from '@react-three/drei';\nimport { useLocalPlayerStore } from '../../stores/localPlayerStore';\n\ninterface AircraftProps extends GroupProps {\n  localPlayer?: boolean;\n  bodyLength?: number;\n  bodyColor?: string;\n}\n\nconst Aircraft = ({ localPlayer = false, bodyLength = 3, bodyColor = '#f5f5f5', ...props }: AircraftProps) => {\n  const helixMeshRef = useRef<THREE.Mesh>(null);\n  const tip1Ref = useRef<THREE.Object3D>(null);\n  const tip2Ref = useRef<THREE.Object3D>(null);\n  const { state } = useLocalPlayerStore();\n\n  useFrame((_, delta) => {\n    if (helixMeshRef.current) {\n      let rotZ: number;\n      if (localPlayer) {\n        rotZ = 1.0 * delta * Math.min(60, state.speed);\n      } else {\n        rotZ = 1.0 * delta * 60;\n      }\n\n      helixMeshRef.current.rotation.z -= rotZ;\n    }\n  });\n\n  return (\n    <>\n      <group scale={bodyLength}>\n        <group position={[0, 0.1, 0]} {...props}>\n          {/* Body */}\n          <mesh castShadow position={[0, 0.01, 0]}>\n            <boxGeometry args={[0.18, 0.18, 1]} />\n            <meshStandardMaterial color={bodyColor} />\n          </mesh>\n          {/* Cockpit Window */}\n          <mesh castShadow position={[0, 0.04, -0.32]} renderOrder={1}>\n            <boxGeometry args={[0.19, 0.16, 0.22]} />\n            <meshStandardMaterial color=\"skyblue\" transparent={true} opacity={0.8} />\n          </mesh>\n          {/* Nose Cone */}\n          <mesh castShadow position={[0, -0.01, -0.54]}>\n            <boxGeometry args={[0.13, 0.13, 0.13]} />\n            <meshStandardMaterial color=\"orange\" />\n          </mesh>\n          {/* Wings */}\n          <group position={[0, 0.07, -0.066]}>\n            <mesh castShadow>\n              <boxGeometry args={[1.4, 0.02, 0.26]} />\n              <meshStandardMaterial color={bodyColor} />\n            </mesh>\n            {/* Empty objects at propeller tips to act as targets */}\n            <object3D ref={tip1Ref} position={[-0.7, 0, 0]} />\n            <object3D ref={tip2Ref} position={[0.7, 0, 0]} />\n          </group>\n          {/* Tail Wing */}\n          <mesh castShadow position={[0, 0.06, 0.44]}>\n            <boxGeometry args={[0.533, 0.02, 0.16]} />\n            <meshStandardMaterial color={bodyColor} />\n          </mesh>\n          {/* Tail Fin */}\n          <mesh castShadow position={[0, 0.12, 0.42]}>\n            <boxGeometry args={[0.02, 0.18, 0.24]} />\n            <meshStandardMaterial color={bodyColor} />\n          </mesh>\n          {/* Propeller */}\n          <mesh castShadow ref={helixMeshRef} position={[0, 0, -0.62]} rotation-z={Math.PI / 2}>\n            <boxGeometry args={[0.02, 0.4, 0.02]} />\n            <meshStandardMaterial color=\"gray\" />\n          </mesh>\n          {/* Trails targeting the propeller tips */}\n          <Trail width={1 * bodyLength} color=\"#dddddd\" length={1} decay={1} attenuation={(width) => width * 0.5} target={tip1Ref} />\n          <Trail width={1 * bodyLength} color=\"#dddddd\" length={1} decay={1} attenuation={(width) => width * 0.5} target={tip2Ref} />\n        </group>\n      </group>\n    </>\n  );\n};\n\nexport default Aircraft;\n",
    isBinary: false,
  },
  'src/components/r3f/FloatingShapes.tsx': {
    type: 'file',
    content:
      "import { useMemo, useRef } from 'react';\nimport * as THREE from 'three';\nimport { BallCollider } from '@react-three/rapier';\nimport { useFrame } from '@react-three/fiber';\nimport { RigidBodyObject, RigidBodyObjectRef } from 'vibe-starter-3d';\n\n// Define movement types\ntype MovementType = 'oscillate' | 'circle' | 'drift';\n\n// Define movement parameter types\ninterface MovementParams {\n  amplitude?: number;\n  speed?: number;\n  radius?: number;\n  direction?: THREE.Vector3;\n}\n\n// Define object types\ntype FloatingObjectType = 'balloon' | 'bird' | 'plane';\n\n// Define object data type (includes movement information)\ninterface FloatingObjectData {\n  id: number;\n  type: FloatingObjectType;\n  position: [number, number, number];\n  color: string;\n  scale: number;\n  movementType: MovementType;\n  movementParams: MovementParams;\n}\n\n// Render each object type and move it\nconst FloatingObject = ({ data }: { data: FloatingObjectData }) => {\n  const rigidBodyRef = useRef<RigidBodyObjectRef>(null!);\n  const initialPosition = useRef(new THREE.Vector3(...data.position)).current;\n  const angleRef = useRef(Math.random() * Math.PI * 2);\n  const driftDirection = useRef(data.movementParams.direction?.clone() || new THREE.Vector3(0, 0, 0)).current;\n\n  useFrame((state, delta) => {\n    if (!rigidBodyRef.current) return;\n\n    const t = state.clock.elapsedTime;\n    const { movementType, movementParams } = data;\n    const nextPosition = new THREE.Vector3();\n\n    const currentPositionVec = rigidBodyRef.current.translation();\n    nextPosition.set(currentPositionVec.x, currentPositionVec.y, currentPositionVec.z);\n\n    switch (movementType) {\n      case 'circle': {\n        const speed = movementParams.speed || 0.2;\n        const radius = movementParams.radius || 15;\n        angleRef.current += speed * delta;\n        nextPosition.x = initialPosition.x + Math.cos(angleRef.current) * radius;\n        nextPosition.z = initialPosition.z + Math.sin(angleRef.current) * radius;\n        nextPosition.y = initialPosition.y + Math.sin(t * (movementParams.speed || 0.2) * 0.5 + initialPosition.x) * (movementParams.amplitude || 3);\n        break;\n      }\n\n      case 'drift':\n        nextPosition.set(\n          currentPositionVec.x + driftDirection.x * (movementParams.speed || 10) * delta,\n          currentPositionVec.y + driftDirection.y * (movementParams.speed || 2) * delta,\n          currentPositionVec.z + driftDirection.z * (movementParams.speed || 10) * delta,\n        );\n        break;\n\n      case 'oscillate':\n      default: {\n        const amplitude = movementParams.amplitude || 5;\n        nextPosition.y = initialPosition.y + Math.sin(t * (movementParams.speed || 0.5) + initialPosition.x) * amplitude;\n        nextPosition.x = currentPositionVec.x;\n        nextPosition.z = currentPositionVec.z;\n        break;\n      }\n    }\n    // Check if translation() and setNextKinematicTranslation() methods exist (use any if not)\n    rigidBodyRef.current.setNextKinematicTranslation(nextPosition);\n  });\n\n  let geometry: React.ReactNode;\n  let colliderArgs: [number] = [data.scale * 1.5];\n\n  switch (data.type) {\n    case 'balloon':\n      geometry = (\n        <group>\n          <mesh position={[0, 0, 0]}>\n            <sphereGeometry args={[data.scale * 1.5, 32, 32]} />\n            <meshStandardMaterial color={data.color} />\n          </mesh>\n          <mesh position={[0, -data.scale * 1.5, 0]}>\n            <coneGeometry args={[data.scale * 0.8, data.scale, 8]} />\n            <meshStandardMaterial color=\"saddlebrown\" />\n          </mesh>\n        </group>\n      );\n      colliderArgs = [data.scale * 1.5];\n      break;\n    case 'bird':\n      geometry = (\n        <group rotation={[0, Math.random() * Math.PI * 2, 0]}>\n          <mesh position={[0, 0, 0]} rotation={[0, 0, Math.PI / 12]}>\n            <boxGeometry args={[data.scale * 3, data.scale * 0.2, data.scale * 0.5]} />\n            <meshStandardMaterial color={data.color} />\n          </mesh>\n          <mesh position={[data.scale * 1.5, 0, 0]} rotation={[0, 0, -Math.PI / 6]}>\n            <boxGeometry args={[data.scale * 3, data.scale * 0.2, data.scale * 0.5]} />\n            <meshStandardMaterial color={data.color} />\n          </mesh>\n        </group>\n      );\n      colliderArgs = [data.scale * 1.5];\n      break;\n    case 'plane':\n    default:\n      geometry = (\n        <group rotation={[0, Math.random() * Math.PI * 2, 0]}>\n          {/* Î™∏Ï≤¥ */}\n          <mesh position={[0, 0, 0]}>\n            <boxGeometry args={[data.scale * 3, data.scale * 0.8, data.scale]} />\n            <meshStandardMaterial color={data.color} />\n          </mesh>\n          {/* ÎÇ†Í∞ú */}\n          <mesh position={[0, 0, 0]}>\n            <boxGeometry args={[data.scale * 0.5, data.scale * 0.2, data.scale * 4]} />\n            <meshStandardMaterial color=\"lightgray\" />\n          </mesh>\n        </group>\n      );\n      colliderArgs = [data.scale * 2];\n      break;\n  }\n\n  return (\n    <RigidBodyObject key={data.id} ref={rigidBodyRef} type=\"kinematicPosition\" colliders={false} position={data.position}>\n      <BallCollider args={colliderArgs} />\n      <group>{geometry}</group>\n    </RigidBodyObject>\n  );\n};\n\nconst FloatingShapes = () => {\n  const objectsData = useMemo(() => {\n    const dataArray: FloatingObjectData[] = [];\n    const count = 150;\n    const types: FloatingObjectType[] = ['balloon', 'bird', 'plane'];\n    const colors = ['red', 'blue', 'yellow', 'white', 'orange', 'purple', 'pink', 'cyan'];\n    const movementTypes: MovementType[] = ['oscillate', 'circle', 'drift'];\n\n    for (let i = 0; i < count; i++) {\n      const x = (Math.random() - 0.5) * 3000;\n      const y = Math.random() * 300 + 100;\n      const z = (Math.random() - 0.5) * 3000;\n\n      const type = types[Math.floor(Math.random() * types.length)];\n      const color = colors[Math.floor(Math.random() * colors.length)];\n      const scale = Math.random() * 5 + 5;\n\n      const movementType = movementTypes[Math.floor(Math.random() * movementTypes.length)];\n      let movementParams: MovementParams = {};\n      switch (movementType) {\n        case 'circle':\n          movementParams = {\n            radius: Math.random() * 10 + 10,\n            speed: Math.random() * 0.3 + 0.1,\n            amplitude: Math.random() * 4 + 1,\n          };\n          break;\n        case 'drift':\n          movementParams = {\n            direction: new THREE.Vector3((Math.random() - 0.5) * 2, (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 2).normalize(),\n            speed: Math.random() * 20 + 10,\n          };\n          break;\n        case 'oscillate':\n        default:\n          movementParams = {\n            amplitude: Math.random() * 8 + 2,\n            speed: Math.random() * 0.5 + 0.2,\n          };\n          break;\n      }\n\n      dataArray.push({\n        id: i,\n        type,\n        position: [x, y, z],\n        color,\n        scale,\n        movementType,\n        movementParams,\n      });\n    }\n    return dataArray;\n  }, []);\n\n  return (\n    <>\n      {objectsData.map((data) => (\n        <FloatingObject key={data.id} data={data} />\n      ))}\n    </>\n  );\n};\n\nexport default FloatingShapes;\n",
    isBinary: false,
  },
  'src/components/r3f/GameSceneCanvas.tsx': {
    type: 'file',
    content:
      "import React, { Suspense } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { Physics } from '@react-three/rapier';\nimport { FlightControllerKeyMapping, FlightViewController, FollowLight } from 'vibe-starter-3d';\nimport { useGameStore } from '../../stores/gameStore';\nimport { Sky } from '@react-three/drei';\nimport MapPhysicsReadyChecker from '../r3f/MapPhysicsReadyChecker';\nimport EffectContainer from './EffectContainer';\nimport Player from './Player';\nimport FloatingShapes from './FloatingShapes';\nimport Ground from './Ground';\n\nconst movementKeyMapping: FlightControllerKeyMapping = {\n  forward: ['KeyW'],\n  backward: ['KeyS'],\n  leftward: ['KeyA'],\n  rightward: ['KeyD'],\n  pitchUp: ['ArrowUp'],\n  pitchDown: ['ArrowDown'],\n  rollLeft: ['ArrowLeft'],\n  rollRight: ['ArrowRight'],\n};\n\n/**\n * Game Scene Canvas Component\n *\n * This component is responsible for rendering the entire 3D game world using React Three Fiber.\n * It serves as the root container for all 3D elements, physics simulation, and game interactions.\n */\nconst GameSceneCanvas = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* ‚ö†Ô∏è DO NOT DELETE: Core Canvas component for React Three Fiber */}\n      <Canvas\n        shadows\n        camera={{ far: 5000 }}\n        onPointerDown={(e) => {\n          (e.target as HTMLCanvasElement).requestPointerLock();\n        }}\n      >\n        <Physics paused={!isMapPhysicsReady} debug={false}>\n          <Suspense fallback={null}>\n            {/* ‚ö†Ô∏è MUST INCLUDE: Essential checker for map physics initialization */}\n            {!isMapPhysicsReady && <MapPhysicsReadyChecker />}\n            <FlightViewController keyMapping={movementKeyMapping} />\n            <EffectContainer />\n            <Sky distance={450000} sunPosition={[-20, 30, 10]} turbidity={0.8} rayleigh={0.4} />\n            <ambientLight intensity={1.2} />\n            <FollowLight />\n            <Player />\n            <FloatingShapes />\n            <Ground />\n          </Suspense>\n        </Physics>\n      </Canvas>\n    </>\n  );\n};\n\nexport default GameSceneCanvas;\n",
    isBinary: false,
  },
  'src/components/r3f/EffectContainer.tsx': {
    type: 'file',
    content:
      "import { useCallback } from 'react';\nimport * as THREE from 'three';\nimport { ActiveEffect, EffectType } from '../../types';\nimport { useEffectStore, useActiveEffects } from '../../stores/effectStore';\nimport { useMultiPlayerStore } from '../../stores/multiPlayerStore';\nimport { createExplosionEffectConfig } from '../../utils/effectUtils';\nimport Explosion from './effects/Explosion';\nimport BulletEffectController from './effects/BulletEffectController';\nimport { CollisionPayload } from '@react-three/rapier';\n\n/**\n * Effect container component using Zustand store for effect management.\n */\nfunction EffectContainer() {\n  const { getConnectedPlayerRef } = useMultiPlayerStore();\n\n  // Get state and actions from the Zustand store\n  const activeEffects = useActiveEffects();\n  const addEffect = useEffectStore((state) => state.addEffect);\n  const removeEffect = useEffectStore((state) => state.removeEffect);\n\n  // Callback to remove completed effects using the store action\n  const handleEffectComplete = useCallback(\n    (keyToRemove: number) => {\n      removeEffect(keyToRemove);\n    },\n    [removeEffect],\n  );\n\n  // Handler for when an effect hits something (logic might be needed here)\n  const handleEffectHit = useCallback(\n    (type: EffectType, payload: CollisionPayload, sender?: string): boolean => {\n      const otherAccount = payload.other.rigidBody?.userData?.['account'];\n      if (sender && otherAccount) {\n        if (otherAccount === sender) return false;\n      }\n\n      if (type === EffectType.BULLET) {\n        const hitPoint = payload.target.collider.translation();\n        addEffect(EffectType.EXPLOSION, undefined, createExplosionEffectConfig(new THREE.Vector3(hitPoint.x, hitPoint.y, hitPoint.z), 0.1));\n      }\n\n      return true;\n    },\n    [addEffect],\n  );\n\n  // Function to render individual effects based on their type\n  const renderEffect = useCallback(\n    (effect: ActiveEffect) => {\n      const type = effect.effectData.type;\n\n      switch (type) {\n        case EffectType.BULLET:\n          return (\n            <BulletEffectController\n              key={effect.key}\n              config={effect.effectData.config}\n              owner={getConnectedPlayerRef(effect.sender)?.current}\n              onHit={(payload) => handleEffectHit(type, payload, effect.sender)}\n              onComplete={() => {\n                handleEffectComplete(effect.key);\n              }}\n            />\n          );\n        case EffectType.EXPLOSION:\n          return (\n            <Explosion\n              key={effect.key}\n              config={effect.effectData.config}\n              onComplete={() => {\n                handleEffectComplete(effect.key);\n              }}\n            />\n          );\n        // Add cases for other effect types here\n        default:\n          console.warn(`[EffectContainer] Unknown effect type: ${type}`);\n          return null;\n      }\n    },\n    [handleEffectHit, handleEffectComplete, getConnectedPlayerRef],\n  );\n\n  // Render all active effects from the store\n  return <>{activeEffects.map(renderEffect)}</>;\n}\n\nexport default EffectContainer;\n",
    isBinary: false,
  },
  'src/components/r3f/Ground.tsx': {
    type: 'file',
    content:
      "import { useMemo } from 'react';\nimport * as THREE from 'three';\nimport { RigidBodyObject } from 'vibe-starter-3d';\nimport { RigidBodyObjectType } from '../../constants/rigidBodyObjectType';\n\ntype SimpleObject = {\n  position: THREE.Vector3;\n  scale: THREE.Vector3;\n  rotationY: number;\n  geometryType: 'box' | 'sphere' | 'cone';\n  color: THREE.Color;\n};\n\nconst Ground = () => {\n  // Generate object data to scatter on the ground (optimized with useMemo)\n  const objects = useMemo<SimpleObject[]>(() => {\n    const tempObjects: SimpleObject[] = [];\n    const count = 500;\n    const planeSize = 1000;\n    const runwayWidth = 6;\n    const minScale = 1.0;\n    const maxScale = 4.0;\n    const colors = [\n      new THREE.Color('#5a8a38'), // Dark Green\n      new THREE.Color('#6b9c46'), // Medium Green\n      new THREE.Color('#88ab6c'), // Light Green\n      new THREE.Color('#8b4513'), // Brown\n      new THREE.Color('#a0522d'), // Sienna\n    ];\n    const geometryTypes: SimpleObject['geometryType'][] = ['box', 'sphere', 'cone'];\n\n    for (let i = 0; i < count; i++) {\n      // Calculate X position avoiding the runway area\n      let x = (Math.random() - 0.5) * planeSize;\n      if (Math.abs(x) < runwayWidth / 2 + 5) {\n        // Do not generate within 5 units near the runway\n        x = Math.sign(x) * (runwayWidth / 2 + 5 + Math.random() * (planeSize / 2 - runwayWidth / 2 - 5));\n      }\n      const z = (Math.random() - 0.5) * planeSize;\n\n      const scaleFactor = THREE.MathUtils.randFloat(minScale, maxScale);\n      const scale = new THREE.Vector3(scaleFactor, scaleFactor * THREE.MathUtils.randFloat(0.8, 1.5), scaleFactor);\n\n      const position = new THREE.Vector3(x, scale.y / 2, z);\n\n      const rotationY = Math.random() * Math.PI * 2;\n      const color = colors[Math.floor(Math.random() * colors.length)];\n      const geometryType = geometryTypes[Math.floor(Math.random() * geometryTypes.length)];\n\n      tempObjects.push({ position, scale, rotationY, geometryType, color });\n    }\n    return tempObjects;\n  }, []);\n\n  return (\n    <>\n      <RigidBodyObject type=\"fixed\" colliders={'cuboid'} userData={{ type: RigidBodyObjectType.SEA }}>\n        <mesh receiveShadow rotation={[-Math.PI / 2, 0, 0]} position={[0, -1, 0]} scale={[10000, 10000, 1]}>\n          <planeGeometry args={[1, 1]} />\n          <meshStandardMaterial color=\"#77aaff\" />\n        </mesh>\n      </RigidBodyObject>\n\n      <RigidBodyObject type=\"fixed\" colliders={'cuboid'} userData={{ type: RigidBodyObjectType.FLOOR }}>\n        <mesh receiveShadow rotation={[-Math.PI / 2, 0, 0]} position={[0, 0, 0]} scale={[1000, 1000, 1]}>\n          <planeGeometry args={[1, 1]} />\n          <meshStandardMaterial color=\"#3d711c\" />\n        </mesh>\n      </RigidBodyObject>\n\n      {/* Runway with markings as one RigidBody */}\n      <RigidBodyObject type=\"fixed\" colliders={'cuboid'}>\n        {/* Runway surface */}\n        <mesh receiveShadow rotation={[-Math.PI / 2, 0, 0]} position={[0, 0.01, 0]} scale={[6, 1000, 1]}>\n          <planeGeometry args={[1, 1]} />\n          <meshStandardMaterial color=\"#51595c\" />\n        </mesh>\n\n        {/* Runway Markings */}\n        {Array.from({ length: 100 }).map((_, i) => {\n          const zPosition = -500 + i * 10;\n          return (\n            <mesh\n              key={`runway-line-${i}`}\n              receiveShadow\n              rotation={[-Math.PI / 2, 0, 0]}\n              position={[0, 0.011, zPosition]}\n              scale={[0.4, 5, 1]} // X: length, Y: width (relative to geometry)\n            >\n              <planeGeometry args={[1, 1]} />\n              <meshStandardMaterial\n                color=\"#ffffff\"\n                polygonOffset\n                polygonOffsetFactor={-20.0}\n                polygonOffsetUnits={-100.0} // Slightly more offset than the runway\n              />\n            </mesh>\n          );\n        })}\n      </RigidBodyObject>\n\n      {/* Test objects scattered on the ground */}\n      {objects.map((obj, index) => (\n        <mesh key={index} position={obj.position} scale={obj.scale} rotation={[0, obj.rotationY, 0]} castShadow receiveShadow>\n          {obj.geometryType === 'box' && <boxGeometry args={[1, 1, 1]} />}\n          {obj.geometryType === 'sphere' && <sphereGeometry args={[0.5, 16, 8]} />} {/* radius, widthSegments, heightSegments */}\n          {obj.geometryType === 'cone' && <coneGeometry args={[0.5, 1, 16]} />} {/* radius, height, radialSegments */}\n          <meshStandardMaterial color={obj.color} roughness={0.8} metalness={0.1} />\n        </mesh>\n      ))}\n    </>\n  );\n};\n\nexport default Ground;\n",
    isBinary: false,
  },
  'src/components/r3f/MapPhysicsReadyChecker.tsx': {
    type: 'file',
    content:
      "import { useFrame } from '@react-three/fiber';\nimport { useRapier } from '@react-three/rapier';\nimport { useRef } from 'react';\nimport * as THREE from 'three';\nimport { useGameStore } from '../../stores/gameStore';\n\n/**\n * Component that checks if the map physics is ready by performing raycasting.\n * Casts a ray downward from above to detect map geometry and ensures physics\n * interactions are properly initialized before gameplay begins.\n *\n * - Performs checks every frame until map physics is confirmed ready\n * - Times out after 60 frames as fallback to prevent infinite checking\n * - Excludes Capsule shapes (likely characters/objects) and sensor colliders\n * - Sets mapPhysicsReady to true once valid map geometry is detected\n */\nfunction MapPhysicsReadyChecker() {\n  const { isMapPhysicsReady, setMapPhysicsReady } = useGameStore();\n  const physicsCheckCount = useRef(0);\n  const { rapier, world } = useRapier();\n\n  useFrame(() => {\n    if (isMapPhysicsReady) return;\n\n    physicsCheckCount.current++;\n    if (physicsCheckCount.current > 180) {\n      setMapPhysicsReady(true);\n      return;\n    }\n\n    const origin = new THREE.Vector3(0, 50, 0);\n    const downDirection = new THREE.Vector3(0, -1, 0);\n    const ray = new rapier.Ray(origin, downDirection);\n\n    // Get all intersections and find the first non-sensor collider\n    const intersections: any[] = [];\n    world.propagateModifiedBodyPositionsToColliders();\n    world.updateSceneQueries();\n    world.intersectionsWithRay(ray, 100, true, (intersection) => {\n      // Exclude Capsule shapes as they are unlikely to be map colliders\n      if (intersection.collider.shape.type === rapier.ShapeType.Capsule) {\n        return true;\n      }\n      intersections.push(intersection);\n      return true; // continue searching\n    });\n\n    // Find the first non-sensor collider\n    const validHit = intersections.find((intersection) => !intersection.collider.isSensor());\n    if (!validHit) return;\n\n    console.log('%c[vibe-starter-3d]%c Map physics initialized.', 'color: #7159c1; font-weight: bold', 'color: inherit;');\n    setMapPhysicsReady(true);\n  });\n\n  return null;\n}\n\nexport default MapPhysicsReadyChecker;\n",
    isBinary: false,
  },
  'src/components/r3f/Player.tsx': {
    type: 'file',
    content:
      "import React, { useCallback, useEffect, useRef } from 'react';\nimport { RigidBodyPlayer, RigidBodyPlayerRef, useControllerState } from 'vibe-starter-3d';\nimport * as THREE from 'three';\nimport { useGameServer } from '@agent8/gameserver';\nimport { useEffectStore } from '../../stores/effectStore';\nimport { useFrame } from '@react-three/fiber';\nimport { EffectType } from '../../types';\nimport { useMultiPlayerStore } from '../../stores/multiPlayerStore';\nimport { CollisionPayload, CuboidCollider } from '@react-three/rapier';\nimport { createBulletEffectConfig } from '../../utils/effectUtils';\nimport Aircraft from './Aircraft';\nimport { ActiveCollisionTypes } from '@dimforge/rapier3d-compat';\nimport { useLocalPlayerStore } from '../../stores/localPlayerStore';\nimport { RigidBodyObjectType } from '../../constants/rigidBodyObjectType';\n\nconst SHOOT_COOLDOWN = 200;\nconst AIRCRAFT_BODY_LENGTH = 3;\n\n// Action types enum\nenum ActionType {\n  RESET = 'reset',\n  ATTACK = 'attack',\n}\n\nconst keyMapping = {\n  [ActionType.RESET]: ['KeyR'],\n  [ActionType.ATTACK]: ['Space'],\n};\n\nconst Player = () => {\n  const { account } = useGameServer();\n  const { registerConnectedPlayer, unregisterConnectedPlayer } = useMultiPlayerStore();\n  const { setPosition: setLocalPlayerPosition, setSpeed: setLocalPlayerSpeed } = useLocalPlayerStore();\n  const { setPosition, setRotation, setVelocity } = useControllerState();\n\n  // IMPORTANT: rigidBodyPlayerRef.current type is RigidBody\n  const rigidBodyPlayerRef = useRef<RigidBodyPlayerRef>(null);\n  const canShootTimestamp = useRef(0);\n  const lastFramePressedReset = useRef(false);\n\n  // Speed calculation refs\n  const previousPosition = useRef<THREE.Vector3 | null>(null);\n  const speedHistory = useRef<{ distance: number; deltaTime: number }[]>([]);\n  const SPEED_HISTORY_LENGTH = 5;\n\n  // IMPORTANT: Register connected player reference\n  useEffect(() => {\n    if (!account) return;\n\n    registerConnectedPlayer(account, rigidBodyPlayerRef);\n\n    return () => {\n      unregisterConnectedPlayer(account);\n    };\n  }, [account, registerConnectedPlayer, unregisterConnectedPlayer]);\n\n  // IMPORTANT: Update local player store position information\n  useFrame(() => {\n    const playerRigidBody = rigidBodyPlayerRef.current;\n    if (!playerRigidBody) return;\n\n    const position = playerRigidBody.translation();\n    setLocalPlayerPosition(position.x, position.y, position.z);\n  });\n\n  // IMPORTANT: Update local player speed calculation based on position changes over 5 frames\n  useFrame((_, delta) => {\n    const playerRigidBody = rigidBodyPlayerRef.current;\n    if (!playerRigidBody) return;\n\n    const currentPosition = new THREE.Vector3().copy(playerRigidBody.translation());\n\n    if (previousPosition.current) {\n      // Calculate distance moved this frame\n      const distance = currentPosition.distanceTo(previousPosition.current);\n\n      // Add to speed history\n      speedHistory.current.push({ distance, deltaTime: delta });\n\n      // Keep only the last 5 frames\n      if (speedHistory.current.length > SPEED_HISTORY_LENGTH) {\n        speedHistory.current.shift();\n      }\n\n      // Calculate average speed over the last frames\n      if (speedHistory.current.length > 0) {\n        const totalDistance = speedHistory.current.reduce((sum, frame) => sum + frame.distance, 0);\n        const totalTime = speedHistory.current.reduce((sum, frame) => sum + frame.deltaTime, 0);\n\n        // Calculate speed (distance per second)\n        const speed = totalTime > 0 ? totalDistance / totalTime : 0;\n        setLocalPlayerSpeed(speed);\n      }\n    }\n\n    // Update previous position for next frame\n    previousPosition.current = currentPosition.clone();\n  });\n\n  // Action input state management - only for actions, not movement\n  const actionInputRef = useRef<Partial<Record<ActionType, boolean>>>({});\n\n  // Set up key event listeners for actions only\n  useEffect(() => {\n    const actionKeys = Object.values(ActionType);\n\n    const initialState: Partial<Record<ActionType, boolean>> = {};\n    actionKeys.forEach((action) => {\n      initialState[action] = false;\n    });\n    actionInputRef.current = initialState;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      actionKeys.forEach((action) => {\n        if (keyMapping[action]?.includes(event.code)) {\n          actionInputRef.current[action] = true;\n        }\n      });\n    };\n\n    const handleKeyUp = (event: KeyboardEvent) => {\n      actionKeys.forEach((action) => {\n        if (keyMapping[action]?.includes(event.code)) {\n          actionInputRef.current[action] = false;\n        }\n      });\n    };\n\n    const handleMouseDown = (event: MouseEvent) => {\n      const mouseButton = `Mouse${event.button}`;\n      actionKeys.forEach((action) => {\n        if (keyMapping[action]?.includes(mouseButton)) {\n          actionInputRef.current[action] = true;\n        }\n      });\n    };\n\n    const handleMouseUp = (event: MouseEvent) => {\n      const mouseButton = `Mouse${event.button}`;\n      actionKeys.forEach((action) => {\n        if (keyMapping[action]?.includes(mouseButton)) {\n          actionInputRef.current[action] = false;\n        }\n      });\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n      document.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, []);\n\n  const reset = useCallback(() => {\n    setPosition(new THREE.Vector3(0, 0, 0));\n    setRotation(new THREE.Quaternion());\n    setVelocity(new THREE.Vector3(0, 0, 0));\n  }, [setPosition, setRotation, setVelocity]);\n\n  // Get addEffect action from the store\n  const addEffect = useEffectStore((state) => state.addEffect);\n\n  // Callback for Player to request a cast\n  const spawnEffect = useCallback(\n    async (type: string, config?: { [key: string]: any }) => {\n      if (!account) return;\n\n      // Add effect locally via store\n      addEffect(type, account, config);\n    },\n    [account, addEffect],\n  );\n\n  useFrame(() => {\n    const playerRigidBody = rigidBodyPlayerRef.current;\n    if (!playerRigidBody) return;\n\n    // Shooting Logic\n    const attack = actionInputRef.current[ActionType.ATTACK];\n    const now = Date.now();\n    const canAttack = attack && now > canShootTimestamp.current;\n    if (canAttack) {\n      canShootTimestamp.current = now + SHOOT_COOLDOWN;\n\n      const originPosition = playerRigidBody.translation();\n      const originRotation = playerRigidBody.rotation();\n      const position = new THREE.Vector3(originPosition.x, originPosition.y, originPosition.z);\n      const rotation = new THREE.Quaternion(originRotation.x, originRotation.y, originRotation.z, originRotation.w);\n\n      const forward = new THREE.Vector3(0, 0, -1);\n      forward.applyQuaternion(rotation);\n      forward.normalize();\n\n      const bulletSpeed = 200;\n\n      const offset = forward.clone().multiplyScalar(2).add(new THREE.Vector3(0, 0.5, 0));\n      const startPosition = position.clone().add(offset);\n      spawnEffect(\n        EffectType.BULLET,\n        createBulletEffectConfig({ startPosition, direction: forward, speed: bulletSpeed, duration: 500, scale: 3, flashDuration: 30, color: 'black' }),\n      );\n    }\n  });\n\n  // Handle reset action input processing on every frame\n  // Prevents reset from being called continuously while key is held down\n  useFrame(() => {\n    if (!rigidBodyPlayerRef.current) return;\n\n    // Reset key input handling - prevents continuous execution\n    // Compare with previous frame state to execute only once even when key is held down\n    const inputReset = actionInputRef.current[ActionType.RESET];\n    if (inputReset && !lastFramePressedReset.current) {\n      // Execute reset only when key is pressed in current frame but not in previous frame\n      reset();\n    }\n\n    // Store current frame's key input state for next frame comparison\n    lastFramePressedReset.current = inputReset;\n  });\n\n  if (!account) return null;\n\n  const hitBodySizeVector = new THREE.Vector3(AIRCRAFT_BODY_LENGTH / 3, AIRCRAFT_BODY_LENGTH / 5, AIRCRAFT_BODY_LENGTH);\n  const colliderOffsetY = hitBodySizeVector.y / 2;\n\n  /** handleTriggerEnter: Called when the player intersects or collides with another object.\n   * - Handles when entering a specific area or colliding with another object\n   */\n  const handleTriggerEnter = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when entering a specific area or colliding with another object\n    }\n  };\n\n  /** handleTriggerExit: Called when the player exits an intersection or ends a collision with another object.\n   * - Handles when exiting a specific area or when collision with another object ends\n   */\n  const handleTriggerExit = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when exiting a specific area or when collision with another object ends\n    }\n  };\n\n  return (\n    <RigidBodyPlayer\n      ref={rigidBodyPlayerRef}\n      userData={{ account, type: RigidBodyObjectType.LOCAL_PLAYER }}\n      onTriggerEnter={handleTriggerEnter}\n      onTriggerExit={handleTriggerExit}\n      autoCreateCollider={false}\n      offsetY={0}\n      type=\"kinematicPosition\"\n      sensor={true}\n      enabledRotations={[false, false, false]}\n      gravityScale={0}\n    >\n      <CuboidCollider\n        position={[0, colliderOffsetY, 0]}\n        args={[hitBodySizeVector.x / 2, hitBodySizeVector.y / 2, hitBodySizeVector.z / 2]}\n        activeCollisionTypes={ActiveCollisionTypes.DEFAULT | ActiveCollisionTypes.KINEMATIC_KINEMATIC | ActiveCollisionTypes.KINEMATIC_FIXED}\n      />\n\n      <Aircraft bodyLength={AIRCRAFT_BODY_LENGTH} localPlayer={true} />\n    </RigidBodyPlayer>\n  );\n};\n\nexport default Player;\n",
    isBinary: false,
  },
  'src/components/r3f/effects/Explosion.tsx': {
    type: 'file',
    content:
      "import * as THREE from 'three';\nimport React, { useRef, useMemo, useState } from 'react';\nimport { useFrame } from '@react-three/fiber';\n\nconst DEFAULT_SCALE = 1;\n\ninterface ExplosionProps {\n  config: { [key: string]: any };\n  onComplete?: () => void;\n}\n\n// Utility to convert Vector3 array to THREE.Vector3 (needed for rendering)\nconst arrayToVec = (arr?: [number, number, number]): THREE.Vector3 => {\n  if (!arr) {\n    console.error('Missing required config properties');\n    return new THREE.Vector3();\n  }\n  return new THREE.Vector3(arr[0], arr[1], arr[2]);\n};\n\nconst parseConfig = (config: { [key: string]: any }) => {\n  return {\n    position: arrayToVec(config.position),\n    scale: config.scale || DEFAULT_SCALE,\n  };\n};\n\nfunction makeParticles(color: string, speed: number) {\n  // data: [position Vector3, movement direction Vector3]\n  const data = new Array(20).fill(null).map(() => {\n    const position = new THREE.Vector3();\n    const direction = new THREE.Vector3(-1 + Math.random() * 2, -1 + Math.random() * 2, -1 + Math.random() * 2).normalize().multiplyScalar(speed);\n    return [position, direction] as [THREE.Vector3, THREE.Vector3];\n  });\n\n  return { color, data };\n}\n\n// \"Explosion/smoke\" effect appearing at the collision point\nconst Explosion: React.FC<ExplosionProps> = ({ config, onComplete }) => {\n  const groupRef = useRef<THREE.Group>(null);\n  // Reusable dummy object\n  const dummy = useMemo(() => new THREE.Object3D(), []);\n\n  // Explosion particle array (2 types with different color/speed)\n  const [particleGroups] = useState(() => [makeParticles('white', 0.1), makeParticles('grey', 0.1)]);\n\n  // \"Total lifespan\" of the explosion/smoke (in ms)\n  const totalDuration = 500;\n  const startTime = useRef(performance.now());\n\n  const { position, scale } = parseConfig(config);\n\n  useFrame(() => {\n    const elapsed = performance.now() - startTime.current;\n    const fadeOut = elapsed / totalDuration; // 0 ~ 1\n\n    // Iterate particle groups\n    particleGroups.forEach((pg, groupIndex) => {\n      // instancedMesh reference\n      const mesh = groupRef.current?.children[groupIndex] as THREE.InstancedMesh;\n      if (!mesh) return;\n\n      // Move individual particles\n      pg.data.forEach(([pos, dir], i) => {\n        // Continuously adding dir results in spreading out\n        pos.add(dir);\n        dummy.position.copy(pos);\n        dummy.updateMatrix();\n        mesh.setMatrixAt(i, dummy.matrix);\n      });\n\n      // Reduce material opacity\n      if (mesh.material instanceof THREE.MeshBasicMaterial) {\n        mesh.material.opacity = Math.max(1 - fadeOut, 0);\n      }\n\n      mesh.instanceMatrix.needsUpdate = true;\n    });\n\n    // Trigger removal from parent when lifespan ends\n    if (elapsed > totalDuration) {\n      onComplete?.();\n    }\n  });\n\n  if (!position || !scale) {\n    console.error('[Explosion] Missing required config properties');\n    onComplete?.();\n    return null;\n  }\n\n  return (\n    <group ref={groupRef} position={position} scale={scale}>\n      {particleGroups.map((pg, index) => (\n        <instancedMesh\n          key={index}\n          args={[undefined, undefined, pg.data.length]}\n          frustumCulled={false} // Display even if outside camera frustum\n        >\n          <dodecahedronGeometry args={[1, 0]} />\n          <meshBasicMaterial\n            color={pg.color}\n            transparent\n            opacity={1}\n            depthWrite={false} // Make it look like smoke\n          />\n        </instancedMesh>\n      ))}\n    </group>\n  );\n};\n\nexport default Explosion;\n",
    isBinary: false,
  },
  'src/components/r3f/effects/MuzzleFlash.tsx': {
    type: 'file',
    content:
      "import React, { useState, useEffect, useMemo } from 'react';\nimport * as THREE from 'three';\nimport { useFrame } from '@react-three/fiber';\n\n// --- Muzzle Flash Configuration ---\nconst FLASH_PETAL_COUNT = 5; // Number of flame petals\nconst FLASH_PETAL_LENGTH = 0.4; // Length of each petal\nconst FLASH_PETAL_BASE_RADIUS = 0.03; // Base radius of each petal\nconst FLASH_RADIAL_SEGMENTS = 4; // Number of radial segments for each cone\nconst FLASH_TILT_ANGLE = Math.PI / 4; // Tilt angle of flame petals (45 degrees)\nconst FLASH_INNER_GLOW_SIZE = 0.08; // Size of the center glow\nconst FLASH_COLOR = '#FFA500'; // Orange color\nconst FLASH_INNER_COLOR = '#FFFF55'; // Brighter yellow for center\nconst DEFAULT_DURATION = 100; // Default duration\n// ------------------------\n\ninterface MuzzleFlashProps {\n  config: { [key: string]: any };\n  onComplete?: () => void;\n}\n\n// Utility to convert Vector3 array to THREE.Vector3 (needed for rendering)\nconst arrayToVec = (arr?: [number, number, number]): THREE.Vector3 => {\n  if (!arr) {\n    console.error('Missing required config properties');\n    return new THREE.Vector3();\n  }\n  return new THREE.Vector3(arr[0], arr[1], arr[2]);\n};\n\nconst parseConfig = (config: { [key: string]: any }) => {\n  return {\n    position: arrayToVec(config.position as [number, number, number]),\n    direction: arrayToVec(config.direction as [number, number, number]),\n    duration: (config.duration as number) || DEFAULT_DURATION,\n  };\n};\n\nconst MuzzleFlash: React.FC<MuzzleFlashProps> = ({ config, onComplete }) => {\n  const { position, direction, duration } = parseConfig(config);\n\n  const [visible, setVisible] = useState(true);\n  const startTime = useMemo(() => Date.now(), []); // Record creation time (for animation)\n\n  // Calculate rotation based on direction\n  const flashQuaternion = useMemo(() => {\n    const quaternion = new THREE.Quaternion();\n    const normalizedDirection = direction.clone().normalize();\n    // Rotate the group whose default direction is Z-axis (0,0,1) to the firing direction\n    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), normalizedDirection);\n    return quaternion;\n  }, [direction]);\n\n  // --- Muzzle Flash Related Memos ---\n  const petalGeometry = useMemo(() => new THREE.ConeGeometry(FLASH_PETAL_BASE_RADIUS, FLASH_PETAL_LENGTH, FLASH_RADIAL_SEGMENTS), []);\n  const petalMaterial = useMemo(\n    () =>\n      new THREE.MeshBasicMaterial({\n        color: FLASH_COLOR,\n        blending: THREE.AdditiveBlending,\n        transparent: true,\n        opacity: 0.8,\n        depthWrite: false,\n      }),\n    [],\n  );\n  const innerGlowGeometry = useMemo(() => new THREE.SphereGeometry(FLASH_INNER_GLOW_SIZE, 16, 8), []);\n  const innerGlowMaterial = useMemo(\n    () =>\n      new THREE.MeshBasicMaterial({\n        color: FLASH_INNER_COLOR,\n        blending: THREE.AdditiveBlending,\n        transparent: true,\n        opacity: 1.0,\n        depthWrite: false,\n      }),\n    [],\n  );\n  // --- End of Muzzle Flash Related Memos ---\n\n  // Auto-destruction timer\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setVisible(false);\n      if (onComplete) onComplete();\n    }, duration);\n\n    return () => clearTimeout(timer);\n  }, [duration, onComplete]); // Timer reset when id or onComplete function changes\n\n  // Opacity animation\n  useFrame(() => {\n    if (!visible) return;\n    const elapsed = Date.now() - startTime;\n    const progress = Math.min(elapsed / duration, 1);\n    const opacity = 1.0 - progress; // Opacity decreases over time\n\n    petalMaterial.opacity = opacity * 0.8;\n    innerGlowMaterial.opacity = opacity;\n  });\n\n  if (!position || !direction || !duration) {\n    console.error('[MuzzleFlash] Missing required config properties');\n    return null;\n  }\n\n  if (!visible) return null; // Don't render if not visible\n\n  return (\n    <group position={position} quaternion={flashQuaternion}>\n      {/* Center glow */}\n      <mesh geometry={innerGlowGeometry} material={innerGlowMaterial} />\n\n      {/* Flame petals (using ConeGeometry with tilt applied) */}\n      {Array.from({ length: FLASH_PETAL_COUNT }).map((_, i) => {\n        const radialAngle = (i / FLASH_PETAL_COUNT) * Math.PI * 2;\n        return (\n          <group key={i} rotation={[0, 0, radialAngle]}>\n            <group rotation={[FLASH_TILT_ANGLE, 0, 0]}>\n              <mesh geometry={petalGeometry} material={petalMaterial} position={[0, FLASH_PETAL_LENGTH / 2, 0]} />\n            </group>\n          </group>\n        );\n      })}\n    </group>\n  );\n};\n\nexport default MuzzleFlash;\n",
    isBinary: false,
  },
  'src/components/r3f/effects/Bullet.tsx': {
    type: 'file',
    content:
      "import * as THREE from 'three';\nimport React, { useRef, useEffect, useMemo, useCallback } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { RapierRigidBody, useRapier, CollisionPayload } from '@react-three/rapier';\nimport { ActiveCollisionTypes, InteractionGroups } from '@dimforge/rapier3d-compat';\nimport { RigidBodyObject, RigidBodyObjectRef } from 'vibe-starter-3d';\nimport { RigidBodyObjectType } from '../../../constants/rigidBodyObjectType';\n\nconst DEFAULT_SIZE = new THREE.Vector3(0.5, 0.5, 1);\n\nexport interface BulletProps {\n  startPosition: THREE.Vector3;\n  direction: THREE.Vector3;\n  color?: THREE.ColorRepresentation | undefined;\n  scale?: number;\n  speed: number;\n  duration: number;\n  collisionGroups?: InteractionGroups;\n  owner?: RapierRigidBody;\n  onHit?: (payload: CollisionPayload) => void;\n  onComplete?: () => void;\n}\n\nconst Bullet: React.FC<BulletProps> = ({\n  startPosition,\n  direction,\n  color = 'orange',\n  scale = 1,\n  speed,\n  duration,\n  collisionGroups,\n  owner,\n  onHit,\n  onComplete,\n}) => {\n  const active = useRef(true);\n  const rigidBodyRef = useRef<RigidBodyObjectRef>(null);\n  const freezed = useRef(false);\n  const framesSinceFreezed = useRef(0);\n  const { rapier, world } = useRapier();\n  const normalizedDirection = direction.clone().normalize();\n  const bulletGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.3);\n  const bulletMaterial = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 2 });\n  const onCompleteRef = useRef(onComplete);\n  const startTime = useRef(Date.now());\n\n  // Bullet removal function\n  const removeBullet = useCallback(() => {\n    if (!active.current) return;\n\n    active.current = false;\n    onCompleteRef.current?.();\n  }, [active]);\n\n  useEffect(() => {\n    onCompleteRef.current = onComplete;\n  }, [onComplete]);\n\n  useFrame((_, delta) => {\n    if (!active.current) return;\n\n    const elapsed = Date.now() - startTime.current;\n    if (elapsed > duration) {\n      removeBullet();\n      return;\n    }\n\n    // skip update if bullet is freezed\n    if (freezed.current) {\n      framesSinceFreezed.current++;\n\n      // If onTriggerEnter hasn't been called after 3 frames, unfreeze and continue checking\n      if (framesSinceFreezed.current > 3) {\n        console.warn('Bullet frozen too long, unfreezing to continue collision check');\n        freezed.current = false;\n        framesSinceFreezed.current = 0;\n      }\n      return;\n    }\n\n    const rigidBody = rigidBodyRef.current;\n    if (!rigidBody || rigidBody.numColliders() === 0) return;\n\n    const frameTravelDistance = speed * delta;\n    const originVec = rigidBody.translation();\n    const ray = new rapier.Ray(originVec, normalizedDirection);\n    const bulletOwnCollider = rigidBody.collider(0);\n\n    const hit = world.castRay(\n      ray,\n      frameTravelDistance,\n      true, // solid\n      undefined, // queryFlags\n      collisionGroups, // groups\n      bulletOwnCollider, // Exclude bullet's own collider\n      owner, // Exclude the owner (firer)\n    );\n\n    if (hit) {\n      const hitPoint = ray.pointAt(hit.timeOfImpact);\n      const hitPointVec3 = new THREE.Vector3(hitPoint.x, hitPoint.y, hitPoint.z);\n\n      freezed.current = true;\n      framesSinceFreezed.current = 0;\n      rigidBody.setTranslation(hitPointVec3, true);\n      return;\n    } else {\n      // No hit, continue with velocity based movement (handled by RigidBody component)\n      const curVec3 = new THREE.Vector3(originVec.x, originVec.y, originVec.z);\n      const nextPosition = curVec3.addScaledVector(normalizedDirection, frameTravelDistance);\n      rigidBody.setTranslation(nextPosition, true);\n    }\n  });\n\n  // Calculate rotation quaternion in the firing direction\n  const bulletQuaternion = useMemo(() => {\n    const quaternion = new THREE.Quaternion();\n    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), normalizedDirection);\n    return quaternion;\n  }, [normalizedDirection]);\n\n  // Calculate rotation & position for RigidBody\n  const bulletRotation = useMemo(() => {\n    return new THREE.Euler().setFromQuaternion(bulletQuaternion);\n  }, [bulletQuaternion]);\n\n  // Don't render if the bullet has been removed\n  if (!active) return null;\n\n  return (\n    <RigidBodyObject\n      ref={rigidBodyRef}\n      userData={{\n        type: RigidBodyObjectType.BULLET,\n      }}\n      type=\"kinematicVelocity\"\n      position={[startPosition.x, startPosition.y, startPosition.z]}\n      rotation={bulletRotation}\n      sensor={true}\n      scale={scale}\n      colliders={'cuboid'}\n      collisionGroups={collisionGroups ?? 0xffffffff}\n      activeCollisionTypes={ActiveCollisionTypes.ALL}\n      onTriggerEnter={(payload: CollisionPayload) => {\n        freezed.current = false;\n        framesSinceFreezed.current = 0;\n        if (owner && owner.handle === payload.other.rigidBody.handle) {\n          return;\n        }\n\n        onHit?.(payload);\n        removeBullet();\n      }}\n      name=\"bullet\"\n    >\n      <mesh geometry={bulletGeometry} material={bulletMaterial} scale={DEFAULT_SIZE} />\n    </RigidBodyObject>\n  );\n};\n\nexport default Bullet;\n",
    isBinary: false,
  },
  'src/components/r3f/effects/BulletEffectController.tsx': {
    type: 'file',
    content:
      "import * as THREE from 'three';\nimport Bullet from './Bullet';\nimport MuzzleFlash from './MuzzleFlash';\nimport { InteractionGroups, RigidBody } from '@dimforge/rapier3d-compat';\nimport { CollisionPayload } from '@react-three/rapier';\n\nconst DEFAULT_SPEED = 100;\nconst DEFAULT_DURATION = 1000;\nconst DEFAULT_SCALE = 1;\nconst DEFAULT_FLASH_DURATION = 100;\n\ninterface BulletEffectControllerProps {\n  config: { [key: string]: any };\n  collisionGroups?: InteractionGroups;\n  owner?: RigidBody;\n  onHit?: (payload: CollisionPayload) => void;\n  onComplete?: () => void;\n}\n\nexport interface BulletEffectConfig {\n  startPosition: THREE.Vector3;\n  direction: THREE.Vector3;\n  speed?: number;\n  duration?: number;\n  scale?: number;\n  color?: string;\n  flashDuration?: number;\n}\n\nconst parseConfig = (config: { [key: string]: any }) => {\n  return {\n    startPosition: new THREE.Vector3(...config.startPosition),\n    direction: new THREE.Vector3(...config.direction),\n    speed: (config.speed as number) || DEFAULT_SPEED,\n    duration: (config.duration as number) || DEFAULT_DURATION,\n    scale: (config.scale as number) || DEFAULT_SCALE,\n    color: config.color,\n    flashDuration: config.flashDuration === undefined ? DEFAULT_FLASH_DURATION : config.flashDuration,\n  };\n};\n\nconst BulletEffectController: React.FC<BulletEffectControllerProps> = ({ config, collisionGroups, owner, onHit, onComplete }) => {\n  const { startPosition, direction, speed, duration, scale, flashDuration, color } = parseConfig(config);\n  if (!startPosition || !direction || !speed || !duration) {\n    console.error('[BulletEffectController] Missing required config properties');\n    onComplete?.();\n    return null;\n  }\n\n  const calcStartPosition = startPosition.clone().add(direction.clone().multiplyScalar(1));\n\n  return (\n    <>\n      <Bullet\n        startPosition={calcStartPosition}\n        direction={direction}\n        color={color}\n        scale={scale}\n        speed={speed}\n        duration={duration}\n        collisionGroups={collisionGroups}\n        owner={owner}\n        onHit={onHit}\n        onComplete={onComplete}\n      />\n      {flashDuration > 0 && (\n        <MuzzleFlash\n          config={{\n            position: calcStartPosition.toArray(),\n            direction: direction.toArray(),\n            duration: flashDuration,\n          }}\n        />\n      )}\n    </>\n  );\n};\n\nexport default BulletEffectController;\n",
    isBinary: false,
  },
} as FileMap;

export const TEMPLATE_3D_BASIC_FIRSTPERSONVIEW = {
  '.gitignore': {
    type: 'file',
    content:
      '# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n',
    isBinary: false,
  },
  'eslint.config.js': {
    type: 'file',
    content:
      "import js from '@eslint/js'\nimport globals from 'globals'\nimport reactHooks from 'eslint-plugin-react-hooks'\nimport reactRefresh from 'eslint-plugin-react-refresh'\nimport tseslint from 'typescript-eslint'\n\nexport default tseslint.config(\n  { ignores: ['dist'] },\n  {\n    extends: [js.configs.recommended, ...tseslint.configs.recommended],\n    files: ['**/*.{ts,tsx}'],\n    languageOptions: {\n      ecmaVersion: 2020,\n      globals: globals.browser,\n    },\n    plugins: {\n      'react-hooks': reactHooks,\n      'react-refresh': reactRefresh,\n    },\n    rules: {\n      ...reactHooks.configs.recommended.rules,\n      'react-refresh/only-export-components': [\n        'warn',\n        { allowConstantExport: true },\n      ],\n    },\n  },\n)\n",
    isBinary: false,
  },
  'index.html': {
    type: 'file',
    content:
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + React + TS</title>\n    <style>\n      body {\n        margin: 0;\n        padding: 0;\n        font-family: Arial, sans-serif;\n      }\n      .loading-container {\n        position: fixed;\n        inset: 0;\n        z-index: 50;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background-color: black;\n        color: white;\n      }\n      .loading-title {\n        font-size: 1.5rem;\n        font-weight: bold;\n        margin-bottom: 1rem;\n      }\n      .spinner {\n        width: 30px;\n        height: 30px;\n        border: 3px solid rgba(255, 255, 255, 0.3);\n        border-radius: 50%;\n        border-top-color: white;\n        animation: spin 1s ease-in-out infinite;\n      }\n      @keyframes spin {\n        to {\n          transform: rotate(360deg);\n        }\n      }\n    </style>\n    <script>\n      (function () {\n        function reportGameSize() {\n          const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n\n          const width = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n\n          window.parent.postMessage(\n            {\n              type: \'GAME_SIZE_RESPONSE\',\n              height: height,\n              width: width,\n            },\n            \'*\',\n          );\n        }\n\n        window.addEventListener(\'load\', reportGameSize);\n\n        window.addEventListener(\'resize\', reportGameSize);\n\n        window.addEventListener(\'message\', function (event) {\n          if (event.data && event.data.type === \'REQUEST_GAME_SIZE\') {\n            reportGameSize();\n          }\n        });\n      })();\n    </script>\n  </head>\n  <body>\n    <div id="root">\n      <div class="loading-container">\n        <h2 class="loading-title">Loading</h2>\n        <div class="spinner"></div>\n      </div>\n    </div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    isBinary: false,
  },
  'tsconfig.app.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",\n    "target": "ES2020",\n    "useDefineForClassFields": true,\n    "lib": ["ES2020", "DOM", "DOM.Iterable"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n    "jsx": "react-jsx",\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["src"]\n}\n',
    isBinary: false,
  },
  'README.md': {
    type: 'file',
    content:
      "# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n",
    isBinary: false,
  },
  'tsconfig.node.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",\n    "target": "ES2022",\n    "lib": ["ES2023"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["vite.config.ts"]\n}\n',
    isBinary: false,
  },
  'postcss.config.js': {
    type: 'file',
    content: 'export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n',
    isBinary: false,
  },
  'vite.config.ts.js': {
    type: 'file',
    content:
      '// vite.config.ts\nimport { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\nvar vite_config_default = defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"]\n  },\n  base: "./",\n  build: {\n    outDir: "dist"\n  }\n});\nexport {\n  vite_config_default as default\n};\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsidml0ZS5jb25maWcudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IGRlZmluZUNvbmZpZyB9IGZyb20gXCJ2aXRlXCI7XG5pbXBvcnQgcmVhY3QgZnJvbSBcIkB2aXRlanMvcGx1Z2luLXJlYWN0XCI7XG5cbi8vIGh0dHBzOi8vdml0ZWpzLmRldi9jb25maWcvXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVDb25maWcoe1xuICBwbHVnaW5zOiBbcmVhY3QoKV0sXG4gIG9wdGltaXplRGVwczoge1xuICAgIGV4Y2x1ZGU6IFtcImx1Y2lkZS1yZWFjdFwiXSxcbiAgfSxcbiAgYmFzZTogXCIuL1wiLFxuICBidWlsZDoge1xuICAgIG91dERpcjogXCJkaXN0XCIsXG4gIH0sXG59KTtcbiJdLAogICJtYXBwaW5ncyI6ICI7QUFBQTtBQUNBO0FBR0EsSUFBTyxzQkFBUSxhQUFhO0FBQUEsRUFDMUIsU0FBUyxDQUFDO0FBQUEsRUFDVixjQUFjO0FBQUEsSUFDWixTQUFTLENBQUM7QUFBQTtBQUFBLEVBRVosTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLElBQ0wsUUFBUTtBQUFBO0FBQUE7IiwKICAibmFtZXMiOiBbXQp9Cg==\n',
    isBinary: false,
  },
  'tailwind.config.js': {
    type: 'file',
    content:
      '/** @type {import(\'tailwindcss\').Config} */\nexport default {\n  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n',
    isBinary: false,
  },
  'PROJECT.md': {
    type: 'file',
    content:
      "# Basic 3D First Person View (FPV) - FPS\n\n## Project Summary\n\nThis project is a single-player First Person View (FPV) 3D FPS game built using Three.js and React Three Fiber.\n\n## Implementation Strategy\n\nThis project uses a **Three.js-based 3D approach** because:\n\n- It requires real-time 3D character animation and control\n- Three.js provides efficient 3D rendering in web browsers\n- React Three Fiber simplifies integration with React components\n- The vibe-starter-3d library provides essential character rendering and animation tools\n\nKey technologies:\n\n- Three.js for 3D rendering\n- React Three Fiber for React integration\n- @react-three/rapier for physics simulation\n- @react-three/drei for useful Three.js helpers\n- vibe-starter-3d for character rendering and animation\n- Tailwind CSS for styling\n\n## Implemented Features\n\n- Keyboard-controlled character movement (WASD/Arrow keys)\n- Attack by clicking the left mouse button\n- First person view camera that follows the character\n- Physics-based character movement with collision detection\n- 3D environment with floor\n- Pointer lock for immersive control\n- FPS-style crosshair overlay for targeting\n- Rigid body object type system for physics collision detection\n- Map physics system initialization with loading screen\n- Automatic physics readiness detection through raycasting\n\n## File Structure Overview\n\n### `src/main.tsx`\n\n- Entry point for the application.\n- Sets up React rendering and mounts the `App` component.\n\n### `src/App.tsx`\n\n- Main application component.\n- Configures the overall layout and includes the `GameScene` component.\n\n### `src/App.css`\n\n- Defines the main styles for the `App` component and its child UI elements.\n\n### `src/index.css`\n\n- Defines global base styles, Tailwind CSS directives, fonts, etc., applied throughout the application.\n\n### `src/assets.json`\n\n- File for managing asset metadata. (Currently empty)\n\n### `src/constants/`\n\n- Directory defining constant values used throughout the application.\n  - **`character.ts`**: Defines character-related settings (e.g., movement speed, jump height).\n  - **`controls.ts`**: Defines settings that map keyboard inputs (WASD, arrow keys, etc.) to corresponding actions (movement, firing, etc.).\n  - **`rigidBodyObjectType.ts`**: Defines constant values for different types of rigid body objects in the physics simulation (e.g., LOCAL_PLAYER, ENEMY, WALL, BULLET, FLOOR, etc.).\n\n### `src/components/`\n\n- Directory managing React components categorized by function.\n\n  - **`r3f/`**: Contains 3D components related to React Three Fiber.\n\n    - **`EffectContainer.tsx`**: Groups and manages various visual effect components like bullets and muzzle flash.\n    - **`Experience.tsx`**: Main component responsible for the primary 3D scene configuration. Sets up ambient lighting, environment preset (sunset), and includes the `Player` and `Floor` components.\n    - **`Floor.tsx`**: Defines and visually represents the ground plane in the 3D space. Has physical properties.\n    - **`GameSceneCanvas.tsx`**: React Three Fiber Canvas component that renders the 3D game world with physics simulation and controller setup.\n    - **`MapPhysicsReadyChecker.tsx`**: Component that checks if the map physics system is ready by performing raycasting from above downward to detect map geometry and ensures physics interactions are properly initialized before gameplay begins. Performs checks every frame until valid map geometry is detected, with a timeout after 180 frames to prevent infinite checking. Excludes Capsule shapes (likely characters/objects) and sensor colliders from the inspection.\n    - **`Player.tsx`**: Component defining the player character using the `RigidBodyPlayer` component from vibe-starter-3d. Handles player state management, animation configurations, shooting mechanics, and object interactions through `onTriggerEnter` and `onTriggerExit` events. The character is set to invisible for FPS view, and includes comprehensive collision detection with other rigid body objects using the RigidBodyObjectType system.\n    - **`effects/`**: Sub-directory containing components related to visual effects.\n      - **`Bullet.tsx`**: Component defining the visual representation and behavior of bullets fired from the player.\n      - **`BulletEffectController.tsx`**: Manages the entire bullet effect system, including creation, state updates, and recycling (Object Pooling).\n      - **`Explosion.tsx`**: Component that creates and manages explosion visual effects.\n      - **`MuzzleFlash.tsx`**: Component that generates and manages the flash effect occurring at the muzzle when firing a gun.\n\n  - **`scene/`**: Contains components related to scene setup.\n\n    - **`GameScene.tsx`**: Main game scene component that serves as a layout container arranging the game UI and 3D Canvas. Contains critical performance warnings and guidelines to prevent re-rendering issues. Includes the `GameSceneCanvas` and `GameSceneUI` components in a proper layered structure where the Canvas renders the 3D world and UI components render as overlays.\n\n  - **`ui/`**: Contains UI components for the game interface.\n    - **`Crosshair.tsx`**: Renders a centered crosshair overlay for FPS-style targeting with white lines and black outline for better visibility across different backgrounds.\n    - **`GameSceneUI.tsx`**: Component that manages UI overlays for the game scene.\n    - **`LoadingScreen.tsx`**: Loading screen component displayed during game loading.\n    - **`InputController.tsx`**: Manages all input handling including keyboard, mouse, and touch controls with virtual joystick support for mobile devices and action buttons for FPS-style attack controls and movement.\n\n### `src/stores/`\n\n- Directory containing Zustand stores for application state management.\n  - **`effectStore.ts`**: Store that manages the state of visual effects like bullets (e.g., creation, active/inactive).\n  - **`gameStore.ts`**: Store that manages the overall game state. Tracks and controls the readiness state of the map physics system (`isMapPhysicsReady`). This state is used to determine physics simulation pause/resume and loading screen display.\n  - **`localPlayerStore.ts`**: Store that manages the local player's state, such as position tracking.\n  - **`multiPlayerStore.ts`**: Store that manages multiple connected players' rigid body references for multiplayer functionality, including registration, unregistration, and retrieval of player references.\n- **`playerActionStore.ts`**: Store that manages player action states including combat actions (punch, kick, meleeAttack, cast) with support for setting, getting, and resetting action states.\n\n### `src/types/`\n\n- Directory containing TypeScript type definitions.\n  - **`effect.ts`**: Defines types related to visual effects (Effect).\n  - **`index.ts`**: Exports types from within the `types` directory.\n\n### `src/utils/`\n\n- Directory containing utility functions used throughout the application.\n  - **`effectUtils.ts`**: Provides utility functions for creating effect configurations, such as bullet and explosion effects.\n",
    isBinary: false,
  },
  'vite.config.ts': {
    type: 'file',
    content:
      'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"],\n  },\n  base: "./",\n  build: {\n    outDir: "dist",\n  },\n});\n',
    isBinary: false,
  },
  'server.js': {
    type: 'file',
    content: 'class Server {}\n',
    isBinary: false,
  },
  'package.json': {
    type: 'file',
    content:
      '{\n  "name": "firstpersonview",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "lint": "eslint .",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@agent8/gameserver": "^1.5.3",\n    "vibe-starter-3d": "^0.8.18",\n    "@react-three/drei": "9.122.0",\n    "@react-three/fiber": "8.18.0",\n    "@react-three/postprocessing": "2.19.1",\n    "@react-three/rapier": "1.5.0",\n    "@dimforge/rapier3d-compat": "0.14.0",\n    "nipplejs": "0.10.2",\n    "lucide-react": "0.482.0",\n    "react": "18.3.1",\n    "react-dom": "18.3.1",\n    "three": "0.174.0",\n    "three-stdlib": "2.35.14",\n    "zustand": "5.0.3"\n  },\n  "devDependencies": {\n    "@eslint/js": "^9.23.0",\n    "@types/react": "^18.3.20",\n    "@types/react-dom": "^18.3.5",\n    "@types/three": "^0.174.0",\n    "@vitejs/plugin-react": "^4.3.4",\n    "autoprefixer": "^10.4.21",\n    "eslint": "^9.23.0",\n    "eslint-plugin-react-hooks": "^5.2.0",\n    "eslint-plugin-react-refresh": "^0.4.19",\n    "globals": "^16.0.0",\n    "tailwindcss": "^3.4.17",\n    "typescript": "~5.8.2",\n    "typescript-eslint": "^8.28.0",\n    "vite": "^6.2.3"\n  }\n}\n',
    isBinary: false,
  },
  'docs/project-3d-rules.md': {
    type: 'file',
    content:
      "# 3D Project Development Rules\n\n## Guideline for Using `RigidBodyObject`\n\nWhen implementing physics interactions, it is mandatory to use the `RigidBodyObject` component from the `vibe-starter-3d` package instead of the standard `RigidBody` from `@react-three/rapier`.\n\nThe primary reason for this is to simplify event handling for collisions and intersections. Using the standard `RigidBody` component requires managing a complex set of events (`onCollisionEnter`, `onCollisionExit`, `onIntersectionEnter`, `onIntersectionExit`).\n\nIn contrast, `RigidBodyObject` abstracts this complexity. It allows you to handle all physics-based interactions uniformly through just two simple trigger events: `onTriggerEnter` and `onTriggerExit`. This makes the interaction logic significantly cleaner and easier to manage.\n\n## Canvas Component Structure Rules\n\n**Core Requirement:** Components that render HTML tags (e.g., `<div>`, `<button>`) must NEVER be placed inside React Three Fiber's `<Canvas>` component.\n\n**Reasoning:**\nThis is a core architectural rule. Placing standard HTML inside the `<Canvas>` WebGL context will cause rendering errors.\n\n**Implementation Guidelines:**\n\n- **UI Components:** Components using HTML tags belong in the `src/components/ui/` directory. They must be rendered as an overlay, outside the `<Canvas>`.\n- **3D Components:** Only Three.js-related components, located in `src/components/r3f/`, should be placed inside the `<Canvas>`.\n\n**Correct Structure Example:**\n\n```tsx\n// ‚úÖ Correct approach\n<div>\n  {/* The 3D scene is rendered inside the Canvas */}\n  <Canvas>\n    <Player />\n    <Floor />\n  </Canvas>\n\n  {/* UI components are rendered as overlays outside the Canvas */}\n  <Crosshair />\n  <LoadingScreen />\n</div>\n```\n\n**Incorrect Structure Example:**\n\n```tsx\n// ‚ùå Incorrect approach\n<Canvas>\n  <Player />\n  {/* This is forbidden, as Crosshair renders HTML */}\n  <Crosshair />\n</Canvas>\n```\n",
    isBinary: false,
  },
  'tsconfig.json': {
    type: 'file',
    content:
      '{\n  "files": [],\n  "references": [\n    { "path": "./tsconfig.app.json" },\n    { "path": "./tsconfig.node.json" }\n  ]\n}\n',
    isBinary: false,
  },
  'src/index.css': {
    type: 'file',
    content: '@tailwind base;\n@tailwind components;\n@tailwind utilities;\n',
    isBinary: false,
  },
  'src/main.tsx': {
    type: 'file',
    content:
      "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport './index.css';\nimport App from './App.tsx';\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n",
    isBinary: false,
  },
  'src/App.css': {
    type: 'file',
    content: '#root {\n  margin: 0 auto;\n  text-align: center;\n}\n',
    isBinary: false,
  },
  'src/App.tsx': {
    type: 'file',
    content:
      "import React from 'react';\nimport './App.css';\nimport GameScene from './components/scene/GameScene.tsx';\n\nconst App: React.FC = () => {\n  return (\n    <div style={{ width: '100vw', height: '100vh' }}>\n      <GameScene />\n    </div>\n  );\n};\n\nexport default App;\n",
    isBinary: false,
  },
  'src/assets.json': {
    type: 'file',
    content:
      '{\n  "characters": {\n    "base-model": {\n      "url": "https://agent8-games.verse8.io/assets/3d/characters/realistic style/base-model.glb"\n    }\n  },\n  "animations": {\n    "idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle.glb",\n      "description": "Idle"\n    },\n    "idle-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle-00.glb",\n      "description": "Idle 00"\n    },\n    "idle-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle-01.glb",\n      "description": "Idle 01"\n    },\n    "rifle-idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/rifle-idle.glb",\n      "description": "Rifle idle"\n    },\n    "pistol-idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/pistol-idle.glb",\n      "description": "Pistol idle"\n    },\n    "walk": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/walk.glb",\n      "description": "Walk"\n    },\n    "run-medium": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/run-medium.glb",\n      "description": "Run Medium"\n    },\n    "run-fast": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/run-fast.glb",\n      "description": "Run Fast"\n    },\n    "rifle-run": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/rifle-run.glb",\n      "description": "Rifle Run"\n    },\n    "pistol-run": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/pistol-run.glb",\n      "description": "Pistol Run"\n    },\n    "jump": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/jump.glb",\n      "description": "Jump"\n    },\n    "swim": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/swim.glb",\n      "description": "Swim"\n    },\n    "punch-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/punch-00.glb",\n      "description": "Punch 00"\n    },\n    "punch-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/punch-01.glb",\n      "description": "Punch 01"\n    },\n    "kick-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-00.glb",\n      "description": "Kick 00"\n    },\n    "kick-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-01.glb",\n      "description": "Kick 01"\n    },\n    "kick-02": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-02.glb",\n      "description": "Kick 02"\n    },\n    "melee-attack": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/melee-attack.glb",\n      "description": "Melee Attack"\n    },\n    "cast": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/cast.glb",\n      "description": "Cast"\n    },\n    "dance-locking": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/dance-locking.glb",\n      "description": "Dance Locking"\n    },\n    "dance-wave": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/dance-wave.glb",\n      "description": "Dance Wave"\n    },\n    "death-backward": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/death-backward.glb",\n      "description": "Death Backward"\n    },\n    "death-foward": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/death-foward.glb",\n      "description": "Death Foward"\n    },\n    "hit-to-body": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/hit-to-body.glb",\n      "description": "Hit to Body"\n    }\n  }\n}\n',
    isBinary: false,
  },
  'src/constants/rigidBodyObjectType.ts': {
    type: 'file',
    content:
      "export const RigidBodyObjectType = {\n  /** Local Player */\n  LOCAL_PLAYER: 'LOCAL_PLAYER',\n  /** Enemy */\n  ENEMY: 'ENEMY',\n  /** Monster */\n  MONSTER: 'MONSTER',\n  /** Wall */\n  WALL: 'WALL',\n  /** Obstacle */\n  OBSTACLE: 'OBSTACLE',\n  /** Item */\n  ITEM: 'ITEM',\n  /** Bullet */\n  BULLET: 'BULLET',\n  /** Floor */\n  FLOOR: 'FLOOR',\n  /** Floating board */\n  PLOTTING_BOARD: 'PLOTTING_BOARD',\n} as const;\n",
    isBinary: false,
  },
  'src/constants/character.ts': {
    type: 'file',
    content:
      "import { AnimationType } from 'vibe-starter-3d';\n\nexport const CharacterState: { [key: string]: AnimationType } = {\n  /** IDLE ACTION */\n  IDLE: 'IDLE',\n  /** WALKING ACTION */\n  WALK: 'WALK',\n  /** RUNNING ACTION */\n  RUN: 'RUN',\n  /** JUMP ACTION */\n  JUMP: 'JUMP',\n  /** HIT ACTION */\n  HIT: 'HIT',\n  /** DIE ACTION */\n  DIE: 'DIE',\n};\n\nexport type CharacterState = (typeof CharacterState)[keyof typeof CharacterState];\n",
    isBinary: false,
  },
  'src/types/effect.ts': {
    type: 'file',
    content:
      "/**\n * Effect type enumeration\n */\nexport enum EffectType {\n  BULLET = 'BULLET',\n  EXPLOSION = 'EXPLOSION',\n}\n\n/**\n * Base effect data interface\n * Basic structure for all effect-related data\n */\nexport interface EffectData {\n  type: string;\n  config: { [key: string]: any };\n}\n\n/**\n * Active effect interface\n * Effect instance managed on the client\n */\nexport interface ActiveEffect {\n  key: number;\n  // Sender account\n  sender?: string;\n  effectData: EffectData;\n}\n\n/**\n * Effect message exchanged between server and client\n */\nexport interface EffectEventMessage {\n  sender: string;\n  effectData: EffectData;\n  timestamp: number;\n}\n",
    isBinary: false,
  },
  'src/types/index.ts': {
    type: 'file',
    content: "// Effect types\nexport * from './effect';\n",
    isBinary: false,
  },
  'src/utils/effectUtils.ts': {
    type: 'file',
    content:
      "import * as THREE from 'three';\nimport { toVector3Array } from 'vibe-starter-3d';\nimport { BulletEffectConfig } from '../components/r3f/effects/BulletEffectController';\n\nexport const createBulletEffectConfig = (config: BulletEffectConfig): { [key: string]: any } => {\n  return {\n    startPosition: config.startPosition.toArray(),\n    direction: config.direction.toArray(),\n    speed: config.speed || 100,\n    duration: config.duration || 1000,\n    scale: config.scale || 1,\n    color: config.color,\n    flashDuration: config.flashDuration === undefined ? 100 : config.flashDuration,\n  };\n};\n\nexport const createExplosionEffectConfig = (position: THREE.Vector3, scale?: number): { [key: string]: any } => {\n  return {\n    position: toVector3Array(position),\n    scale: scale || 1,\n  };\n};\n",
    isBinary: false,
  },
  'src/stores/multiPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport React from 'react';\nimport { RigidBody } from '@dimforge/rapier3d-compat';\n\ntype MultiPlayerRigidBodyState = {\n  connectedPlayerRefs: Record<string, React.RefObject<RigidBody>>;\n  registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => void;\n  unregisterConnectedPlayer: (account: string) => void;\n  getConnectedPlayerRef: (account: string) => React.RefObject<RigidBody> | undefined;\n  getAllConnectedPlayerRefs: () => Record<string, React.RefObject<RigidBody>>;\n  getConnectedPlayerCount: () => number;\n};\n\nexport const useMultiPlayerStore = create<MultiPlayerRigidBodyState>()(\n  subscribeWithSelector((set, get) => ({\n    connectedPlayerRefs: {},\n\n    registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => {\n      set((state) => ({\n        connectedPlayerRefs: {\n          ...state.connectedPlayerRefs,\n          [account]: rigidBodyRef,\n        },\n      }));\n    },\n\n    unregisterConnectedPlayer: (account: string) => {\n      set((state) => {\n        const newConnectedPlayerRefs = { ...state.connectedPlayerRefs };\n        delete newConnectedPlayerRefs[account];\n        return { connectedPlayerRefs: newConnectedPlayerRefs };\n      });\n    },\n\n    getConnectedPlayerRef: (account: string) => {\n      return get().connectedPlayerRefs[account];\n    },\n\n    getAllConnectedPlayerRefs: () => {\n      return get().connectedPlayerRefs;\n    },\n\n    getConnectedPlayerCount: () => {\n      return Object.keys(get().connectedPlayerRefs).length;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/effectStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { ActiveEffect, EffectData } from '../types';\n\n// Define state interface\ninterface EffectState {\n  activeEffects: ActiveEffect[]; // List of active effects\n  effectKeyCounter: number; // Effect unique key counter\n  // Action to add an effect\n  addEffect: (type: string, sender?: string, config?: Record<string, any>) => number; // Returns the key of the added effect\n  // Action to remove an effect\n  removeEffect: (key: number) => void;\n}\n\n// Create Zustand store\nexport const useEffectStore = create<EffectState>((set, get) => ({\n  activeEffects: [], // Initial state: empty array\n  effectKeyCounter: 0, // Initial state: 0\n\n  // Implement effect addition\n  addEffect: (type, sender, config) => {\n    const newKey = get().effectKeyCounter; // Generate a new key with the current counter value\n    // Create EffectData object\n    const effectData: EffectData = {\n      type,\n      config: config,\n    };\n    // Create ActiveEffect object\n    const newEffect: ActiveEffect = {\n      key: newKey,\n      sender,\n      effectData,\n    };\n\n    // State update: add new effect and increment counter\n    set((state) => ({\n      activeEffects: [...state.activeEffects, newEffect],\n      effectKeyCounter: state.effectKeyCounter + 1,\n    }));\n\n    // console.log(`[EffectStore] Effect added: key=${newKey}, type=${type}`); // Debugging log (optional)\n    return newKey; // Return the generated key\n  },\n\n  // Implement effect removal\n  removeEffect: (keyToRemove: number) => {\n    // State update: filter and remove the effect with the corresponding key\n    set((state) => ({\n      activeEffects: state.activeEffects.filter((effect) => effect.key !== keyToRemove),\n    }));\n    // console.log(`[EffectStore] Effect removed: key=${keyToRemove}`); // Debugging log (optional)\n  },\n}));\n\n// Convenience selector hook (optional)\nexport const useActiveEffects = () => useEffectStore((state) => state.activeEffects);\n",
    isBinary: false,
  },
  'src/stores/localPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport * as THREE from 'three';\n\ntype PlayerState = {\n  position: THREE.Vector3;\n};\n\ntype LocalPlayerState = {\n  state: PlayerState;\n  setPosition: (x: number, y: number, z: number) => void;\n  clearPosition: () => void;\n};\n\nexport const useLocalPlayerStore = create<LocalPlayerState>()(\n  subscribeWithSelector((_, get) => ({\n    state: {\n      position: new THREE.Vector3(0, 0, 0),\n    },\n\n    setPosition: (x: number, y: number, z: number) => {\n      const state = get().state;\n      state.position.x = x;\n      state.position.y = y;\n      state.position.z = z;\n    },\n\n    clearPosition: () => {\n      const state = get().state;\n      state.position.x = 0;\n      state.position.y = 0;\n      state.position.z = 0;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/playerActionStore.ts': {
    type: 'file',
    content:
      'interface PlayerActionState {\n  punch: boolean;\n  kick: boolean;\n  meleeAttack: boolean;\n  cast: boolean;\n}\n\ninterface PlayerActionStore extends PlayerActionState {\n  setPlayerAction: (action: string, pressed: boolean) => void;\n  getPlayerAction: (action: string) => boolean;\n  resetAllPlayerActions: () => void;\n}\n\nconst playerActionStore: PlayerActionStore = {\n  punch: false,\n  kick: false,\n  meleeAttack: false,\n  cast: false,\n\n  setPlayerAction: (action: string, pressed: boolean) => {\n    (playerActionStore as any)[action] = pressed;\n  },\n\n  getPlayerAction: (action: string): boolean => {\n    return (playerActionStore as any)[action];\n  },\n\n  resetAllPlayerActions: () => {\n    playerActionStore.punch = false;\n    playerActionStore.kick = false;\n    playerActionStore.meleeAttack = false;\n    playerActionStore.cast = false;\n  },\n};\n\nexport const usePlayerActionStore = () => playerActionStore;',
    isBinary: false,
  },
  'src/stores/gameStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\ninterface GameStore {\n  isMapPhysicsReady: boolean;\n  setMapPhysicsReady: (ready: boolean) => void;\n}\n\nexport const useGameStore = create<GameStore>()(\n  subscribeWithSelector((set) => ({\n    isMapPhysicsReady: false,\n    setMapPhysicsReady: (ready: boolean) => set({ isMapPhysicsReady: ready }),\n  })),\n);\n",
    isBinary: false,
  },
  'src/components/scene/GameScene.tsx': {
    type: 'file',
    content:
      "import GameSceneUI from '../ui/GameSceneUI';\nimport GameSceneCanvas from '../r3f/GameSceneCanvas';\n\n/**\n * Main Game Scene Component\n *\n * This component serves as a layout container that arranges the game UI and 3D Canvas.\n *\n * üö® CRITICAL PERFORMANCE WARNING:\n * Re-rendering of this component triggers re-rendering of the entire 3D Canvas, causing severe performance degradation.\n *\n * Prohibited Actions:\n * - Using state management hooks like useState, useReducer\n * - Passing frequently changing values as props\n * - State updates inside useEffect\n * - Conditional rendering that changes component structure\n * - Creating inline objects/functions (e.g., style={{...}}, onClick={() => {}})\n *\n * Recommendations:\n * - Handle state management in child components (GameSceneUI, GameSceneCanvas)\n * - Access global state directly through zustand store or similar\n * - Memoize event handlers with useCallback before use\n */\nconst GameScene = () => {\n  return (\n    <div className=\"relative w-full h-screen\">\n      <GameSceneCanvas />\n      <GameSceneUI />\n    </div>\n  );\n};\n\nexport default GameScene;\n",
    isBinary: false,
  },
  'src/components/ui/LoadingScreen.tsx': {
    type: 'file',
    content:
      "import { useThree } from '@react-three/fiber';\nimport { Html } from '@react-three/drei';\n\n/**\n * Loading screen component\n */\nconst LoadingScreen = () => {\n  let isInThreeCanvas: boolean;\n  try {\n    useThree();\n    isInThreeCanvas = true;\n  } catch {\n    isInThreeCanvas = false;\n  }\n\n  const loadingContent = (\n    <div>\n      <style>{`\n        .loading-container {\n          inset: 0;\n          z-index: 50;\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: center;\n          background-color: black;\n          color: white;\n          width: 100%;\n          height: 100%;\n        }\n        .loading-title {\n          font-size: 1.5rem;\n          font-weight: bold;\n          margin-bottom: 1rem;\n        }\n        .spinner {\n          width: 30px;\n          height: 30px;\n          border: 3px solid rgba(255, 255, 255, 0.3);\n          border-radius: 50%;\n          border-top-color: white;\n          animation: spin 1s ease-in-out infinite;\n        }\n        @keyframes spin {\n          to {\n            transform: rotate(360deg);\n          }\n        }\n      `}</style>\n      <div className=\"loading-container\">\n        <h2 className=\"loading-title\">Loading</h2>\n        <div className=\"spinner\"></div>\n      </div>\n    </div>\n  );\n\n  if (isInThreeCanvas) {\n    return (\n      <Html\n        center\n        style={{\n          width: '100vw',\n          height: '100vh',\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          pointerEvents: 'none',\n        }}\n      >\n        {loadingContent}\n      </Html>\n    );\n  }\n\n  return loadingContent;\n};\n\nexport default LoadingScreen;\n",
    isBinary: false,
  },
  'src/components/ui/Crosshair.tsx': {
    type: 'file',
    content:
      "import { useEffect, useState } from 'react';\n\n/**\n * Crosshair component for FPS-style targeting\n *\n * Renders a centered crosshair overlay with white lines and black outline\n * for better visibility across different backgrounds.\n */\nconst Crosshair = () => {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const updatePosition = () => {\n      // Get canvas element directly\n      const canvas = document.querySelector('canvas');\n      if (canvas) {\n        const rect = canvas.getBoundingClientRect();\n        const centerX = rect.left + rect.width / 2;\n        const centerY = rect.top + rect.height / 2;\n        setPosition({ x: centerX, y: centerY });\n      } else {\n        // Use viewport center if canvas not found\n        const centerX = window.innerWidth / 2;\n        const centerY = window.innerHeight / 2;\n        setPosition({ x: centerX, y: centerY });\n      }\n    };\n\n    // Set initial position\n    updatePosition();\n\n    // Handle screen size changes and mobile address bar changes\n    window.addEventListener('resize', updatePosition);\n    window.addEventListener('orientationchange', updatePosition);\n\n    // Handle mobile address bar changes on scroll\n    let ticking = false;\n    const handleScroll = () => {\n      if (!ticking) {\n        requestAnimationFrame(() => {\n          updatePosition();\n          ticking = false;\n        });\n        ticking = true;\n      }\n    };\n\n    window.addEventListener('scroll', handleScroll, { passive: true });\n\n    return () => {\n      window.removeEventListener('resize', updatePosition);\n      window.removeEventListener('orientationchange', updatePosition);\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, []);\n\n  return (\n    <div className=\"fixed inset-0 pointer-events-none z-50\">\n      <div\n        className=\"absolute w-6 h-6 flex items-center justify-center\"\n        style={{\n          left: `${position.x}px`,\n          top: `${position.y}px`,\n          transform: 'translate(-50%, -50%)',\n        }}\n      >\n        {/* Horizontal line with black outline */}\n        <div className=\"w-3 h-[1px] bg-white opacity-100 absolute shadow-[0_0_0_1px_rgba(0,0,0,0.8)]\"></div>\n        {/* Vertical line with black outline */}\n        <div className=\"h-3 w-[1px] bg-white opacity-100 absolute shadow-[0_0_0_1px_rgba(0,0,0,0.8)]\"></div>\n      </div>\n    </div>\n  );\n};\n\nexport default Crosshair;\n",
    isBinary: false,
  },
  'src/components/ui/GameSceneUI.tsx': {
    type: 'file',
    content:
      "import { useGameStore } from '../../stores/gameStore';\nimport Crosshair from './Crosshair';\nimport { InputController } from './InputController';\nimport LoadingScreen from './LoadingScreen';\n\n/**\n * Game Scene UI Component\n *\n * This component manages UI overlays for the game scene.\n * It handles loading states and displays appropriate UI elements based on game state.\n */\nconst GameSceneUI = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* Input Controller - Global input management (keyboard, touch) */}\n      <InputController disableJoystick={false} disableKeyboard={false} disabled={!isMapPhysicsReady} />\n\n      {/* Loading Game Scene screen overlay */}\n      {!isMapPhysicsReady && <LoadingScreen />}\n\n      {isMapPhysicsReady && <Crosshair />}\n    </>\n  );\n};\n\nexport default GameSceneUI;\n",
    isBinary: false,
  },
  'src/components/ui/InputController.tsx': {
    type: 'file',
    content:
      "import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport * as THREE from 'three';\nimport { useInputStore, IS_MOBILE } from 'vibe-starter-3d';\nimport { usePlayerActionStore } from '../../stores/playerActionStore';\nimport nipplejs from 'nipplejs';\n\n/**\n * Key mapping configuration - simple Record<string, string[]>\n */\ntype KeyMapping = Record<string, string[]>; // action: [key1, key2, ...]\n\n/**\n * Controller key mapping\n */\nconst CONTROL_KEY_MAPPING: KeyMapping = {\n  forward: ['KeyW', 'ArrowUp'],\n  backward: ['KeyS', 'ArrowDown'],\n  leftward: ['KeyA', 'ArrowLeft'],\n  rightward: ['KeyD', 'ArrowRight'],\n  jump: ['Space'],\n  run: ['ShiftLeft', 'ShiftRight'],\n};\n\n/**\n * Player action key mapping\n */\nconst ACTION_MAPPING: KeyMapping = {\n  attack: ['Mouse0'],\n};\n\n// Movement speed constants\nconst MOVEMENT_SPEED_WALK = 0.6;\nconst MOVEMENT_SPEED_RUN_BOOST = 0.4;\nconst MOVEMENT_SPEED_MAX = 1.0;\nconst JOYSTICK_RANGE_MULTIPLIER = 2.0; // Converts joystick range (0~0.5) to full range (0~1.0)\n\ninterface InputControllerProps {\n  disabled?: boolean;\n  disableKeyboard?: boolean;\n  disableJoystick?: boolean;\n}\n\nexport const InputController: React.FC<InputControllerProps> = ({ disabled = false, disableKeyboard = false, disableJoystick = false }) => {\n  // Store actions to controller\n  const { setMovementInput, setActionInput, resetAllInputs, setActiveInputSource } = useInputStore();\n  const { setPlayerAction, resetAllPlayerActions } = usePlayerActionStore();\n\n  // Button states\n  const [isJumpPressed, setIsJumpPressed] = useState(false);\n  const [isAttackPressed, setIsAttackPressed] = useState(false);\n\n  // Keyboard state tracking\n  const keyboardStateRef = useRef({\n    forward: false,\n    backward: false,\n    leftward: false,\n    rightward: false,\n    run: false,\n  });\n\n  // Helper function to calculate movement from keyboard state\n  const calculateKeyboardMovement = useCallback(() => {\n    const state = keyboardStateRef.current;\n\n    // Calculate direction\n    const x = (state.leftward ? 1 : 0) + (state.rightward ? -1 : 0);\n    const y = (state.forward ? 1 : 0) + (state.backward ? -1 : 0);\n\n    // Use Three.js Vector2 for efficient normalization\n    const direction = new THREE.Vector2(x, y);\n    const magnitude = direction.length();\n\n    // Normalize diagonal movement\n    if (magnitude > 0) {\n      direction.normalize();\n    }\n\n    // Calculate intensity: base speed + run boost\n    const baseIntensity = magnitude > 0 ? MOVEMENT_SPEED_WALK : 0; // Base walking speed\n    const runBoost = state.run ? MOVEMENT_SPEED_RUN_BOOST : 0; // Additional speed when running\n    const intensity = Math.min(baseIntensity + runBoost, MOVEMENT_SPEED_MAX);\n\n    return {\n      direction: { x: direction.x, y: direction.y },\n      intensity,\n    };\n  }, []);\n\n  // Joystick input handling with analog support\n  useEffect(() => {\n    if (disabled || disableJoystick || !IS_MOBILE) return;\n\n    // Create div element for left side area of screen\n    const joystickZone = document.createElement('div');\n    joystickZone.style.position = 'fixed';\n    joystickZone.style.left = '0';\n    joystickZone.style.top = '0';\n    joystickZone.style.width = '50%'; // Left 50% of screen\n    joystickZone.style.height = '100%';\n    joystickZone.style.zIndex = '1000';\n    joystickZone.style.pointerEvents = 'auto';\n    joystickZone.style.backgroundColor = 'transparent';\n    // Disable long touch events\n    joystickZone.style.touchAction = 'none';\n    joystickZone.style.userSelect = 'none';\n    joystickZone.style.setProperty('-webkit-user-select', 'none');\n    joystickZone.style.setProperty('-webkit-touch-callout', 'none');\n    document.body.appendChild(joystickZone);\n\n    const options: nipplejs.JoystickManagerOptions = {\n      zone: joystickZone,\n      color: 'white',\n      mode: 'dynamic',\n      shape: 'circle',\n    };\n\n    const manager = nipplejs.create(options);\n\n    manager.on('move', (evt, data) => {\n      if (disabled || disableJoystick) return; // Check disabled state\n      setActiveInputSource('joystick');\n\n      // Extract analog data from nipplejs\n      const angle = data.angle?.radian || 0; // Angle in radians\n      const distance = data.distance || 0; // Distance from center\n      const maxDistance = data.instance.options.size || 100; // Maximum distance\n\n      // Calculate normalized direction vector\n      // nipplejs uses mathematical coordinate system (0¬∞ = right, 90¬∞ = up)\n      // We need to convert to game coordinate system (0¬∞ = up, 90¬∞ = right)\n      const gameAngle = angle - Math.PI / 2; // Rotate by -90 degrees\n      const directionX = Math.sin(gameAngle); // Right/Left\n      const directionY = Math.cos(gameAngle); // Forward/Backward\n\n      // Calculate intensity (0.0 to 1.0) based on distance from center\n      const intensity = Math.min((distance / maxDistance) * JOYSTICK_RANGE_MULTIPLIER, MOVEMENT_SPEED_MAX);\n\n      // Set analog movement input\n      setMovementInput({ x: directionX, y: directionY }, intensity, 'joystick');\n    });\n\n    manager.on('end', () => {\n      if (disabled || disableJoystick) return; // Check disabled state\n      // Reset all inputs when joystick ends\n      setMovementInput({ x: 0, y: 0 }, 0, 'joystick');\n    });\n\n    return () => {\n      manager.destroy();\n      if (joystickZone.parentNode) {\n        joystickZone.parentNode.removeChild(joystickZone);\n      }\n    };\n  }, [disabled, disableJoystick, setMovementInput, setActiveInputSource]);\n\n  // Keyboard input handling - convert to movement immediately\n  useEffect(() => {\n    if (disabled || disableKeyboard) return;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n      let stateChanged = false;\n\n      // Handle movement keys\n      if (CONTROL_KEY_MAPPING['forward']?.includes(event.code) && !keyboardStateRef.current.forward) {\n        keyboardStateRef.current.forward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['backward']?.includes(event.code) && !keyboardStateRef.current.backward) {\n        keyboardStateRef.current.backward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['leftward']?.includes(event.code) && !keyboardStateRef.current.leftward) {\n        keyboardStateRef.current.leftward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['rightward']?.includes(event.code) && !keyboardStateRef.current.rightward) {\n        keyboardStateRef.current.rightward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['run']?.includes(event.code) && !keyboardStateRef.current.run) {\n        keyboardStateRef.current.run = true;\n        stateChanged = true;\n      }\n\n      // Handle action keys\n      if (CONTROL_KEY_MAPPING['jump']?.includes(event.code)) {\n        setActionInput('jump', true, 'keyboard');\n      }\n\n      // Handle player action keys\n      Object.keys(ACTION_MAPPING).forEach((action) => {\n        if (ACTION_MAPPING[action]?.includes(event.code)) {\n          setPlayerAction(action, true);\n        }\n      });\n\n      // Update movement if any movement-related key changed\n      if (stateChanged) {\n        const movement = calculateKeyboardMovement();\n        setMovementInput(movement.direction, movement.intensity, 'keyboard');\n      }\n    };\n\n    const handleKeyUp = (event: KeyboardEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n      let stateChanged = false;\n\n      // Handle movement keys\n      if (CONTROL_KEY_MAPPING['forward']?.includes(event.code) && keyboardStateRef.current.forward) {\n        keyboardStateRef.current.forward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['backward']?.includes(event.code) && keyboardStateRef.current.backward) {\n        keyboardStateRef.current.backward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['leftward']?.includes(event.code) && keyboardStateRef.current.leftward) {\n        keyboardStateRef.current.leftward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['rightward']?.includes(event.code) && keyboardStateRef.current.rightward) {\n        keyboardStateRef.current.rightward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['run']?.includes(event.code) && keyboardStateRef.current.run) {\n        keyboardStateRef.current.run = false;\n        stateChanged = true;\n      }\n\n      // Handle action keys\n      if (CONTROL_KEY_MAPPING['jump']?.includes(event.code)) {\n        setActionInput('jump', false, 'keyboard');\n      }\n\n      // Handle player action keys\n      Object.keys(ACTION_MAPPING).forEach((action) => {\n        if (ACTION_MAPPING[action]?.includes(event.code)) {\n          setPlayerAction(action, false);\n        }\n      });\n\n      // Update movement if any movement-related key changed\n      if (stateChanged) {\n        const movement = calculateKeyboardMovement();\n        setMovementInput(movement.direction, movement.intensity, 'keyboard');\n      }\n    };\n\n    const handleMouseDown = (event: MouseEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n\n      // Handle player action mouse keys\n      const mouseButton = `Mouse${event.button}`;\n      Object.keys(ACTION_MAPPING).forEach((action) => {\n        if (ACTION_MAPPING[action]?.includes(mouseButton)) {\n          setPlayerAction(action, true);\n        }\n      });\n    };\n\n    const handleMouseUp = (event: MouseEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n\n      // Handle player action mouse keys\n      const mouseButton = `Mouse${event.button}`;\n      Object.keys(ACTION_MAPPING).forEach((action) => {\n        if (ACTION_MAPPING[action]?.includes(mouseButton)) {\n          setPlayerAction(action, false);\n        }\n      });\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n      document.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [disabled, disableKeyboard, setMovementInput, setActionInput, setPlayerAction, calculateKeyboardMovement]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      resetAllInputs();\n      resetAllPlayerActions();\n    };\n  }, [resetAllInputs, resetAllPlayerActions]);\n\n  // Reset inputs when disabled\n  useEffect(() => {\n    if (disabled || disableKeyboard || disableJoystick) {\n      // Reset keyboard state if keyboard is disabled\n      if (disabled || disableKeyboard) {\n        keyboardStateRef.current = {\n          forward: false,\n          backward: false,\n          leftward: false,\n          rightward: false,\n          run: false,\n        };\n      }\n      // Reset button states\n      setIsJumpPressed(false);\n      setIsAttackPressed(false);\n      resetAllInputs();\n      resetAllPlayerActions();\n    }\n  }, [disabled, disableKeyboard, disableJoystick, resetAllInputs, resetAllPlayerActions]);\n\n  // Button handlers\n  const handleJumpStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation(); // Prevent event propagation\n      setIsJumpPressed(true);\n      setActionInput('jump', true, 'touch');\n    },\n    [disabled, setActionInput],\n  );\n\n  const handleJumpEnd = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation(); // Prevent event propagation\n      setIsJumpPressed(false);\n      setActionInput('jump', false, 'touch');\n    },\n    [disabled, setActionInput],\n  );\n\n  const handleAttackStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation();\n      setIsAttackPressed(true);\n      setPlayerAction('attack', true);\n    },\n    [disabled, setPlayerAction],\n  );\n\n  const handleAttackEnd = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation();\n      setIsAttackPressed(false);\n      setPlayerAction('attack', false);\n    },\n    [disabled, setPlayerAction],\n  );\n\n  // Don't render action buttons if joystick is disabled\n  if (disableJoystick) {\n    return null;\n  }\n\n  // Render action buttons\n  return (\n    <div className=\"fixed bottom-8 right-8 z-[1001]\">\n      {/* Attack Button */}\n      <div\n        className={`w-20 h-20 rounded-full bg-white/30 \n                   flex items-center justify-center cursor-pointer select-none touch-none\n                   ${isAttackPressed ? 'scale-90' : 'scale-100'} transition-transform`}\n        onMouseDown={handleAttackStart}\n        onMouseUp={handleAttackEnd}\n        onMouseLeave={handleAttackEnd}\n        onTouchStart={handleAttackStart}\n        onTouchEnd={handleAttackEnd}\n      >\n        <span className=\"text-white text-xs font-bold\">ATTACK</span>\n      </div>\n\n      {/* Jump Button */}\n      <div\n        className={`absolute bottom-0 -left-12 -top-12 w-14 h-14 rounded-full bg-white/30 \n                   flex items-center justify-center cursor-pointer select-none touch-none\n                   ${isJumpPressed ? 'scale-90' : 'scale-100'} transition-transform`}\n        onMouseDown={handleJumpStart}\n        onMouseUp={handleJumpEnd}\n        onMouseLeave={handleJumpEnd}\n        onTouchStart={handleJumpStart}\n        onTouchEnd={handleJumpEnd}\n      >\n        <span className=\"text-white text-xs font-bold\">JUMP</span>\n      </div>\n    </div>\n  );\n};\n",
    isBinary: false,
  },
  'src/components/r3f/Floor.tsx': {
    type: 'file',
    content:
      'import { RigidBodyObject } from \'vibe-starter-3d\';\nimport { RigidBodyObjectType } from \'../../constants/rigidBodyObjectType\';\n\nfunction Floor() {\n  return (\n    <RigidBodyObject type="fixed" colliders="cuboid" userData={{ type: RigidBodyObjectType.FLOOR }}>\n      <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow position={[0, 0, 0]}>\n        <planeGeometry args={[100, 100]} />\n        <meshStandardMaterial color="#3f3f3f" />\n      </mesh>\n    </RigidBodyObject>\n  );\n}\n\nexport default Floor;\n',
    isBinary: false,
  },
  'src/components/r3f/Player.tsx': {
    type: 'file',
    content:
      "import React, { useRef, useEffect, useCallback } from 'react';\nimport * as THREE from 'three';\nimport { useFrame, useThree, Vector3 } from '@react-three/fiber';\nimport { CollisionPayload } from '@react-three/rapier';\nimport { useGameServer } from '@agent8/gameserver';\n\nimport {\n  AnimationConfigMap,\n  AnimationType,\n  CharacterMovementState,\n  CharacterRenderer,\n  RigidBodyPlayer,\n  RigidBodyPlayerRef,\n  useCharacterAnimation,\n  useControllerStore,\n} from 'vibe-starter-3d';\n\nimport { useLocalPlayerStore } from '../../stores/localPlayerStore';\nimport { useMultiPlayerStore } from '../../stores/multiPlayerStore';\nimport { usePlayerActionStore } from '../../stores/playerActionStore';\n\nimport { CharacterState } from '../../constants/character';\nimport { RigidBodyObjectType } from '../../constants/rigidBodyObjectType';\n\nimport Assets from '../../assets.json';\nimport { useEffectStore } from '../../stores/effectStore';\nimport { EffectType } from '../../types/effect';\nimport { createBulletEffectConfig } from '../../utils/effectUtils';\n\nconst SHOOT_COOLDOWN = 200;\nconst targetHeight = 1.6;\n\n// States that can be interrupted by actions\nconst INTERRUPTIBLE_STATES = [\n  CharacterState.IDLE,\n  CharacterState.IDLE_01,\n  CharacterState.WALK,\n  CharacterState.RUN,\n  CharacterState.FAST_RUN,\n  CharacterState.JUMP,\n] as const;\n\nconst animationConfigMap: AnimationConfigMap = {\n  [CharacterState.IDLE]: {\n    url: Assets.animations['idle-00'].url,\n    loop: true,\n  },\n  [CharacterState.IDLE_01]: {\n    url: Assets.animations['idle-01'].url,\n    loop: true,\n  },\n  [CharacterState.WALK]: {\n    url: Assets.animations['walk'].url,\n    loop: true,\n  },\n  [CharacterState.RUN]: {\n    url: Assets.animations['run-medium'].url,\n    loop: true,\n  },\n  [CharacterState.FAST_RUN]: {\n    url: Assets.animations['run-fast'].url,\n    loop: true,\n  },\n  [CharacterState.JUMP]: {\n    url: Assets.animations['jump'].url,\n    loop: true,\n    clampWhenFinished: true,\n  },\n  [CharacterState.PUNCH]: {\n    url: Assets.animations['punch-00'].url,\n    loop: false,\n    duration: 0.5,\n    clampWhenFinished: true,\n  },\n  [CharacterState.PUNCH_01]: {\n    url: Assets.animations['punch-01'].url,\n    loop: false,\n    duration: 0.5,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK]: {\n    url: Assets.animations['kick-00'].url,\n    loop: false,\n    duration: 0.75,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK_01]: {\n    url: Assets.animations['kick-01'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK_02]: {\n    url: Assets.animations['kick-02'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.MELEE_ATTACK]: {\n    url: Assets.animations['melee-attack'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.CAST]: {\n    url: Assets.animations['cast'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.HIT]: {\n    url: Assets.animations['hit-to-body'].url,\n    loop: false,\n    clampWhenFinished: false,\n  },\n  [CharacterState.DANCE]: {\n    url: Assets.animations['dance-wave'].url,\n    loop: false,\n    clampWhenFinished: false,\n  },\n  [CharacterState.SWIM]: {\n    url: Assets.animations['swim'].url,\n    loop: true,\n  },\n  [CharacterState.DIE]: {\n    url: Assets.animations['death-backward'].url,\n    loop: false,\n    clampWhenFinished: true,\n  },\n};\n\n/**\n * Player props\n */\ninterface PlayerProps {\n  /** Initial position of the player */\n  position?: Vector3;\n}\n\n/**\n * Player component that manages character model and animations\n *\n * Handles player state management and delegates rendering to CharacterRenderer.\n * Movement states come from ControllerStore, actions are handled locally.\n */\nconst Player = ({ position }: PlayerProps) => {\n  const { account } = useGameServer();\n  const { registerConnectedPlayer, unregisterConnectedPlayer } = useMultiPlayerStore();\n  const { setPosition: setLocalPlayerPosition } = useLocalPlayerStore();\n  const { getPlayerAction } = usePlayerActionStore();\n\n  // Use the new useCharacterAnimation hook\n  const { animationState, setAnimation, getAnimation } = useCharacterAnimation<CharacterState>(CharacterState.IDLE);\n\n  const camera = useThree((state) => state.camera);\n\n  // Get movement state from controller store (unified API)\n  const { getCharacterMovementState, isControlLocked, lockControls, unlockControls } = useControllerStore();\n\n  // IMPORTANT: rigidBodyPlayerRef.current type is RigidBody\n  const rigidBodyPlayerRef = useRef<RigidBodyPlayerRef>(null);\n\n  const shootTimestamp = useRef(0);\n  const lastFrameAttack = useRef(false);\n\n  // IMPORTANT: Register connected player reference\n  useEffect(() => {\n    if (!account) return;\n\n    registerConnectedPlayer(account, rigidBodyPlayerRef);\n\n    return () => {\n      unregisterConnectedPlayer(account);\n    };\n  }, [account, registerConnectedPlayer, unregisterConnectedPlayer]);\n\n  // IMPORTANT: Update local player store position information\n  useFrame(() => {\n    const playerRigidBody = rigidBodyPlayerRef.current;\n    if (!playerRigidBody) return;\n\n    const position = playerRigidBody.translation();\n    setLocalPlayerPosition(position.x, position.y, position.z);\n  });\n\n  // Get addEffect action from the store\n  const addEffect = useEffectStore((state) => state.addEffect);\n\n  // Callback for Player to request a cast\n  const spawnEffect = useCallback(\n    async (type: string, config?: { [key: string]: any }) => {\n      if (!account) return;\n\n      // Add effect locally via store\n      addEffect(type, account, config);\n    },\n    [addEffect, account],\n  );\n\n  // Helper functions\n  const canInterrupt = useCallback((state: CharacterState): boolean => {\n    return INTERRUPTIBLE_STATES.includes(state);\n  }, []);\n\n  // Convert ControllerStore state to Player animation state\n  const toCharacterState = useCallback((characterMovementState: CharacterMovementState): CharacterState => {\n    switch (characterMovementState) {\n      case CharacterMovementState.IDLE:\n        return CharacterState.IDLE;\n      case CharacterMovementState.WALKING:\n        return CharacterState.WALK;\n      case CharacterMovementState.RUN:\n        return CharacterState.RUN;\n      case CharacterMovementState.FAST_RUN:\n        return CharacterState.FAST_RUN;\n      case CharacterMovementState.AIRBORNE:\n        return CharacterState.JUMP;\n      default:\n        return CharacterState.IDLE;\n    }\n  }, []);\n\n  // Callback triggered when a non-looping animation finishes.\n  const handleAnimationComplete = useCallback(\n    (type: AnimationType) => {\n      unlockControls();\n      switch (type) {\n        case CharacterState.PUNCH:\n        case CharacterState.PUNCH_01:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.KICK:\n        case CharacterState.KICK_01:\n        case CharacterState.KICK_02:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.CAST:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.HIT:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.MELEE_ATTACK:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.DANCE:\n          setAnimation(CharacterState.IDLE);\n          break;\n        default:\n          break;\n      }\n    },\n    [unlockControls, setAnimation],\n  );\n\n  const updatePlayerState = useCallback((): void => {\n    const currentState = getAnimation();\n\n    // If controls are locked, don't process actions\n    if (isControlLocked()) {\n      return;\n    }\n\n    // Handle death and revive states\n    // TODO: Connect with actual game state\n    // const isRevive = playerHealth > 0 && currentState === CharacterState.DIE;\n    // const isDying = playerHealth <= 0 && currentState !== CharacterState.DIE;\n\n    // Currently using placeholder false values\n    const isRevive = false;\n    const isDying = false;\n\n    // Revive handling: when health is restored while in death state\n    if (isRevive) {\n      setAnimation(CharacterState.IDLE);\n      return;\n    }\n\n    // Death handling: when health drops to 0 or below\n    if (isDying) {\n      setAnimation(CharacterState.DIE);\n      return;\n    }\n\n    // For movement states, use ControllerStore state\n    if (canInterrupt(currentState)) {\n      const characterMovementState = getCharacterMovementState();\n      const characterState = toCharacterState(characterMovementState);\n      setAnimation(characterState);\n    }\n  }, [isControlLocked, canInterrupt, lockControls, getCharacterMovementState, toCharacterState, getAnimation, setAnimation, getPlayerAction]);\n\n  // Update player action state based on inputs and physics\n  useFrame(() => {\n    if (!rigidBodyPlayerRef.current) return;\n    updatePlayerState();\n\n    const attack = getPlayerAction('attack');\n    const now = Date.now();\n    const canAttack = attack && !lastFrameAttack.current;\n    lastFrameAttack.current = attack;\n    if (canAttack && now > shootTimestamp.current) {\n      shootTimestamp.current = now + SHOOT_COOLDOWN;\n      const direction = new THREE.Vector3();\n      camera.getWorldDirection(direction);\n      const bulletSpeed = 200;\n      const cameraPosition = new THREE.Vector3();\n      camera.getWorldPosition(cameraPosition);\n      const startPosition = cameraPosition.add(direction.clone().multiplyScalar(1.5));\n      spawnEffect(\n        EffectType.BULLET,\n        createBulletEffectConfig({ startPosition, direction, speed: bulletSpeed, duration: 500, scale: 3, flashDuration: 30, color: 'black' }),\n      );\n    }\n  });\n\n  /** handleTriggerEnter: Called when the player intersects or collides with another object.\n   * - Handles when entering a specific area or colliding with another object\n   */\n  const handleTriggerEnter = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when entering a specific area or colliding with another object\n    }\n  };\n\n  /** handleTriggerExit: Called when the player exits an intersection or ends a collision with another object.\n   * - Handles when exiting a specific area or when collision with another object ends\n   */\n  const handleTriggerExit = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when exiting a specific area or when collision with another object ends\n    }\n  };\n\n  return (\n    <RigidBodyPlayer\n      ref={rigidBodyPlayerRef}\n      userData={{ account, type: RigidBodyObjectType.LOCAL_PLAYER }}\n      position={position}\n      targetHeight={targetHeight}\n      onTriggerEnter={handleTriggerEnter}\n      onTriggerExit={handleTriggerExit}\n    >\n      <CharacterRenderer\n        /**\n         * IMPORTANT: In First Person View (FPS), the player's own character should not be visible,\n         * so the visible property is set to false. This setting is crucial for the FPS implementation.\n         */\n        visible={false}\n        url={Assets.characters['base-model'].url}\n        animationConfigMap={animationConfigMap}\n        animationState={animationState}\n        targetHeight={targetHeight}\n        onAnimationComplete={handleAnimationComplete}\n      />\n    </RigidBodyPlayer>\n  );\n};\n\nexport default Player;\n",
    isBinary: false,
  },
  'src/components/r3f/GameSceneCanvas.tsx': {
    type: 'file',
    content:
      "import React, { Suspense } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { Physics } from '@react-three/rapier';\nimport { FirstPersonViewController, FollowLight, IS_MOBILE } from 'vibe-starter-3d';\nimport { useGameStore } from '../../stores/gameStore';\nimport { Environment } from '@react-three/drei';\nimport MapPhysicsReadyChecker from '../r3f/MapPhysicsReadyChecker';\nimport EffectContainer from './EffectContainer';\nimport Player from './Player';\nimport Floor from './Floor';\n\n/**\n * Game Scene Canvas Component\n *\n * This component is responsible for rendering the entire 3D game world using React Three Fiber.\n * It serves as the root container for all 3D elements, physics simulation, and game interactions.\n */\nconst GameSceneCanvas = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* ‚ö†Ô∏è DO NOT DELETE: Core Canvas component for React Three Fiber */}\n      <Canvas\n        shadows\n        onPointerDown={(e) => {\n          if (!IS_MOBILE) {\n            (e.target as HTMLCanvasElement).requestPointerLock();\n          }\n        }}\n      >\n        <Physics paused={!isMapPhysicsReady}>\n          <Suspense fallback={null}>\n            {/* ‚ö†Ô∏è MUST INCLUDE: Essential checker for map physics initialization */}\n            {!isMapPhysicsReady && <MapPhysicsReadyChecker />}\n            <FirstPersonViewController />\n            <EffectContainer />\n            <Environment preset=\"sunset\" background={false} />\n            <ambientLight intensity={0.7} />\n            <FollowLight />\n            <Player />\n            <Floor />\n          </Suspense>\n        </Physics>\n      </Canvas>\n    </>\n  );\n};\n\nexport default GameSceneCanvas;\n",
    isBinary: false,
  },
  'src/components/r3f/EffectContainer.tsx': {
    type: 'file',
    content:
      "import { useCallback } from 'react';\nimport * as THREE from 'three';\nimport { ActiveEffect, EffectType } from '../../types';\nimport { useEffectStore, useActiveEffects } from '../../stores/effectStore';\nimport { useMultiPlayerStore } from '../../stores/multiPlayerStore';\nimport { createExplosionEffectConfig } from '../../utils/effectUtils';\nimport Explosion from './effects/Explosion';\nimport BulletEffectController from './effects/BulletEffectController';\nimport { CollisionPayload } from '@react-three/rapier';\n\n/**\n * Effect container component using Zustand store for effect management.\n */\nfunction EffectContainer() {\n  const { getConnectedPlayerRef } = useMultiPlayerStore();\n\n  // Get state and actions from the Zustand store\n  const activeEffects = useActiveEffects();\n  const addEffect = useEffectStore((state) => state.addEffect);\n  const removeEffect = useEffectStore((state) => state.removeEffect);\n\n  // Callback to remove completed effects using the store action\n  const handleEffectComplete = useCallback(\n    (keyToRemove: number) => {\n      removeEffect(keyToRemove);\n    },\n    [removeEffect],\n  );\n\n  // Handler for when an effect hits something (logic might be needed here)\n  const handleEffectHit = useCallback(\n    (type: EffectType, payload: CollisionPayload, sender?: string): boolean => {\n      const otherAccount = payload.other.rigidBody?.userData?.['account'];\n      if (sender && otherAccount) {\n        if (otherAccount === sender) return false;\n      }\n\n      if (type === EffectType.BULLET) {\n        const hitPoint = payload.target.collider.translation();\n        addEffect(EffectType.EXPLOSION, undefined, createExplosionEffectConfig(new THREE.Vector3(hitPoint.x, hitPoint.y, hitPoint.z), 0.1));\n      }\n\n      return true;\n    },\n    [addEffect],\n  );\n\n  // Function to render individual effects based on their type\n  const renderEffect = useCallback(\n    (effect: ActiveEffect) => {\n      const type = effect.effectData.type;\n\n      switch (type) {\n        case EffectType.BULLET:\n          return (\n            <BulletEffectController\n              key={effect.key}\n              config={effect.effectData.config}\n              owner={getConnectedPlayerRef(effect.sender)?.current}\n              onHit={(payload) => handleEffectHit(type, payload, effect.sender)}\n              onComplete={() => {\n                handleEffectComplete(effect.key);\n              }}\n            />\n          );\n        case EffectType.EXPLOSION:\n          return (\n            <Explosion\n              key={effect.key}\n              config={effect.effectData.config}\n              onComplete={() => {\n                handleEffectComplete(effect.key);\n              }}\n            />\n          );\n        // Add cases for other effect types here\n        default:\n          console.warn(`[EffectContainer] Unknown effect type: ${type}`);\n          return null;\n      }\n    },\n    [handleEffectHit, handleEffectComplete, getConnectedPlayerRef],\n  );\n\n  // Render all active effects from the store\n  return <>{activeEffects.map(renderEffect)}</>;\n}\n\nexport default EffectContainer;\n",
    isBinary: false,
  },
  'src/components/r3f/MapPhysicsReadyChecker.tsx': {
    type: 'file',
    content:
      "import { useFrame } from '@react-three/fiber';\nimport { useRapier } from '@react-three/rapier';\nimport { useRef } from 'react';\nimport * as THREE from 'three';\nimport { useGameStore } from '../../stores/gameStore';\n\n/**\n * Component that checks if the map physics is ready by performing raycasting.\n * Casts a ray downward from above to detect map geometry and ensures physics\n * interactions are properly initialized before gameplay begins.\n *\n * - Performs checks every frame until map physics is confirmed ready\n * - Times out after 60 frames as fallback to prevent infinite checking\n * - Excludes Capsule shapes (likely characters/objects) and sensor colliders\n * - Sets mapPhysicsReady to true once valid map geometry is detected\n */\nfunction MapPhysicsReadyChecker() {\n  const { isMapPhysicsReady, setMapPhysicsReady } = useGameStore();\n  const physicsCheckCount = useRef(0);\n  const { rapier, world } = useRapier();\n\n  useFrame(() => {\n    if (isMapPhysicsReady) return;\n\n    physicsCheckCount.current++;\n    if (physicsCheckCount.current > 180) {\n      setMapPhysicsReady(true);\n      return;\n    }\n\n    const origin = new THREE.Vector3(0, 50, 0);\n    const downDirection = new THREE.Vector3(0, -1, 0);\n    const ray = new rapier.Ray(origin, downDirection);\n\n    // Get all intersections and find the first non-sensor collider\n    const intersections: any[] = [];\n    world.propagateModifiedBodyPositionsToColliders();\n    world.updateSceneQueries();\n    world.intersectionsWithRay(ray, 100, true, (intersection) => {\n      // Exclude Capsule shapes as they are unlikely to be map colliders\n      if (intersection.collider.shape.type === rapier.ShapeType.Capsule) {\n        return true;\n      }\n      intersections.push(intersection);\n      return true; // continue searching\n    });\n\n    // Find the first non-sensor collider\n    const validHit = intersections.find((intersection) => !intersection.collider.isSensor());\n    if (!validHit) return;\n\n    console.log('%c[vibe-starter-3d]%c Map physics initialized.', 'color: #7159c1; font-weight: bold', 'color: inherit;');\n    setMapPhysicsReady(true);\n  });\n\n  return null;\n}\n\nexport default MapPhysicsReadyChecker;\n",
    isBinary: false,
  },
  'src/components/r3f/effects/Bullet.tsx': {
    type: 'file',
    content:
      "import * as THREE from 'three';\nimport React, { useRef, useEffect, useMemo, useCallback } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { RapierRigidBody, useRapier, CollisionPayload, CuboidArgs, CuboidCollider } from '@react-three/rapier';\nimport { ActiveCollisionTypes, InteractionGroups } from '@dimforge/rapier3d-compat';\nimport { RigidBodyObject, RigidBodyObjectRef } from 'vibe-starter-3d';\nimport { RigidBodyObjectType } from '../../../constants/rigidBodyObjectType';\n\nconst DEFAULT_SIZE = new THREE.Vector3(0.05, 0.05, 0.15);\nconst DEFAULT_SIZE_HALF: CuboidArgs = [DEFAULT_SIZE.x / 2, DEFAULT_SIZE.y / 2, DEFAULT_SIZE.z / 2];\n\nexport interface BulletProps {\n  startPosition: THREE.Vector3;\n  direction: THREE.Vector3;\n  color?: THREE.ColorRepresentation | undefined;\n  scale?: number;\n  speed: number;\n  duration: number;\n  collisionGroups?: InteractionGroups;\n  owner?: RapierRigidBody;\n  onHit?: (payload: CollisionPayload) => void;\n  onComplete?: () => void;\n}\n\nconst Bullet: React.FC<BulletProps> = ({\n  startPosition,\n  direction,\n  color = 'orange',\n  scale = 1,\n  speed,\n  duration,\n  collisionGroups,\n  owner,\n  onHit,\n  onComplete,\n}) => {\n  const active = useRef(true);\n  const rigidBodyRef = useRef<RigidBodyObjectRef>(null);\n  const freezed = useRef(false);\n  const framesSinceFreezed = useRef(0);\n  const meshRef = useRef<THREE.Mesh>(null);\n  const visible = useRef(false);\n  const { rapier, world } = useRapier();\n  const normalizedDirection = direction.clone().normalize();\n  const bulletGeometry = new THREE.BoxGeometry(DEFAULT_SIZE.x, DEFAULT_SIZE.y, DEFAULT_SIZE.z);\n  const bulletMaterial = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 2 });\n  const onCompleteRef = useRef(onComplete);\n  const startTime = useRef(Date.now());\n\n  // Bullet removal function\n  const removeBullet = useCallback(() => {\n    if (!active.current) return;\n\n    active.current = false;\n    onCompleteRef.current?.();\n  }, [active]);\n\n  useEffect(() => {\n    onCompleteRef.current = onComplete;\n  }, [onComplete]);\n\n  useFrame((_, delta) => {\n    if (!active.current) return;\n\n    const elapsed = Date.now() - startTime.current;\n    if (elapsed > duration) {\n      removeBullet();\n      return;\n    }\n\n    // make bullet visible after 150ms\n    if (!visible.current && elapsed > 150) {\n      visible.current = true;\n      if (meshRef.current) {\n        meshRef.current.visible = true;\n      }\n    }\n\n    // skip update if bullet is freezed\n    if (freezed.current) {\n      framesSinceFreezed.current++;\n\n      // If onTriggerEnter hasn't been called after 3 frames, unfreeze and continue checking\n      if (framesSinceFreezed.current > 3) {\n        console.warn('Bullet frozen too long, unfreezing to continue collision check');\n        freezed.current = false;\n        framesSinceFreezed.current = 0;\n      }\n      return;\n    }\n\n    const rigidBody = rigidBodyRef.current;\n    if (!rigidBody || rigidBody.numColliders() === 0) return;\n\n    const frameTravelDistance = speed * delta;\n    const originVec = rigidBody.translation();\n    const ray = new rapier.Ray(originVec, normalizedDirection);\n    const bulletOwnCollider = rigidBody.collider(0);\n\n    const hit = world.castRay(\n      ray,\n      frameTravelDistance,\n      true, // solid\n      undefined, // queryFlags\n      collisionGroups, // groups\n      bulletOwnCollider, // Exclude bullet's own collider\n      owner, // Exclude the owner (firer)\n    );\n\n    if (hit) {\n      const hitPoint = ray.pointAt(hit.timeOfImpact);\n      const hitPointVec3 = new THREE.Vector3(hitPoint.x, hitPoint.y, hitPoint.z);\n\n      freezed.current = true;\n      framesSinceFreezed.current = 0;\n      rigidBody.setTranslation(hitPointVec3, true);\n      return;\n    } else {\n      // No hit, continue with velocity based movement (handled by RigidBody component)\n      const curVec3 = new THREE.Vector3(originVec.x, originVec.y, originVec.z);\n      const nextPosition = curVec3.addScaledVector(normalizedDirection, frameTravelDistance);\n      rigidBody.setTranslation(nextPosition, true);\n    }\n  });\n\n  // Calculate rotation quaternion in the firing direction\n  const bulletQuaternion = useMemo(() => {\n    const quaternion = new THREE.Quaternion();\n    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), normalizedDirection);\n    return quaternion;\n  }, [normalizedDirection]);\n\n  // Calculate rotation & position for RigidBody\n  const bulletRotation = useMemo(() => {\n    return new THREE.Euler().setFromQuaternion(bulletQuaternion);\n  }, [bulletQuaternion]);\n\n  // Don't render if the bullet has been removed\n  if (!active) return null;\n\n  return (\n    <RigidBodyObject\n      ref={rigidBodyRef}\n      userData={{\n        type: RigidBodyObjectType.BULLET,\n      }}\n      type=\"kinematicVelocity\"\n      position={[startPosition.x, startPosition.y, startPosition.z]}\n      rotation={bulletRotation}\n      sensor={true}\n      scale={scale}\n      colliders={false}\n      collisionGroups={collisionGroups ?? 0xffffffff}\n      activeCollisionTypes={ActiveCollisionTypes.ALL}\n      onTriggerEnter={(payload: CollisionPayload) => {\n        freezed.current = false;\n        framesSinceFreezed.current = 0;\n        if (owner && owner.handle === payload.other.rigidBody.handle) {\n          return;\n        }\n\n        onHit?.(payload);\n        removeBullet();\n      }}\n      name=\"bullet\"\n    >\n      <CuboidCollider args={DEFAULT_SIZE_HALF} />\n      <mesh ref={meshRef} geometry={bulletGeometry} material={bulletMaterial} visible={false} />\n    </RigidBodyObject>\n  );\n};\n\nexport default Bullet;\n",
    isBinary: false,
  },
  'src/components/r3f/effects/BulletEffectController.tsx': {
    type: 'file',
    content:
      "import * as THREE from 'three';\nimport Bullet from './Bullet';\nimport MuzzleFlash from './MuzzleFlash';\nimport { InteractionGroups, RigidBody } from '@dimforge/rapier3d-compat';\nimport { CollisionPayload } from '@react-three/rapier';\n\nconst DEFAULT_SPEED = 100;\nconst DEFAULT_DURATION = 1000;\nconst DEFAULT_SCALE = 1;\nconst DEFAULT_FLASH_DURATION = 100;\n\ninterface BulletEffectControllerProps {\n  config: { [key: string]: any };\n  collisionGroups?: InteractionGroups;\n  owner?: RigidBody;\n  onHit?: (payload: CollisionPayload) => void;\n  onComplete?: () => void;\n}\n\nexport interface BulletEffectConfig {\n  startPosition: THREE.Vector3;\n  direction: THREE.Vector3;\n  speed?: number;\n  duration?: number;\n  scale?: number;\n  color?: string;\n  flashDuration?: number;\n}\n\nconst parseConfig = (config: { [key: string]: any }) => {\n  return {\n    startPosition: new THREE.Vector3(...config.startPosition),\n    direction: new THREE.Vector3(...config.direction),\n    speed: (config.speed as number) || DEFAULT_SPEED,\n    duration: (config.duration as number) || DEFAULT_DURATION,\n    scale: (config.scale as number) || DEFAULT_SCALE,\n    color: config.color,\n    flashDuration: config.flashDuration === undefined ? DEFAULT_FLASH_DURATION : config.flashDuration,\n  };\n};\n\nconst BulletEffectController: React.FC<BulletEffectControllerProps> = ({ config, collisionGroups, owner, onHit, onComplete }) => {\n  const { startPosition, direction, speed, duration, scale, flashDuration, color } = parseConfig(config);\n  if (!startPosition || !direction || !speed || !duration) {\n    console.error('[BulletEffectController] Missing required config properties');\n    onComplete?.();\n    return null;\n  }\n\n  const calcStartPosition = startPosition.clone().add(direction.clone().multiplyScalar(1));\n\n  return (\n    <>\n      <Bullet\n        startPosition={calcStartPosition}\n        direction={direction}\n        color={color}\n        scale={scale}\n        speed={speed}\n        duration={duration}\n        collisionGroups={collisionGroups}\n        owner={owner}\n        onHit={onHit}\n        onComplete={onComplete}\n      />\n      {flashDuration > 0 && (\n        <MuzzleFlash\n          config={{\n            position: calcStartPosition.toArray(),\n            direction: direction.toArray(),\n            duration: flashDuration,\n          }}\n        />\n      )}\n    </>\n  );\n};\n\nexport default BulletEffectController;\n",
    isBinary: false,
  },
  'src/components/r3f/effects/Explosion.tsx': {
    type: 'file',
    content:
      "import * as THREE from 'three';\nimport React, { useRef, useMemo, useState } from 'react';\nimport { useFrame } from '@react-three/fiber';\n\nconst DEFAULT_SCALE = 1;\n\ninterface ExplosionProps {\n  config: { [key: string]: any };\n  onComplete?: () => void;\n}\n\n// Utility to convert Vector3 array to THREE.Vector3 (needed for rendering)\nconst arrayToVec = (arr?: [number, number, number]): THREE.Vector3 => {\n  if (!arr) {\n    console.error('Missing required config properties');\n    return new THREE.Vector3();\n  }\n  return new THREE.Vector3(arr[0], arr[1], arr[2]);\n};\n\nconst parseConfig = (config: { [key: string]: any }) => {\n  return {\n    position: arrayToVec(config.position),\n    scale: config.scale || DEFAULT_SCALE,\n  };\n};\n\nfunction makeParticles(color: string, speed: number) {\n  // data: [position Vector3, movement direction Vector3]\n  const data = new Array(20).fill(null).map(() => {\n    const position = new THREE.Vector3();\n    const direction = new THREE.Vector3(-1 + Math.random() * 2, -1 + Math.random() * 2, -1 + Math.random() * 2).normalize().multiplyScalar(speed);\n    return [position, direction] as [THREE.Vector3, THREE.Vector3];\n  });\n\n  return { color, data };\n}\n\n// \"Explosion/smoke\" effect appearing at the collision point\nconst Explosion: React.FC<ExplosionProps> = ({ config, onComplete }) => {\n  const groupRef = useRef<THREE.Group>(null);\n  // Reusable dummy object\n  const dummy = useMemo(() => new THREE.Object3D(), []);\n\n  // Explosion particle array (2 types with different color/speed)\n  const [particleGroups] = useState(() => [makeParticles('white', 0.1), makeParticles('grey', 0.1)]);\n\n  // \"Total lifespan\" of the explosion/smoke (in ms)\n  const totalDuration = 500;\n  const startTime = useRef(performance.now());\n\n  const { position, scale } = parseConfig(config);\n\n  useFrame(() => {\n    const elapsed = performance.now() - startTime.current;\n    const fadeOut = elapsed / totalDuration; // 0 ~ 1\n\n    // Iterate particle groups\n    particleGroups.forEach((pg, groupIndex) => {\n      // instancedMesh reference\n      const mesh = groupRef.current?.children[groupIndex] as THREE.InstancedMesh;\n      if (!mesh) return;\n\n      // Move individual particles\n      pg.data.forEach(([pos, dir], i) => {\n        // Continuously adding dir results in spreading out\n        pos.add(dir);\n        dummy.position.copy(pos);\n        dummy.updateMatrix();\n        mesh.setMatrixAt(i, dummy.matrix);\n      });\n\n      // Reduce material opacity\n      if (mesh.material instanceof THREE.MeshBasicMaterial) {\n        mesh.material.opacity = Math.max(1 - fadeOut, 0);\n      }\n\n      mesh.instanceMatrix.needsUpdate = true;\n    });\n\n    // Trigger removal from parent when lifespan ends\n    if (elapsed > totalDuration) {\n      onComplete?.();\n    }\n  });\n\n  if (!position || !scale) {\n    console.error('[Explosion] Missing required config properties');\n    onComplete?.();\n    return null;\n  }\n\n  return (\n    <group ref={groupRef} position={position} scale={scale}>\n      {particleGroups.map((pg, index) => (\n        <instancedMesh\n          key={index}\n          args={[undefined, undefined, pg.data.length]}\n          frustumCulled={false} // Display even if outside camera frustum\n        >\n          <dodecahedronGeometry args={[1, 0]} />\n          <meshBasicMaterial\n            color={pg.color}\n            transparent\n            opacity={1}\n            depthWrite={false} // Make it look like smoke\n          />\n        </instancedMesh>\n      ))}\n    </group>\n  );\n};\n\nexport default Explosion;\n",
    isBinary: false,
  },
  'src/components/r3f/effects/MuzzleFlash.tsx': {
    type: 'file',
    content:
      "import React, { useState, useEffect, useMemo } from 'react';\nimport * as THREE from 'three';\nimport { useFrame } from '@react-three/fiber';\n\n// --- Muzzle Flash Configuration ---\nconst FLASH_PETAL_COUNT = 5; // Number of flame petals\nconst FLASH_PETAL_LENGTH = 0.4; // Length of each petal\nconst FLASH_PETAL_BASE_RADIUS = 0.03; // Base radius of each petal\nconst FLASH_RADIAL_SEGMENTS = 4; // Number of radial segments for each cone\nconst FLASH_TILT_ANGLE = Math.PI / 4; // Tilt angle of flame petals (45 degrees)\nconst FLASH_INNER_GLOW_SIZE = 0.08; // Size of the center glow\nconst FLASH_COLOR = '#FFA500'; // Orange color\nconst FLASH_INNER_COLOR = '#FFFF55'; // Brighter yellow for center\nconst FLASH_DEFAULT_DURATION = 100; // Default duration\n// ------------------------\n\ninterface MuzzleFlashProps {\n  config: { [key: string]: any };\n  onComplete?: () => void;\n}\n\n// Utility to convert Vector3 array to THREE.Vector3 (needed for rendering)\nconst arrayToVec = (arr?: [number, number, number]): THREE.Vector3 => {\n  if (!arr) {\n    console.error('Missing required config properties');\n    return new THREE.Vector3();\n  }\n  return new THREE.Vector3(arr[0], arr[1], arr[2]);\n};\n\nconst parseConfig = (config: { [key: string]: any }) => {\n  return {\n    position: arrayToVec(config.position as [number, number, number]),\n    direction: arrayToVec(config.direction as [number, number, number]),\n    duration: (config.duration as number) || FLASH_DEFAULT_DURATION,\n  };\n};\n\nconst MuzzleFlash: React.FC<MuzzleFlashProps> = ({ config, onComplete }) => {\n  const { position, direction, duration } = parseConfig(config);\n\n  const [visible, setVisible] = useState(true);\n  const startTime = useMemo(() => Date.now(), []); // Record creation time (for animation)\n\n  // Calculate rotation based on direction\n  const flashQuaternion = useMemo(() => {\n    const quaternion = new THREE.Quaternion();\n    const normalizedDirection = direction.clone().normalize();\n    // Rotate the group whose default direction is Z-axis (0,0,1) to the firing direction\n    quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), normalizedDirection);\n    return quaternion;\n  }, [direction]);\n\n  // --- Muzzle Flash Related Memos ---\n  const petalGeometry = useMemo(() => new THREE.ConeGeometry(FLASH_PETAL_BASE_RADIUS, FLASH_PETAL_LENGTH, FLASH_RADIAL_SEGMENTS), []);\n  const petalMaterial = useMemo(\n    () =>\n      new THREE.MeshBasicMaterial({\n        color: FLASH_COLOR,\n        blending: THREE.AdditiveBlending,\n        transparent: true,\n        opacity: 0.8,\n        depthWrite: false,\n      }),\n    [],\n  );\n  const innerGlowGeometry = useMemo(() => new THREE.SphereGeometry(FLASH_INNER_GLOW_SIZE, 16, 8), []);\n  const innerGlowMaterial = useMemo(\n    () =>\n      new THREE.MeshBasicMaterial({\n        color: FLASH_INNER_COLOR,\n        blending: THREE.AdditiveBlending,\n        transparent: true,\n        opacity: 1.0,\n        depthWrite: false,\n      }),\n    [],\n  );\n  // --- End of Muzzle Flash Related Memos ---\n\n  // Auto-destruction timer\n  useEffect(() => {\n    const timer = setTimeout(() => {\n      setVisible(false);\n      if (onComplete) onComplete();\n    }, duration);\n\n    return () => clearTimeout(timer);\n  }, [duration, onComplete]); // Timer reset when id or onComplete function changes\n\n  // Opacity animation\n  useFrame(() => {\n    if (!visible) return;\n    const elapsed = Date.now() - startTime;\n    const progress = Math.min(elapsed / duration, 1);\n    const opacity = 1.0 - progress; // Opacity decreases over time\n\n    petalMaterial.opacity = opacity * 0.8;\n    innerGlowMaterial.opacity = opacity;\n  });\n\n  if (!position || !direction || !duration) {\n    console.error('[MuzzleFlash] Missing required config properties');\n    return null;\n  }\n\n  if (!visible) return null; // Don't render if not visible\n\n  return (\n    <group position={position} quaternion={flashQuaternion}>\n      {/* Center glow */}\n      <mesh geometry={innerGlowGeometry} material={innerGlowMaterial} />\n\n      {/* Flame petals (using ConeGeometry with tilt applied) */}\n      {Array.from({ length: FLASH_PETAL_COUNT }).map((_, i) => {\n        const radialAngle = (i / FLASH_PETAL_COUNT) * Math.PI * 2;\n        return (\n          <group key={i} rotation={[0, 0, radialAngle]}>\n            <group rotation={[FLASH_TILT_ANGLE, 0, 0]}>\n              <mesh geometry={petalGeometry} material={petalMaterial} position={[0, FLASH_PETAL_LENGTH / 2, 0]} />\n            </group>\n          </group>\n        );\n      })}\n    </group>\n  );\n};\n\nexport default MuzzleFlash;\n",
    isBinary: false,
  },
} as FileMap;

export const TEMPLATE_3D_BASIC_SIDEVIEW = {
  'README.md': {
    type: 'file',
    content:
      "# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n",
    isBinary: false,
  },
  'tsconfig.node.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",\n    "target": "ES2022",\n    "lib": ["ES2023"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["vite.config.ts"]\n}\n',
    isBinary: false,
  },
  '.gitignore': {
    type: 'file',
    content:
      '# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n',
    isBinary: false,
  },
  'package.json': {
    type: 'file',
    content:
      '{\n  "name": "sideview",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "lint": "eslint .",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@agent8/gameserver": "^1.5.3",\n    "vibe-starter-3d": "^0.8.18",\n    "@react-three/drei": "9.122.0",\n    "@react-three/fiber": "8.18.0",\n    "@react-three/postprocessing": "2.19.1",\n    "@react-three/rapier": "1.5.0",\n    "@dimforge/rapier3d-compat": "0.14.0",\n    "nipplejs": "0.10.2",\n    "lucide-react": "0.482.0",\n    "react": "18.3.1",\n    "react-dom": "18.3.1",\n    "three": "0.174.0",\n    "three-stdlib": "2.35.14",\n    "zustand": "5.0.3"\n  },\n  "devDependencies": {\n    "@types/react": "^18.3.1",\n    "@types/react-dom": "^18.3.1",\n    "@types/three": "^0.174.0",\n    "@vitejs/plugin-react": "^4.3.4",\n    "autoprefixer": "^10.4.21",\n    "globals": "^16.0.0",\n    "tailwindcss": "^3.4.1",\n    "typescript": "~5.8.2",\n    "vite": "^6.2.2"\n  }\n}\n',
    isBinary: false,
  },
  'index.html': {
    type: 'file',
    content:
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + React + TS</title>\n    <style>\n      body {\n        margin: 0;\n        padding: 0;\n        font-family: Arial, sans-serif;\n      }\n      .loading-container {\n        position: fixed;\n        inset: 0;\n        z-index: 50;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background-color: black;\n        color: white;\n      }\n      .loading-title {\n        font-size: 1.5rem;\n        font-weight: bold;\n        margin-bottom: 1rem;\n      }\n      .spinner {\n        width: 30px;\n        height: 30px;\n        border: 3px solid rgba(255, 255, 255, 0.3);\n        border-radius: 50%;\n        border-top-color: white;\n        animation: spin 1s ease-in-out infinite;\n      }\n      @keyframes spin {\n        to {\n          transform: rotate(360deg);\n        }\n      }\n    </style>\n    <script>\n      (function () {\n        function reportGameSize() {\n          const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n\n          const width = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n\n          window.parent.postMessage(\n            {\n              type: \'GAME_SIZE_RESPONSE\',\n              height: height,\n              width: width,\n            },\n            \'*\',\n          );\n        }\n\n        window.addEventListener(\'load\', reportGameSize);\n\n        window.addEventListener(\'resize\', reportGameSize);\n\n        window.addEventListener(\'message\', function (event) {\n          if (event.data && event.data.type === \'REQUEST_GAME_SIZE\') {\n            reportGameSize();\n          }\n        });\n      })();\n    </script>\n  </head>\n  <body>\n    <div id="root">\n      <div class="loading-container">\n        <h2 class="loading-title">Loading</h2>\n        <div class="spinner"></div>\n      </div>\n    </div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    isBinary: false,
  },
  'tsconfig.json': {
    type: 'file',
    content:
      '{\n  "files": [],\n  "references": [\n    { "path": "./tsconfig.app.json" },\n    { "path": "./tsconfig.node.json" }\n  ]\n}\n',
    isBinary: false,
  },
  'tailwind.config.js': {
    type: 'file',
    content:
      '/** @type {import(\'tailwindcss\').Config} */\nexport default {\n  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n',
    isBinary: false,
  },
  'PROJECT.md': {
    type: 'file',
    content:
      "# 3D Side View Game\n\n## Project Summary\n\nThis project is a 3D platformer game with a side-scrolling perspective, similar to classic 2D platformers but with 3D graphics. Players control a character that can run, jump, and perform various actions while navigating through a procedurally generated terrain of platforms. The game features character animations, physics-based movement, and jump mechanics that are essential for platformer gameplay. This project is intended for single-player gameplay with an emphasis on platform jumping and character control.\n\n## Implementation Strategy\n\nThis game uses a **Three.js-based 3D approach**:\n\n- React Three Fiber for 3D rendering in a React environment\n- @react-three/rapier for physics simulation and collision detection\n- vibe-starter-3d library for character rendering and animation\n- Side view camera setup providing a classic platformer perspective\n- Seed-based procedural generation for platform layouts\n\nKey technologies:\n\n- Three.js - 3D rendering\n- React Three Fiber - React integration\n- @react-three/rapier - Physics simulation\n- @react-three/drei - Useful Three.js helpers\n- vibe-starter-3d (v0.4.0) - Advanced character rendering, animation, and physics integration\n- Tailwind CSS - UI composition\n- Zustand - State management\n\n## Core Features\n\n- **Advanced Character System**: Comprehensive character rendering with physics-based rigid body integration\n- **Animation Management**: Complete animation system supporting idle, run, sprint, jump, punch, kick, normal_attack, cast, and other character states\n- **Physics Integration**: Full physics simulation with collision detection, gravity, and rigid body object type definitions\n- **Side View Camera**: Fixed side-view perspective with character following and configurable camera distance for optimal platformer experience\n- **Platformer Mechanics**: Specialized jumping mechanics and gravity-based movement essential for platformer gameplay\n- **Procedural Platform Generation**: Seed-based randomization system creating variable platform heights and gaps for challenging gameplay\n- **Interactive Controls**: Keyboard-based navigation (WASD for movement, QERF for actions) with mouse interaction support\n- **Environmental Collision**: Advanced collision detection system for platform interactions and environmental boundaries\n- **State Management**: Robust character state transitions and player reference tracking for multiplayer readiness\n- **Asset Management**: Comprehensive preloading system with progress indication for smooth gameplay\n- **3D Rendering**: High-quality 3D model rendering with smooth animation transitions optimized for platformer gameplay\n\n## File Structure Overview\n\n### `src/main.tsx`\n\n- Entry point for the application.\n- Sets up React rendering and mounts the `App` component.\n\n### `src/App.tsx`\n\n- Main application component.\n- Configures the overall layout and includes the `GameScene` component.\n- Manages loading state and switches between `PreloadScene` and `GameScene`.\n\n### `src/App.css`\n\n- Defines the main styles for the `App` component and its child UI elements.\n\n### `src/index.css`\n\n- Defines global base styles, Tailwind CSS directives, fonts, etc., applied throughout the application.\n\n### `src/assets.json`\n\n- File for managing asset metadata. Includes character model and animation information.\n\n### `src/stores/`\n\n- Directory containing state management stores using Zustand.\n  - **`gameStore.ts`**: Store that manages the overall game state. Tracks and controls the readiness state of the map physics system (`isMapPhysicsReady`). This state is used to determine physics simulation pause/resume and loading screen display.\n  - **`localPlayerStore.ts`**: Store that manages the local player's state, such as position tracking.\n  - **`multiPlayerStore.ts`**: Store that manages multiple connected players' rigid body references for multiplayer functionality, including registration, unregistration, and retrieval of player references.\n  - **`playerActionStore.ts`**: Store that manages player action states including combat actions (punch, kick, meleeAttack, cast) with support for setting, getting, and resetting action states.\n\n### `src/constants/`\n\n- Directory defining constant values used throughout the application.\n  - **`controls.ts`**: Defines settings that map keyboard inputs (WASD, arrow keys, etc.) to corresponding actions (movement, jump, etc.).\n  - **`character.ts`**: Defines character-related constants (animation states, speed, etc.).\n  - **`rigidBodyObjectType.ts`**: Defines physics object types for collision detection and interaction systems.\n\n### Components\n\n### `src/components/`\n\n- Directory managing React components categorized by function.\n\n  - **`r3f/`**: Contains 3D components related to React Three Fiber.\n\n    - **`Experience.tsx`**: Main component responsible for the primary 3D scene configuration. Includes lighting `ambientLight`, environmental elements `Environment`, the `Player` component, and the floor `Floor`. It renders the core visual and interactive elements within the physics simulation configured in `GameScene.tsx`.\n    - **`Floor.tsx`**: Component defining and visually representing the ground plane in the 3D space. Has physical properties and implements procedurally generated platforms for the platformer gameplay.\n    - **`GameSceneCanvas.tsx`**: React Three Fiber Canvas component that renders the 3D game world with physics simulation and controller setup.\n    - **`MapPhysicsReadyChecker.tsx`**: Component that checks if the map physics system is ready by performing raycasting from above downward to detect map geometry and ensures physics interactions are properly initialized before gameplay begins. Performs checks every frame until valid map geometry is detected, with a timeout after 180 frames to prevent infinite checking. Excludes Capsule shapes (likely characters/objects) and sensor colliders from the inspection.\n    - **`Player.tsx`**: Advanced player component integrating RigidBodyPlayer with CharacterRenderer for comprehensive character management, physics interactions, and animation state management with collision detection capabilities optimized for platformer gameplay.\n\n  - **`scene/`**: Contains components related to scene setup.\n\n    - **`GameScene.tsx`**: Main game scene component that serves as a layout container arranging the game UI and 3D Canvas. Contains critical performance warnings and guidelines to prevent re-rendering issues. Includes the `GameSceneCanvas` and `GameSceneUI` components in a proper layered structure where the Canvas renders the 3D world and UI components render as overlays.\n    - **`PreloadScene.tsx`**: Manages asset preloading before the game starts. Loads all assets defined in assets.json (models, textures, etc.) and displays a loading progress bar. Ensures all assets are loaded before the game begins.\n\n  - **`ui/`**: Contains UI components for the game interface.\n    - **`GameSceneUI.tsx`**: Component that manages UI overlays for the game scene.\n    - **`LoadingScreen.tsx`**: Loading screen component displayed during game loading.\n    - **`InputController.tsx`**: Manages all input handling including keyboard, mouse, and touch controls with virtual joystick support for mobile devices and action buttons for combat actions (punch, kick, cast) and movement controls.\n\n### Key Libraries & Components from External Sources\n\n- **`vibe-starter-3d`**: A library providing foundational 3D game components and utilities.\n  - **`SideViewController`**: Wraps the player character and manages side view navigation by implementing a character controller with physics. It handles character movement, jumping mechanics, and camera following with a fixed side-view perspective.\n  - **`CharacterRenderer`**: Renders 3D character models with animations from glTF/GLB files. Manages animation states and transitions based on player actions.\n  - **`useControllerState`**: A React hook that provides control state management for the character, including:\n    - `setEnableInput`: Function to enable/disable player input controls\n    - `rigidBody`: Reference to the physics body for the character\n  - **`useMouseControls`**: A React hook that provides access to mouse input state (left/right buttons and positions).\n\n### Side View System Implementation\n\nThe side view platformer system is implemented through a combination of components:\n\n1. **Controller System**: `SideViewController` from the vibe-starter-3d library handles the physics-based movement of the character based on keyboard inputs, implementing platformer mechanics like jumping and gravity with a fixed camera angle that provides the side view perspective and configurable camera distance.\n\n2. **Input Management**: Keyboard inputs are captured through React Three Fiber's `useKeyboardControls` hook, which maps WASD/arrow keys to movement actions (with special emphasis on jump controls essential for platformer gameplay), with mouse controls for additional interactions.\n\n3. **State Management**: `useControllerState` hook provides shared state between components, allowing different parts of the application to access and modify the character's state. Additionally, `playerStore` manages physics body references for multiplayer support.\n\n4. **Animation Management**: `Player` component with `RigidBodyPlayer` integration determines appropriate animations based on movement and action states, with special attention to jump, fall, and landing animations essential for platformer games, including full collision detection capabilities.\n\n5. **Platform Generation**: Procedurally generated platforms create the game environment, with varying heights and distances to create challenging platforming gameplay.\n\n6. **Asset Management**: `PreloadScene` component ensures all 3D models, textures, and other assets are preloaded before gameplay begins, providing a smooth user experience with a visual loading indicator.\n",
    isBinary: false,
  },
  'postcss.config.js': {
    type: 'file',
    content: 'export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n',
    isBinary: false,
  },
  'vite.config.ts': {
    type: 'file',
    content:
      'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"],\n  },\n  base: "./",\n  build: {\n    outDir: "dist",\n  },\n});\n',
    isBinary: false,
  },
  'tsconfig.app.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",\n    "target": "ES2020",\n    "useDefineForClassFields": true,\n    "lib": ["ES2020", "DOM", "DOM.Iterable"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n    "jsx": "react-jsx",\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["src"]\n}\n',
    isBinary: false,
  },
  'public/vite.svg': {
    type: 'file',
    content:
      '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>',
    isBinary: false,
  },
  'docs/project-3d-rules.md': {
    type: 'file',
    content:
      "# 3D Project Development Rules\n\n## Guideline for Using `RigidBodyObject`\n\nWhen implementing physics interactions, it is mandatory to use the `RigidBodyObject` component from the `vibe-starter-3d` package instead of the standard `RigidBody` from `@react-three/rapier`.\n\nThe primary reason for this is to simplify event handling for collisions and intersections. Using the standard `RigidBody` component requires managing a complex set of events (`onCollisionEnter`, `onCollisionExit`, `onIntersectionEnter`, `onIntersectionExit`).\n\nIn contrast, `RigidBodyObject` abstracts this complexity. It allows you to handle all physics-based interactions uniformly through just two simple trigger events: `onTriggerEnter` and `onTriggerExit`. This makes the interaction logic significantly cleaner and easier to manage.\n\n## Canvas Component Structure Rules\n\n**Core Requirement:** Components that render HTML tags (e.g., `<div>`, `<button>`) must NEVER be placed inside React Three Fiber's `<Canvas>` component.\n\n**Reasoning:**\nThis is a core architectural rule. Placing standard HTML inside the `<Canvas>` WebGL context will cause rendering errors.\n\n**Implementation Guidelines:**\n\n- **UI Components:** Components using HTML tags belong in the `src/components/ui/` directory. They must be rendered as an overlay, outside the `<Canvas>`.\n- **3D Components:** Only Three.js-related components, located in `src/components/r3f/`, should be placed inside the `<Canvas>`.\n\n**Correct Structure Example:**\n\n```tsx\n// ‚úÖ Correct approach\n<div>\n  {/* The 3D scene is rendered inside the Canvas */}\n  <Canvas>\n    <Player />\n    <Floor />\n  </Canvas>\n\n  {/* UI components are rendered as overlays outside the Canvas */}\n  <Crosshair />\n  <LoadingScreen />\n</div>\n```\n\n**Incorrect Structure Example:**\n\n```tsx\n// ‚ùå Incorrect approach\n<Canvas>\n  <Player />\n  {/* This is forbidden, as Crosshair renders HTML */}\n  <Crosshair />\n</Canvas>\n```\n",
    isBinary: false,
  },
  'src/App.tsx': {
    type: 'file',
    content:
      "import React, { useState } from 'react';\nimport './App.css';\nimport GameScene from './components/scene/GameScene';\nimport PreloadScene from './components/scene/PreloadScene';\n\nconst App: React.FC = () => {\n  const [isLoading, setIsLoading] = useState(true);\n\n  const handleLoadingComplete = () => {\n    setIsLoading(false);\n  };\n\n  return <div style={{ width: '100vw', height: '100vh' }}>{isLoading ? <PreloadScene onComplete={handleLoadingComplete} /> : <GameScene />}</div>;\n};\n\nexport default App;\n",
    isBinary: false,
  },
  'src/index.css': {
    type: 'file',
    content: '@tailwind base;\n@tailwind components;\n@tailwind utilities;\n',
    isBinary: false,
  },
  'src/App.css': {
    type: 'file',
    content: '#root {\n  margin: 0 auto;\n  text-align: center;\n}\n',
    isBinary: false,
  },
  'src/vite-env.d.ts': {
    type: 'file',
    content: '/// <reference types="vite/client" />\n',
    isBinary: false,
  },
  'src/assets.json': {
    type: 'file',
    content:
      '{\n  "characters": {\n    "base-model": {\n      "url": "https://agent8-games.verse8.io/assets/3d/characters/realistic style/base-model.glb"\n    }\n  },\n  "animations": {\n    "idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle.glb",\n      "description": "Idle"\n    },\n    "idle-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle-00.glb",\n      "description": "Idle 00"\n    },\n    "idle-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle-01.glb",\n      "description": "Idle 01"\n    },\n    "rifle-idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/rifle-idle.glb",\n      "description": "Rifle idle"\n    },\n    "pistol-idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/pistol-idle.glb",\n      "description": "Pistol idle"\n    },\n    "walk": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/walk.glb",\n      "description": "Walk"\n    },\n    "run-medium": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/run-medium.glb",\n      "description": "Run Medium"\n    },\n    "run-fast": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/run-fast.glb",\n      "description": "Run Fast"\n    },\n    "rifle-run": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/rifle-run.glb",\n      "description": "Rifle Run"\n    },\n    "pistol-run": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/pistol-run.glb",\n      "description": "Pistol Run"\n    },\n    "jump": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/jump.glb",\n      "description": "Jump"\n    },\n    "swim": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/swim.glb",\n      "description": "Swim"\n    },\n    "punch-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/punch-00.glb",\n      "description": "Punch 00"\n    },\n    "punch-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/punch-01.glb",\n      "description": "Punch 01"\n    },\n    "kick-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-00.glb",\n      "description": "Kick 00"\n    },\n    "kick-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-01.glb",\n      "description": "Kick 01"\n    },\n    "kick-02": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-02.glb",\n      "description": "Kick 02"\n    },\n    "melee-attack": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/melee-attack.glb",\n      "description": "Melee Attack"\n    },\n    "cast": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/cast.glb",\n      "description": "Cast"\n    },\n    "dance-locking": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/dance-locking.glb",\n      "description": "Dance Locking"\n    },\n    "dance-wave": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/dance-wave.glb",\n      "description": "Dance Wave"\n    },\n    "death-backward": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/death-backward.glb",\n      "description": "Death Backward"\n    },\n    "death-foward": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/death-foward.glb",\n      "description": "Death Foward"\n    },\n    "hit-to-body": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/hit-to-body.glb",\n      "description": "Hit to Body"\n    }\n  }\n}\n',
    isBinary: false,
  },
  'src/main.tsx': {
    type: 'file',
    content:
      "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport './index.css';\nimport App from './App.tsx';\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n",
    isBinary: false,
  },
  'src/stores/multiPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport React from 'react';\nimport { RigidBody } from '@dimforge/rapier3d-compat';\n\ntype MultiPlayerRigidBodyState = {\n  connectedPlayerRefs: Record<string, React.RefObject<RigidBody>>;\n  registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => void;\n  unregisterConnectedPlayer: (account: string) => void;\n  getConnectedPlayerRef: (account: string) => React.RefObject<RigidBody> | undefined;\n  getAllConnectedPlayerRefs: () => Record<string, React.RefObject<RigidBody>>;\n  getConnectedPlayerCount: () => number;\n};\n\nexport const useMultiPlayerStore = create<MultiPlayerRigidBodyState>()(\n  subscribeWithSelector((set, get) => ({\n    connectedPlayerRefs: {},\n\n    registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => {\n      set((state) => ({\n        connectedPlayerRefs: {\n          ...state.connectedPlayerRefs,\n          [account]: rigidBodyRef,\n        },\n      }));\n    },\n\n    unregisterConnectedPlayer: (account: string) => {\n      set((state) => {\n        const newConnectedPlayerRefs = { ...state.connectedPlayerRefs };\n        delete newConnectedPlayerRefs[account];\n        return { connectedPlayerRefs: newConnectedPlayerRefs };\n      });\n    },\n\n    getConnectedPlayerRef: (account: string) => {\n      return get().connectedPlayerRefs[account];\n    },\n\n    getAllConnectedPlayerRefs: () => {\n      return get().connectedPlayerRefs;\n    },\n\n    getConnectedPlayerCount: () => {\n      return Object.keys(get().connectedPlayerRefs).length;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/playerActionStore.ts': {
    type: 'file',
    content:
      'interface PlayerActionState {\n  punch: boolean;\n  kick: boolean;\n  meleeAttack: boolean;\n  cast: boolean;\n}\n\ninterface PlayerActionStore extends PlayerActionState {\n  setPlayerAction: (action: string, pressed: boolean) => void;\n  getPlayerAction: (action: string) => boolean;\n  resetAllPlayerActions: () => void;\n}\n\nconst playerActionStore: PlayerActionStore = {\n  punch: false,\n  kick: false,\n  meleeAttack: false,\n  cast: false,\n\n  setPlayerAction: (action: string, pressed: boolean) => {\n    (playerActionStore as any)[action] = pressed;\n  },\n\n  getPlayerAction: (action: string): boolean => {\n    return (playerActionStore as any)[action];\n  },\n\n  resetAllPlayerActions: () => {\n    playerActionStore.punch = false;\n    playerActionStore.kick = false;\n    playerActionStore.meleeAttack = false;\n    playerActionStore.cast = false;\n  },\n};\n\nexport const usePlayerActionStore = () => playerActionStore;',
    isBinary: false,
  },
  'src/stores/localPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport * as THREE from 'three';\n\ntype PlayerState = {\n  position: THREE.Vector3;\n  speed: number;\n};\n\ntype LocalPlayerState = {\n  state: PlayerState;\n  setSpeed: (speed: number) => void;\n  setPosition: (x: number, y: number, z: number) => void;\n  clearPosition: () => void;\n};\n\nexport const useLocalPlayerStore = create<LocalPlayerState>()(\n  subscribeWithSelector((_, get) => ({\n    state: {\n      position: new THREE.Vector3(0, 0, 0),\n      speed: 0,\n    },\n\n    setSpeed: (speed: number) => {\n      get().state.speed = speed;\n    },\n\n    setPosition: (x: number, y: number, z: number) => {\n      const state = get().state;\n      state.position.x = x;\n      state.position.y = y;\n      state.position.z = z;\n    },\n\n    clearPosition: () => {\n      const state = get().state;\n      state.position.x = 0;\n      state.position.y = 0;\n      state.position.z = 0;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/gameStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\ninterface GameStore {\n  isMapPhysicsReady: boolean;\n  setMapPhysicsReady: (ready: boolean) => void;\n}\n\nexport const useGameStore = create<GameStore>()(\n  subscribeWithSelector((set) => ({\n    isMapPhysicsReady: false,\n    setMapPhysicsReady: (ready: boolean) => set({ isMapPhysicsReady: ready }),\n  })),\n);\n",
    isBinary: false,
  },
  'src/constants/rigidBodyObjectType.ts': {
    type: 'file',
    content:
      "export const RigidBodyObjectType = {\n  /** Local Player */\n  LOCAL_PLAYER: 'LOCAL_PLAYER',\n  /** Enemy */\n  ENEMY: 'ENEMY',\n  /** Monster */\n  MONSTER: 'MONSTER',\n  /** Wall */\n  WALL: 'WALL',\n  /** Obstacle */\n  OBSTACLE: 'OBSTACLE',\n  /** Item */\n  ITEM: 'ITEM',\n  /** Bullet */\n  BULLET: 'BULLET',\n  /** Floor */\n  FLOOR: 'FLOOR',\n  /** Floating board */\n  PLOTTING_BOARD: 'PLOTTING_BOARD',\n} as const;\n",
    isBinary: false,
  },
  'src/constants/character.ts': {
    type: 'file',
    content:
      "import { AnimationType } from 'vibe-starter-3d';\n\nexport const CharacterState: { [key: string]: AnimationType } = {\n  /** IDLE ACTION */\n  IDLE: 'IDLE',\n  /** IDLE ACTION */\n  IDLE_01: 'IDLE_01',\n  /** WALKING ACTION */\n  WALK: 'WALK',\n  /** RUNNING ACTION */\n  RUN: 'RUN',\n  /** SPRINTING ACTION */\n  FAST_RUN: 'FAST_RUN',\n  /** JUMP ACTION */\n  JUMP: 'JUMP',\n  /** PUNCH ACTION */\n  PUNCH: 'PUNCH',\n  /** PUNCH ACTION */\n  PUNCH_01: 'PUNCH_01',\n  /** KICK ACTION */\n  KICK: 'KICK',\n  /** KICK ACTION */\n  KICK_01: 'KICK_01',\n  /** KICK ACTION */\n  KICK_02: 'KICK_02',\n  /** MELEE ATTACK ACTION */\n  MELEE_ATTACK: 'MELEE_ATTACK',\n  /** CAST ACTION */\n  CAST: 'CAST',\n  /** HIT ACTION */\n  HIT: 'HIT',\n  /** DIE ACTION */\n  DIE: 'DIE',\n};\n\nexport type CharacterState = (typeof CharacterState)[keyof typeof CharacterState];\n",
    isBinary: false,
  },
  'src/components/r3f/MapPhysicsReadyChecker.tsx': {
    type: 'file',
    content:
      "import { useFrame } from '@react-three/fiber';\nimport { useRapier } from '@react-three/rapier';\nimport { useRef } from 'react';\nimport * as THREE from 'three';\nimport { useGameStore } from '../../stores/gameStore';\n\n/**\n * Component that checks if the map physics is ready by performing raycasting.\n * Casts a ray downward from above to detect map geometry and ensures physics\n * interactions are properly initialized before gameplay begins.\n *\n * - Performs checks every frame until map physics is confirmed ready\n * - Times out after 60 frames as fallback to prevent infinite checking\n * - Excludes Capsule shapes (likely characters/objects) and sensor colliders\n * - Sets mapPhysicsReady to true once valid map geometry is detected\n */\nfunction MapPhysicsReadyChecker() {\n  const { isMapPhysicsReady, setMapPhysicsReady } = useGameStore();\n  const physicsCheckCount = useRef(0);\n  const { rapier, world } = useRapier();\n\n  useFrame(() => {\n    if (isMapPhysicsReady) return;\n\n    physicsCheckCount.current++;\n    if (physicsCheckCount.current > 180) {\n      setMapPhysicsReady(true);\n      return;\n    }\n\n    const origin = new THREE.Vector3(0, 50, 0);\n    const downDirection = new THREE.Vector3(0, -1, 0);\n    const ray = new rapier.Ray(origin, downDirection);\n\n    // Get all intersections and find the first non-sensor collider\n    const intersections: any[] = [];\n    world.propagateModifiedBodyPositionsToColliders();\n    world.updateSceneQueries();\n    world.intersectionsWithRay(ray, 100, true, (intersection) => {\n      // Exclude Capsule shapes as they are unlikely to be map colliders\n      if (intersection.collider.shape.type === rapier.ShapeType.Capsule) {\n        return true;\n      }\n      intersections.push(intersection);\n      return true; // continue searching\n    });\n\n    // Find the first non-sensor collider\n    const validHit = intersections.find((intersection) => !intersection.collider.isSensor());\n    if (!validHit) return;\n\n    console.log('%c[vibe-starter-3d]%c Map physics initialized.', 'color: #7159c1; font-weight: bold', 'color: inherit;');\n    setMapPhysicsReady(true);\n  });\n\n  return null;\n}\n\nexport default MapPhysicsReadyChecker;\n",
    isBinary: false,
  },
  'src/components/r3f/GameSceneCanvas.tsx': {
    type: 'file',
    content:
      "import React, { Suspense } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { Physics } from '@react-three/rapier';\nimport Experience from '../r3f/Experience';\nimport { FollowLight, SideViewController } from 'vibe-starter-3d';\nimport { useGameStore } from '../../stores/gameStore';\nimport MapPhysicsReadyChecker from '../r3f/MapPhysicsReadyChecker';\n\n/**\n * Game Scene Canvas Component\n *\n * This component is responsible for rendering the entire 3D game world using React Three Fiber.\n * It serves as the root container for all 3D elements, physics simulation, and game interactions.\n */\nconst GameSceneCanvas = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* ‚ö†Ô∏è DO NOT DELETE: Core Canvas component for React Three Fiber */}\n      <Canvas shadows>\n        <Physics paused={!isMapPhysicsReady}>\n          <Suspense fallback={null}>\n            {/* ‚ö†Ô∏è MUST INCLUDE: Essential checker for map physics initialization */}\n            {!isMapPhysicsReady && <MapPhysicsReadyChecker />}\n            <FollowLight />\n            <SideViewController cameraMode=\"perspective\" followCharacter={true} camDistance={10} />\n            <Experience />\n          </Suspense>\n        </Physics>\n      </Canvas>\n    </>\n  );\n};\n\nexport default GameSceneCanvas;\n",
    isBinary: false,
  },
  'src/components/r3f/Experience.tsx': {
    type: 'file',
    content:
      "import { Environment } from '@react-three/drei';\nimport Player from './Player';\nimport Floor from './Floor';\n\nconst Experience = () => {\n  return (\n    <>\n      <ambientLight intensity={0.7} />\n      <Environment preset=\"sunset\" background={false} />\n      <Player />\n      <Floor />\n    </>\n  );\n};\n\nexport default Experience;\n",
    isBinary: false,
  },
  'src/components/r3f/Floor.tsx': {
    type: 'file',
    content:
      "import { useState, useEffect, useMemo } from 'react';\nimport { RigidBody, CuboidCollider } from '@react-three/rapier';\n\n// Seed-based random number generator class\nclass SeededRandom {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed;\n  }\n\n  // Generate random number between 0~1 (replacement for Math.random())\n  public random(): number {\n    const x = Math.sin(this.seed++) * 10000;\n    return x - Math.floor(x);\n  }\n\n  // Generate random number between min~max\n  public randomRange(min: number, max: number): number {\n    return min + this.random() * (max - min);\n  }\n}\n\nconst Floor = ({ seed = 12345 }: { seed?: number }) => {\n  const [rng, setRng] = useState<SeededRandom | null>(null);\n\n  useEffect(() => {\n    setRng(new SeededRandom(seed));\n  }, [seed]);\n\n  // Generate Mario-style floor blocks\n  const renderFloorBlocks = useMemo(() => {\n    if (!rng) return [];\n\n    // Block size and count settings\n    const blockWidth = 4;\n    const totalBlocks = 15;\n    const blocks = [];\n\n    // Add floor block at character origin (0,0,0) (to prevent character from falling at start)\n    const initialBlockWidth = 6; // Initial block is set wider\n    const initialBlockHeight = 0.8;\n    const initialBlockDepth = 2;\n\n    blocks.push(\n      <RigidBody key=\"initial-block\" type=\"fixed\" position={[0, -initialBlockHeight / 2, 0]} colliders={false}>\n        <CuboidCollider args={[initialBlockWidth / 2, initialBlockHeight / 2, initialBlockDepth / 2]} />\n        <mesh receiveShadow>\n          <boxGeometry args={[initialBlockWidth, initialBlockHeight, initialBlockDepth]} />\n          <meshStandardMaterial color=\"#4a4a4a\" />\n        </mesh>\n      </RigidBody>,\n    );\n\n    // Generate remaining blocks - starting position slightly to the right of origin\n    let currentXPosition = initialBlockWidth / 2 + 2; // Start from a position slightly away from the end of the first block\n\n    for (let i = 0; i < totalBlocks; i++) {\n      // Set different heights for some blocks to create more diverse terrain (using seed-based rng instead of Math.random)\n      const randomHeight = rng.randomRange(0.5, 0.8);\n      const randomDepth = rng.randomRange(1.5, 2.5);\n\n      // Vary block width slightly\n      const currentBlockWidth = rng.randomRange(blockWidth, blockWidth + 2);\n\n      // Set random gap between blocks (jumpable distance)\n      const gapSize = rng.randomRange(2, 4.5); // Random gap between 2~4.5\n\n      // Add random variation to y position\n      const randomYOffset = rng.randomRange(-0.6, 0.6); // Random height change between -0.6~0.6\n\n      const posX = currentXPosition + currentBlockWidth / 2;\n      const posY = -randomHeight / 2 + randomYOffset;\n\n      blocks.push(\n        <RigidBody key={i} type=\"fixed\" position={[posX, posY, 0]} colliders={false}>\n          <CuboidCollider args={[currentBlockWidth / 2, randomHeight / 2, randomDepth / 2]} />\n          <mesh receiveShadow>\n            <boxGeometry args={[currentBlockWidth, randomHeight, randomDepth]} />\n            <meshStandardMaterial color={i % 3 === 0 ? '#4a4a4a' : '#3f3f3f'} />\n          </mesh>\n        </RigidBody>,\n      );\n\n      // Update position for next block (current block width + random gap)\n      currentXPosition += currentBlockWidth + gapSize;\n    }\n\n    // Add some blocks to the left of origin as well\n    currentXPosition = -(initialBlockWidth / 2 + 2); // Position slightly away from the left end of initial block\n\n    for (let i = 0; i < 5; i++) {\n      // Only create 5 blocks to the left\n      const randomHeight = rng.randomRange(0.5, 0.8);\n      const randomDepth = rng.randomRange(1.5, 2.5);\n      const currentBlockWidth = rng.randomRange(blockWidth, blockWidth + 2);\n      const gapSize = rng.randomRange(2, 4.5);\n      const randomYOffset = rng.randomRange(-0.6, 0.6);\n\n      // Calculate block position to the left\n      currentXPosition -= currentBlockWidth + gapSize;\n      const posX = currentXPosition;\n      const posY = -randomHeight / 2 + randomYOffset;\n\n      blocks.push(\n        <RigidBody key={`left-${i}`} type=\"fixed\" position={[posX, posY, 0]} colliders={false}>\n          <CuboidCollider args={[currentBlockWidth / 2, randomHeight / 2, randomDepth / 2]} />\n          <mesh receiveShadow>\n            <boxGeometry args={[currentBlockWidth, randomHeight, randomDepth]} />\n            <meshStandardMaterial color={i % 3 === 0 ? '#4a4a4a' : '#3f3f3f'} />\n          </mesh>\n        </RigidBody>,\n      );\n    }\n\n    return blocks;\n  }, [rng]);\n\n  return <>{renderFloorBlocks}</>;\n};\n\nexport default Floor;\n",
    isBinary: false,
  },
  'src/components/r3f/Player.tsx': {
    type: 'file',
    content:
      "import React, { useRef, useEffect, useCallback } from 'react';\nimport { useFrame, Vector3 } from '@react-three/fiber';\nimport { CollisionPayload } from '@react-three/rapier';\nimport { useGameServer } from '@agent8/gameserver';\n\nimport { useLocalPlayerStore } from '../../stores/localPlayerStore';\nimport { useMultiPlayerStore } from '../../stores/multiPlayerStore';\n\nimport { CharacterState } from '../../constants/character';\nimport { RigidBodyObjectType } from '../../constants/rigidBodyObjectType';\n\nimport Assets from '../../assets.json';\nimport {\n  AnimationConfigMap,\n  AnimationType,\n  CharacterMovementState,\n  CharacterRenderer,\n  RigidBodyPlayer,\n  RigidBodyPlayerRef,\n  useCharacterAnimation,\n  useControllerStore,\n} from 'vibe-starter-3d';\nimport { usePlayerActionStore } from '../../stores/playerActionStore';\n\nconst targetHeight = 1.6;\n\n// States that can be interrupted by actions\nconst INTERRUPTIBLE_STATES = [\n  CharacterState.IDLE,\n  CharacterState.IDLE_01,\n  CharacterState.WALK,\n  CharacterState.RUN,\n  CharacterState.FAST_RUN,\n  CharacterState.JUMP,\n] as const;\n\n// Animation configuration map moved outside component for better performance\nconst animationConfigMap: AnimationConfigMap = {\n  [CharacterState.IDLE]: {\n    url: Assets.animations['idle-00'].url,\n    loop: true,\n  },\n  [CharacterState.IDLE_01]: {\n    url: Assets.animations['idle-01'].url,\n    loop: true,\n  },\n  [CharacterState.WALK]: {\n    url: Assets.animations['walk'].url,\n    loop: true,\n  },\n  [CharacterState.RUN]: {\n    url: Assets.animations['run-medium'].url,\n    loop: true,\n  },\n  [CharacterState.FAST_RUN]: {\n    url: Assets.animations['run-fast'].url,\n    loop: true,\n  },\n  [CharacterState.JUMP]: {\n    url: Assets.animations['jump'].url,\n    loop: true,\n    clampWhenFinished: true,\n  },\n  [CharacterState.PUNCH]: {\n    url: Assets.animations['punch-00'].url,\n    loop: false,\n    duration: 0.5,\n    clampWhenFinished: true,\n  },\n  [CharacterState.PUNCH_01]: {\n    url: Assets.animations['punch-01'].url,\n    loop: false,\n    duration: 0.5,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK]: {\n    url: Assets.animations['kick-00'].url,\n    loop: false,\n    duration: 0.75,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK_01]: {\n    url: Assets.animations['kick-01'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK_02]: {\n    url: Assets.animations['kick-02'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.MELEE_ATTACK]: {\n    url: Assets.animations['melee-attack'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.CAST]: {\n    url: Assets.animations['cast'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.HIT]: {\n    url: Assets.animations['hit-to-body'].url,\n    loop: false,\n    clampWhenFinished: false,\n  },\n  [CharacterState.DANCE]: {\n    url: Assets.animations['dance-wave'].url,\n    loop: false,\n    clampWhenFinished: false,\n  },\n  [CharacterState.SWIM]: {\n    url: Assets.animations['swim'].url,\n    loop: true,\n  },\n  [CharacterState.DIE]: {\n    url: Assets.animations['death-backward'].url,\n    loop: false,\n    clampWhenFinished: true,\n  },\n};\n\n/**\n * Player props\n */\ninterface PlayerProps {\n  /** Initial position of the player */\n  position?: Vector3;\n}\n\n/**\n * Player component that manages character model and animations\n *\n * Handles player state management and delegates rendering to CharacterRenderer.\n * Movement states come from ControllerStore, actions are handled locally.\n */\nconst Player = ({ position }: PlayerProps) => {\n  const { account } = useGameServer();\n  const { registerConnectedPlayer, unregisterConnectedPlayer } = useMultiPlayerStore();\n  const { setPosition: setLocalPlayerPosition } = useLocalPlayerStore();\n  const { getPlayerAction } = usePlayerActionStore();\n\n  // Use the new useCharacterAnimation hook\n  const { animationState, setAnimation, getAnimation } = useCharacterAnimation<CharacterState>(CharacterState.IDLE);\n\n  // Get movement state from controller store (unified API)\n  const { getCharacterMovementState, isControlLocked, lockControls, unlockControls } = useControllerStore();\n\n  // IMPORTANT: rigidBodyPlayerRef.current type is RigidBody\n  const rigidBodyPlayerRef = useRef<RigidBodyPlayerRef>(null);\n\n  // IMPORTANT: Register connected player reference\n  useEffect(() => {\n    if (!account) return;\n\n    registerConnectedPlayer(account, rigidBodyPlayerRef);\n\n    return () => {\n      unregisterConnectedPlayer(account);\n    };\n  }, [account, registerConnectedPlayer, unregisterConnectedPlayer]);\n\n  // IMPORTANT: Update local player store position information\n  useFrame(() => {\n    const playerRigidBody = rigidBodyPlayerRef.current;\n    if (!playerRigidBody) return;\n\n    const position = playerRigidBody.translation();\n    setLocalPlayerPosition(position.x, position.y, position.z);\n  });\n\n  // Helper functions\n  const canInterrupt = useCallback((state: CharacterState): boolean => {\n    return INTERRUPTIBLE_STATES.includes(state);\n  }, []);\n\n  // Convert ControllerStore state to Player animation state\n  const toCharacterState = useCallback((characterMovementState: CharacterMovementState): CharacterState => {\n    switch (characterMovementState) {\n      case CharacterMovementState.IDLE:\n        return CharacterState.IDLE;\n      case CharacterMovementState.WALKING:\n        return CharacterState.WALK;\n      case CharacterMovementState.RUN:\n        return CharacterState.RUN;\n      case CharacterMovementState.FAST_RUN:\n        return CharacterState.FAST_RUN;\n      case CharacterMovementState.AIRBORNE:\n        return CharacterState.JUMP;\n      default:\n        return CharacterState.IDLE;\n    }\n  }, []);\n\n  // Callback triggered when a non-looping animation finishes.\n  const handleAnimationComplete = useCallback(\n    (type: AnimationType) => {\n      unlockControls();\n      switch (type) {\n        case CharacterState.PUNCH:\n        case CharacterState.PUNCH_01:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.KICK:\n        case CharacterState.KICK_01:\n        case CharacterState.KICK_02:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.CAST:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.HIT:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.MELEE_ATTACK:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.DANCE:\n          setAnimation(CharacterState.IDLE);\n          break;\n        default:\n          break;\n      }\n    },\n    [unlockControls, setAnimation],\n  );\n\n  const updatePlayerState = useCallback((): void => {\n    const currentState = getAnimation();\n\n    // If controls are locked, don't process actions\n    if (isControlLocked()) {\n      return;\n    }\n\n    // Handle death and revive states\n    // TODO: Connect with actual game state\n    // const isRevive = playerHealth > 0 && currentState === CharacterState.DIE;\n    // const isDying = playerHealth <= 0 && currentState !== CharacterState.DIE;\n\n    // Currently using placeholder false values\n    const isRevive = false;\n    const isDying = false;\n\n    // Revive handling: when health is restored while in death state\n    if (isRevive) {\n      setAnimation(CharacterState.IDLE);\n      return;\n    }\n\n    // Death handling: when health drops to 0 or below\n    if (isDying) {\n      setAnimation(CharacterState.DIE);\n      return;\n    }\n\n    // Handle action states (punch, kick, etc.) - highest priority\n    if (getPlayerAction('punch') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.PUNCH);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('kick') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.KICK);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('meleeAttack') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.MELEE_ATTACK);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('cast') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.CAST);\n      lockControls();\n      return;\n    }\n\n    // For movement states, use ControllerStore state\n    if (canInterrupt(currentState)) {\n      const characterMovementState = getCharacterMovementState();\n      const characterState = toCharacterState(characterMovementState);\n      setAnimation(characterState);\n    }\n  }, [isControlLocked, canInterrupt, lockControls, getCharacterMovementState, toCharacterState, getAnimation, setAnimation, getPlayerAction]);\n\n  // Update player action state based on inputs and physics\n  useFrame(() => {\n    if (!rigidBodyPlayerRef.current) return;\n    updatePlayerState();\n  });\n\n  /** handleTriggerEnter: Called when the player intersects or collides with another object.\n   * - Handles when entering a specific area or colliding with another object\n   */\n  const handleTriggerEnter = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when entering a specific area or colliding with another object\n    }\n  };\n\n  /** handleTriggerExit: Called when the player exits an intersection or ends a collision with another object.\n   * - Handles when exiting a specific area or when collision with another object ends\n   */\n  const handleTriggerExit = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when exiting a specific area or when collision with another object ends\n    }\n  };\n\n  return (\n    <RigidBodyPlayer\n      ref={rigidBodyPlayerRef}\n      userData={{ account, type: RigidBodyObjectType.LOCAL_PLAYER }}\n      position={position}\n      targetHeight={targetHeight}\n      onTriggerEnter={handleTriggerEnter}\n      onTriggerExit={handleTriggerExit}\n    >\n      <CharacterRenderer\n        url={Assets.characters['base-model'].url}\n        animationConfigMap={animationConfigMap}\n        animationState={animationState}\n        targetHeight={targetHeight}\n        onAnimationComplete={handleAnimationComplete}\n      />\n    </RigidBodyPlayer>\n  );\n};\n\nexport default Player;\n",
    isBinary: false,
  },
  'src/components/scene/GameScene.tsx': {
    type: 'file',
    content:
      "import GameSceneCanvas from '../r3f/GameSceneCanvas';\nimport GameSceneUI from '../ui/GameSceneUI';\n\n/**\n * Main Game Scene Component\n *\n * This component serves as a layout container that arranges the game UI and 3D Canvas.\n *\n * üö® CRITICAL PERFORMANCE WARNING:\n * Re-rendering of this component triggers re-rendering of the entire 3D Canvas, causing severe performance degradation.\n *\n * Prohibited Actions:\n * - Using state management hooks like useState, useReducer\n * - Passing frequently changing values as props\n * - State updates inside useEffect\n * - Conditional rendering that changes component structure\n * - Creating inline objects/functions (e.g., style={{...}}, onClick={() => {}})\n *\n * Recommendations:\n * - Handle state management in child components (GameSceneUI, GameSceneCanvas)\n * - Access global state directly through zustand store or similar\n * - Memoize event handlers with useCallback before use\n */\nconst GameScene = () => {\n  return (\n    <div className=\"relative w-full h-screen\">\n      <GameSceneUI />\n      <GameSceneCanvas />\n    </div>\n  );\n};\n\nexport default GameScene;\n",
    isBinary: false,
  },
  'src/components/scene/PreloadScene.tsx': {
    type: 'file',
    content:
      "import React, { useEffect, useState } from 'react';\nimport assets from '../../assets.json';\nimport * as THREE from 'three';\nimport { GLTF, GLTFLoader } from 'three-stdlib';\nimport { TextureLoader } from 'three';\n\ninterface PreloadSceneProps {\n  onComplete: () => void;\n}\n\n// Type definition to accept any structure in assets.json\ntype AssetCategory = Record<string, { url: string; [key: string]: unknown }>;\n\n// Type for the different possible loaded asset types\ntype LoadedAsset = GLTF | THREE.Texture | HTMLAudioElement | HTMLVideoElement | Response | null;\n\n/**\n * Asset Preloading Scene Component\n *\n * Preloads all assets defined in assets.json regardless of type\n * (models, animations, textures, etc.) and calls the onComplete callback when loading is finished.\n */\nconst PreloadScene: React.FC<PreloadSceneProps> = ({ onComplete }) => {\n  const [progress, setProgress] = useState(0);\n  const [isComplete, setIsComplete] = useState(false);\n\n  useEffect(() => {\n    const preloadAssets = async () => {\n      try {\n        // Collect all asset URLs from every category in assets.json\n        const allUrls: string[] = [];\n\n        // Get all categories from assets.json (characters, animations, textures, etc.)\n        const categories = Object.keys(assets);\n\n        // Loop through each category and collect URLs\n        categories.forEach((category) => {\n          const assetCategory = assets[category as keyof typeof assets] as AssetCategory;\n          if (assetCategory && typeof assetCategory === 'object') {\n            const categoryUrls = Object.values(assetCategory)\n              .filter((item) => item && typeof item === 'object' && 'url' in item)\n              .map((item) => item.url);\n\n            allUrls.push(...categoryUrls);\n          }\n        });\n\n        console.log(`Found ${allUrls.length} assets to preload`);\n\n        // Setup loading manager for all assets\n        const loadingManager = new THREE.LoadingManager();\n\n        // Set up loading manager event handlers\n        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {\n          const currentProgress = Math.floor((itemsLoaded / itemsTotal) * 100);\n          console.log(`Loading progress: ${currentProgress}% (${url})`);\n          setProgress(currentProgress);\n        };\n\n        loadingManager.onLoad = () => {\n          console.log('All assets preloaded successfully');\n          setProgress(100);\n          setIsComplete(true);\n        };\n\n        loadingManager.onError = (url) => {\n          console.error(`Loading error: ${url}`);\n        };\n\n        // Create a Promise for each asset to load with appropriate loader\n        const loadPromises = allUrls.map((url) => {\n          // Determine file type from extension\n          const fileExtension = url.split('.').pop()?.toLowerCase();\n\n          return new Promise<LoadedAsset>((resolve) => {\n            // Choose appropriate loader based on file extension\n            if (fileExtension === 'glb' || fileExtension === 'gltf') {\n              // Use GLTFLoader for 3D models and animations\n              const loader = new GLTFLoader(loadingManager);\n              loader.load(\n                url,\n                (gltf) => {\n                  console.log(`Loaded model: ${url}`);\n                  resolve(gltf);\n                },\n                undefined,\n                (error) => {\n                  console.error(`Failed to load model: ${url}`, error);\n                  resolve(null);\n                },\n              );\n            } else if (['jpg', 'jpeg', 'png', 'webp'].includes(fileExtension || '')) {\n              // Use TextureLoader for image textures\n              const loader = new TextureLoader(loadingManager);\n              loader.load(\n                url,\n                (texture) => {\n                  console.log(`Loaded texture: ${url}`);\n                  resolve(texture);\n                },\n                undefined,\n                (error) => {\n                  console.error(`Failed to load texture: ${url}`, error);\n                  resolve(null);\n                },\n              );\n            } else if (['mp3', 'wav', 'ogg'].includes(fileExtension || '')) {\n              // For audio files, preload with audio element\n              const audio = new Audio();\n              audio.src = url;\n\n              audio.addEventListener('canplaythrough', () => {\n                console.log(`Loaded audio: ${url}`);\n                resolve(audio);\n              });\n\n              audio.addEventListener('error', () => {\n                console.error(`Failed to load audio: ${url}`);\n                resolve(null);\n              });\n\n              // Force preloading\n              audio.load();\n            } else if (['mp4', 'webm'].includes(fileExtension || '')) {\n              // For video files\n              const video = document.createElement('video');\n              video.src = url;\n              video.preload = 'auto';\n\n              video.addEventListener('canplaythrough', () => {\n                console.log(`Loaded video: ${url}`);\n                resolve(video);\n              });\n\n              video.addEventListener('error', () => {\n                console.error(`Failed to load video: ${url}`);\n                resolve(null);\n              });\n\n              // Force preloading\n              video.load();\n            } else {\n              // For other file types, use a simple fetch to ensure it's in browser cache\n              fetch(url)\n                .then((response) => {\n                  if (!response.ok) throw new Error(`Failed to load: ${url}`);\n                  console.log(`Loaded other: ${url}`);\n                  return resolve(response);\n                })\n                .catch((error) => {\n                  console.error(`Failed to load: ${url}`, error);\n                  resolve(null);\n                });\n            }\n          });\n        });\n\n        // Wait for all loading tasks to complete\n        await Promise.all(loadPromises);\n      } catch (error) {\n        console.error('Error during asset preloading:', error);\n      }\n    };\n\n    preloadAssets();\n  }, []);\n\n  // Call onComplete callback when loading is finished\n  useEffect(() => {\n    if (isComplete) {\n      onComplete();\n    }\n  }, [isComplete, onComplete]);\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex flex-col items-center justify-center bg-black text-white\">\n      <h2 className=\"text-2xl font-bold mb-4\">Loading</h2>\n      <div className=\"w-64 h-2 bg-gray-700 rounded-full overflow-hidden\">\n        <div className=\"h-full bg-blue-500 transition-all duration-300\" style={{ width: `${Math.max(0, Math.min(100, progress))}%` }} />\n      </div>\n      <p className=\"mt-2\">{progress}%</p>\n    </div>\n  );\n};\n\nexport default PreloadScene;\n",
    isBinary: false,
  },
  'src/components/ui/LoadingScreen.tsx': {
    type: 'file',
    content:
      "import { useThree } from '@react-three/fiber';\nimport { Html } from '@react-three/drei';\n\n/**\n * Loading screen component\n */\nconst LoadingScreen = () => {\n  let isInThreeCanvas: boolean;\n  try {\n    useThree();\n    isInThreeCanvas = true;\n  } catch {\n    isInThreeCanvas = false;\n  }\n\n  const loadingContent = (\n    <div>\n      <style>{`\n        .loading-container {\n          inset: 0;\n          z-index: 50;\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: center;\n          background-color: black;\n          color: white;\n          width: 100%;\n          height: 100%;\n        }\n        .loading-title {\n          font-size: 1.5rem;\n          font-weight: bold;\n          margin-bottom: 1rem;\n        }\n        .spinner {\n          width: 30px;\n          height: 30px;\n          border: 3px solid rgba(255, 255, 255, 0.3);\n          border-radius: 50%;\n          border-top-color: white;\n          animation: spin 1s ease-in-out infinite;\n        }\n        @keyframes spin {\n          to {\n            transform: rotate(360deg);\n          }\n        }\n      `}</style>\n      <div className=\"loading-container\">\n        <h2 className=\"loading-title\">Loading</h2>\n        <div className=\"spinner\"></div>\n      </div>\n    </div>\n  );\n\n  if (isInThreeCanvas) {\n    return (\n      <Html\n        center\n        style={{\n          width: '100vw',\n          height: '100vh',\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          pointerEvents: 'none',\n        }}\n      >\n        {loadingContent}\n      </Html>\n    );\n  }\n\n  return loadingContent;\n};\n\nexport default LoadingScreen;\n",
    isBinary: false,
  },
  'src/components/ui/InputController.tsx': {
    type: 'file',
    content:
      "import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport * as THREE from 'three';\nimport { IS_MOBILE, useInputStore } from 'vibe-starter-3d';\nimport { usePlayerActionStore } from '../../stores/playerActionStore';\nimport nipplejs from 'nipplejs';\n\n/**\n * Key mapping configuration - simple Record<string, string[]>\n */\ntype KeyMapping = Record<string, string[]>; // action: [key1, key2, ...]\n\n/**\n * Controller key mapping\n */\nconst CONTROL_KEY_MAPPING: KeyMapping = {\n  forward: ['KeyW', 'ArrowUp'],\n  backward: ['KeyS', 'ArrowDown'],\n  leftward: ['KeyA', 'ArrowLeft'],\n  rightward: ['KeyD', 'ArrowRight'],\n  jump: ['Space'],\n  run: ['ShiftLeft', 'ShiftRight'],\n};\n\n/**\n * Player action key mapping\n */\nconst ACTION_KEY_MAPPING: KeyMapping = {\n  punch: ['KeyF', 'Mouse0'],\n  kick: ['KeyG', 'Mouse2'],\n  meleeAttack: ['KeyQ', 'KeyC'],\n  cast: ['KeyE', 'Mouse1'],\n};\n\n// Movement speed constants\nconst MOVEMENT_SPEED_WALK = 0.6;\nconst MOVEMENT_SPEED_RUN_BOOST = 0.4;\nconst MOVEMENT_SPEED_MAX = 1.0;\nconst JOYSTICK_RANGE_MULTIPLIER = 2.0; // Converts joystick range (0~0.5) to full range (0~1.0)\n\ninterface InputControllerProps {\n  disabled?: boolean;\n  disableKeyboard?: boolean;\n  disableJoystick?: boolean;\n}\n\nexport const InputController: React.FC<InputControllerProps> = ({ disabled = false, disableKeyboard = false, disableJoystick = false }) => {\n  // Store actions to controller\n  const { setMovementInput, setActionInput, resetAllInputs, setActiveInputSource } = useInputStore();\n  const { setPlayerAction, resetAllPlayerActions } = usePlayerActionStore();\n\n  // Button states\n  const [isJumpPressed, setIsJumpPressed] = useState(false);\n  const [isAttackPressed, setIsAttackPressed] = useState(false);\n\n  // Keyboard state tracking\n  const keyboardStateRef = useRef({\n    forward: false,\n    backward: false,\n    leftward: false,\n    rightward: false,\n    run: false,\n  });\n\n  // Helper function to calculate movement from keyboard state\n  const calculateKeyboardMovement = useCallback(() => {\n    const state = keyboardStateRef.current;\n\n    // Calculate direction\n    const x = (state.leftward ? 1 : 0) + (state.rightward ? -1 : 0);\n    const y = (state.forward ? 1 : 0) + (state.backward ? -1 : 0);\n\n    // Use Three.js Vector2 for efficient normalization\n    const direction = new THREE.Vector2(x, y);\n    const magnitude = direction.length();\n\n    // Normalize diagonal movement\n    if (magnitude > 0) {\n      direction.normalize();\n    }\n\n    // Calculate intensity: base speed + run boost\n    const baseIntensity = magnitude > 0 ? MOVEMENT_SPEED_WALK : 0; // Base walking speed\n    const runBoost = state.run ? MOVEMENT_SPEED_RUN_BOOST : 0; // Additional speed when running\n    const intensity = Math.min(baseIntensity + runBoost, MOVEMENT_SPEED_MAX);\n\n    return {\n      direction: { x: direction.x, y: direction.y },\n      intensity,\n    };\n  }, []);\n\n  // Joystick input handling with analog support\n  useEffect(() => {\n    if (disabled || disableJoystick || !IS_MOBILE) return;\n\n    // Create div element for left side area of screen\n    const joystickZone = document.createElement('div');\n    joystickZone.style.position = 'fixed';\n    joystickZone.style.left = '0';\n    joystickZone.style.top = '0';\n    joystickZone.style.width = '50%'; // Left 50% of screen\n    joystickZone.style.height = '100%';\n    joystickZone.style.zIndex = '1000';\n    joystickZone.style.pointerEvents = 'auto';\n    joystickZone.style.backgroundColor = 'transparent';\n    // Disable long touch events\n    joystickZone.style.touchAction = 'none';\n    joystickZone.style.userSelect = 'none';\n    joystickZone.style.setProperty('-webkit-user-select', 'none');\n    joystickZone.style.setProperty('-webkit-touch-callout', 'none');\n    document.body.appendChild(joystickZone);\n\n    const options: nipplejs.JoystickManagerOptions = {\n      zone: joystickZone,\n      color: 'white',\n      mode: 'dynamic',\n      shape: 'circle',\n    };\n\n    const manager = nipplejs.create(options);\n\n    manager.on('move', (evt, data) => {\n      if (disabled || disableJoystick) return; // Check disabled state\n      setActiveInputSource('joystick');\n\n      // Extract analog data from nipplejs\n      const angle = data.angle?.radian || 0; // Angle in radians\n      const distance = data.distance || 0; // Distance from center\n      const maxDistance = data.instance.options.size || 100; // Maximum distance\n\n      // Calculate normalized direction vector\n      // nipplejs uses mathematical coordinate system (0¬∞ = right, 90¬∞ = up)\n      // We need to convert to game coordinate system (0¬∞ = up, 90¬∞ = right)\n      const gameAngle = angle - Math.PI / 2; // Rotate by -90 degrees\n      const directionX = Math.sin(gameAngle); // Right/Left\n      const directionY = Math.cos(gameAngle); // Forward/Backward\n\n      // Calculate intensity (0.0 to 1.0) based on distance from center\n      const intensity = Math.min((distance / maxDistance) * JOYSTICK_RANGE_MULTIPLIER, MOVEMENT_SPEED_MAX);\n\n      // Set analog movement input\n      setMovementInput({ x: directionX, y: directionY }, intensity, 'joystick');\n    });\n\n    manager.on('end', () => {\n      if (disabled || disableJoystick) return; // Check disabled state\n      // Reset all inputs when joystick ends\n      setMovementInput({ x: 0, y: 0 }, 0, 'joystick');\n    });\n\n    return () => {\n      manager.destroy();\n      if (joystickZone.parentNode) {\n        joystickZone.parentNode.removeChild(joystickZone);\n      }\n    };\n  }, [disabled, disableJoystick, setMovementInput, setActiveInputSource]);\n\n  // Keyboard input handling - convert to movement immediately\n  useEffect(() => {\n    if (disabled || disableKeyboard) return;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n      let stateChanged = false;\n\n      // Handle movement keys\n      if (CONTROL_KEY_MAPPING['forward']?.includes(event.code) && !keyboardStateRef.current.forward) {\n        keyboardStateRef.current.forward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['backward']?.includes(event.code) && !keyboardStateRef.current.backward) {\n        keyboardStateRef.current.backward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['leftward']?.includes(event.code) && !keyboardStateRef.current.leftward) {\n        keyboardStateRef.current.leftward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['rightward']?.includes(event.code) && !keyboardStateRef.current.rightward) {\n        keyboardStateRef.current.rightward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['run']?.includes(event.code) && !keyboardStateRef.current.run) {\n        keyboardStateRef.current.run = true;\n        stateChanged = true;\n      }\n\n      // Handle action keys\n      if (CONTROL_KEY_MAPPING['jump']?.includes(event.code)) {\n        setActionInput('jump', true, 'keyboard');\n      }\n\n      // Handle player action keys\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(event.code)) {\n          setPlayerAction(action, true);\n        }\n      });\n\n      // Update movement if any movement-related key changed\n      if (stateChanged) {\n        const movement = calculateKeyboardMovement();\n        setMovementInput(movement.direction, movement.intensity, 'keyboard');\n      }\n    };\n\n    const handleKeyUp = (event: KeyboardEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n      let stateChanged = false;\n\n      // Handle movement keys\n      if (CONTROL_KEY_MAPPING['forward']?.includes(event.code) && keyboardStateRef.current.forward) {\n        keyboardStateRef.current.forward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['backward']?.includes(event.code) && keyboardStateRef.current.backward) {\n        keyboardStateRef.current.backward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['leftward']?.includes(event.code) && keyboardStateRef.current.leftward) {\n        keyboardStateRef.current.leftward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['rightward']?.includes(event.code) && keyboardStateRef.current.rightward) {\n        keyboardStateRef.current.rightward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['run']?.includes(event.code) && keyboardStateRef.current.run) {\n        keyboardStateRef.current.run = false;\n        stateChanged = true;\n      }\n\n      // Handle action keys\n      if (CONTROL_KEY_MAPPING['jump']?.includes(event.code)) {\n        setActionInput('jump', false, 'keyboard');\n      }\n\n      // Handle player action keys\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(event.code)) {\n          setPlayerAction(action, false);\n        }\n      });\n\n      // Update movement if any movement-related key changed\n      if (stateChanged) {\n        const movement = calculateKeyboardMovement();\n        setMovementInput(movement.direction, movement.intensity, 'keyboard');\n      }\n    };\n\n    const handleMouseDown = (event: MouseEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n\n      // Handle player action mouse keys\n      const mouseButton = `Mouse${event.button}`;\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(mouseButton)) {\n          setPlayerAction(action, true);\n        }\n      });\n    };\n\n    const handleMouseUp = (event: MouseEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n\n      // Handle player action mouse keys\n      const mouseButton = `Mouse${event.button}`;\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(mouseButton)) {\n          setPlayerAction(action, false);\n        }\n      });\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n      document.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [disabled, disableKeyboard, setMovementInput, setActionInput, setPlayerAction, calculateKeyboardMovement]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      resetAllInputs();\n      resetAllPlayerActions();\n    };\n  }, [resetAllInputs, resetAllPlayerActions]);\n\n  // Reset inputs when disabled\n  useEffect(() => {\n    if (disabled || disableKeyboard || disableJoystick) {\n      // Reset keyboard state if keyboard is disabled\n      if (disabled || disableKeyboard) {\n        keyboardStateRef.current = {\n          forward: false,\n          backward: false,\n          leftward: false,\n          rightward: false,\n          run: false,\n        };\n      }\n      // Reset button states\n      setIsJumpPressed(false);\n      setIsAttackPressed(false);\n      resetAllInputs();\n      resetAllPlayerActions();\n    }\n  }, [disabled, disableKeyboard, disableJoystick, resetAllInputs, resetAllPlayerActions]);\n\n  // Button handlers\n  const handleJumpStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation(); // Prevent event propagation\n      setIsJumpPressed(true);\n      setActionInput('jump', true, 'touch');\n    },\n    [disabled, setActionInput],\n  );\n\n  const handleJumpEnd = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation(); // Prevent event propagation\n      setIsJumpPressed(false);\n      setActionInput('jump', false, 'touch');\n    },\n    [disabled, setActionInput],\n  );\n\n  const handleAttackStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation();\n      setIsAttackPressed(true);\n      // NOTE: change to other action if needed\n      setPlayerAction('punch', true);\n    },\n    [disabled, setPlayerAction],\n  );\n\n  const handleAttackEnd = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation();\n      setIsAttackPressed(false);\n      // NOTE: change to other action if needed\n      setPlayerAction('punch', false);\n    },\n    [disabled, setPlayerAction],\n  );\n\n  // Don't render action buttons if joystick is disabled\n  if (disableJoystick) {\n    return null;\n  }\n\n  // Render action buttons\n  return (\n    <div className=\"fixed bottom-8 right-8 z-[1001]\">\n      {/* Attack Button */}\n      <div\n        className={`w-20 h-20 rounded-full bg-white/30 \n                   flex items-center justify-center cursor-pointer select-none touch-none\n                   ${isAttackPressed ? 'scale-90' : 'scale-100'} transition-transform`}\n        onMouseDown={handleAttackStart}\n        onMouseUp={handleAttackEnd}\n        onMouseLeave={handleAttackEnd}\n        onTouchStart={handleAttackStart}\n        onTouchEnd={handleAttackEnd}\n      >\n        <span className=\"text-white text-xs font-bold\">ATTACK</span>\n      </div>\n\n      {/* Jump Button */}\n      <div\n        className={`absolute bottom-0 -left-12 -top-12 w-14 h-14 rounded-full bg-white/30 \n                   flex items-center justify-center cursor-pointer select-none touch-none\n                   ${isJumpPressed ? 'scale-90' : 'scale-100'} transition-transform`}\n        onMouseDown={handleJumpStart}\n        onMouseUp={handleJumpEnd}\n        onMouseLeave={handleJumpEnd}\n        onTouchStart={handleJumpStart}\n        onTouchEnd={handleJumpEnd}\n      >\n        <span className=\"text-white text-xs font-bold\">JUMP</span>\n      </div>\n    </div>\n  );\n};\n",
    isBinary: false,
  },
  'src/components/ui/GameSceneUI.tsx': {
    type: 'file',
    content:
      "import { useGameStore } from '../../stores/gameStore';\nimport { InputController } from './InputController';\nimport LoadingScreen from './LoadingScreen';\n\n/**\n * Game Scene UI Component\n *\n * This component manages UI overlays for the game scene.\n * It handles loading states and displays appropriate UI elements based on game state.\n */\nconst GameSceneUI = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* Input Controller - Global input management (keyboard, touch) */}\n      <InputController disableJoystick={false} disableKeyboard={false} disabled={!isMapPhysicsReady} />\n      {/* Loading Game Scene screen overlay */}\n      {!isMapPhysicsReady && <LoadingScreen />}\n    </>\n  );\n};\n\nexport default GameSceneUI;\n",
    isBinary: false,
  },
} as FileMap;

export const TEMPLATE_3D_BASIC_MINECRAFT = {
  '.gitignore': {
    type: 'file',
    content:
      '# Logs\nlogs\n*.log\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\npnpm-debug.log*\nlerna-debug.log*\n\nnode_modules\ndist\ndist-ssr\n*.local\n\n# Editor directories and files\n.vscode/*\n!.vscode/extensions.json\n.idea\n.DS_Store\n*.suo\n*.ntvs*\n*.njsproj\n*.sln\n*.sw?\n',
    isBinary: false,
  },
  'index.html': {
    type: 'file',
    content:
      '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + React + TS</title>\n    <style>\n      body {\n        margin: 0;\n        padding: 0;\n        font-family: Arial, sans-serif;\n      }\n      .loading-container {\n        position: fixed;\n        inset: 0;\n        z-index: 50;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background-color: black;\n        color: white;\n      }\n      .loading-title {\n        font-size: 1.5rem;\n        font-weight: bold;\n        margin-bottom: 1rem;\n      }\n      .spinner {\n        width: 30px;\n        height: 30px;\n        border: 3px solid rgba(255, 255, 255, 0.3);\n        border-radius: 50%;\n        border-top-color: white;\n        animation: spin 1s ease-in-out infinite;\n      }\n      @keyframes spin {\n        to {\n          transform: rotate(360deg);\n        }\n      }\n    </style>\n    <script>\n      (function () {\n        function reportGameSize() {\n          const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n\n          const width = Math.max(document.body.scrollWidth, document.documentElement.scrollWidth);\n\n          window.parent.postMessage(\n            {\n              type: \'GAME_SIZE_RESPONSE\',\n              height: height,\n              width: width,\n            },\n            \'*\',\n          );\n        }\n\n        window.addEventListener(\'load\', reportGameSize);\n\n        window.addEventListener(\'resize\', reportGameSize);\n\n        window.addEventListener(\'message\', function (event) {\n          if (event.data && event.data.type === \'REQUEST_GAME_SIZE\') {\n            reportGameSize();\n          }\n        });\n      })();\n    </script>\n  </head>\n  <body>\n    <div id="root">\n      <div class="loading-container">\n        <h2 class="loading-title">Loading</h2>\n        <div class="spinner"></div>\n      </div>\n    </div>\n    <script type="module" src="/src/main.tsx"></script>\n  </body>\n</html>\n',
    isBinary: false,
  },
  'package.json': {
    type: 'file',
    content:
      '{\n  "name": "minecraft",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "vite build",\n    "lint": "eslint .",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "@agent8/gameserver": "^1.5.3",\n    "vibe-starter-3d": "^0.8.18",\n    "@react-three/drei": "9.122.0",\n    "@react-three/fiber": "8.18.0",\n    "@react-three/postprocessing": "2.19.1",\n    "@react-three/rapier": "1.5.0",\n    "@dimforge/rapier3d-compat": "0.14.0",\n    "nipplejs": "0.10.2",\n    "lucide-react": "0.482.0",\n    "react": "18.3.1",\n    "react-dom": "18.3.1",\n    "three": "0.174.0",\n    "three-stdlib": "2.35.14",\n    "zustand": "5.0.3",\n    "lodash": "^4.17.21",\n    "simplex-noise": "^4.0.3"\n  },\n  "devDependencies": {\n    "@types/lodash": "^4.17.16",\n    "@types/react": "^18.3.1",\n    "@types/react-dom": "^18.3.1",\n    "@types/three": "^0.174.0",\n    "@vitejs/plugin-react": "^4.3.4",\n    "autoprefixer": "^10.4.21",\n    "globals": "^16.0.0",\n    "tailwindcss": "^3.4.1",\n    "typescript": "~5.8.2",\n    "vite": "^6.2.2"\n  }\n}\n',
    isBinary: false,
  },
  'tailwind.config.js': {
    type: 'file',
    content:
      '/** @type {import(\'tailwindcss\').Config} */\nexport default {\n  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n',
    isBinary: false,
  },
  'server.js': {
    type: 'file',
    content:
      "class Server {\n  // Join a room or create a new one if roomId is not provided\n  async joinRoom(roomId, nickname) {\n    try {\n      if (!nickname || nickname.trim() === '') {\n        throw new Error('Please enter a nickname');\n      }\n\n      // If roomId is provided, join that specific room\n      // Otherwise, create a new room\n      const joinedRoomId = await $global.joinRoom(roomId);\n\n      // Initialize user state in the room with the provided nickname\n      const userState = {\n        account: $sender.account,\n        joinedAt: Date.now(),\n        lastActive: Date.now(),\n        isReady: false,\n        nickname: nickname.trim(),\n        character: null,\n        stats: {\n          maxHp: 100,\n          currentHp: 100,\n        },\n      };\n\n      await $room.updateUserState($sender.account, userState);\n\n      // Get current room state\n      const roomState = await $room.getRoomState();\n\n      // Initialize room state if it's a new room\n      if (!roomState.initialized) {\n        await $room.updateRoomState({\n          initialized: true,\n          lastActivity: Date.now(),\n          userCount: (roomState.$users || []).length,\n          gameStarted: false,\n        });\n      } else {\n        // Update room state to indicate a new user has joined\n        await $room.updateRoomState({\n          lastActivity: Date.now(),\n          userCount: (roomState.$users || []).length,\n        });\n      }\n\n      // Broadcast a system message that a new user has joined\n      await $room.broadcastToRoom('system-message', {\n        type: 'join',\n        account: $sender.account,\n        nickname: nickname.trim(),\n        timestamp: Date.now(),\n      });\n\n      return joinedRoomId;\n    } catch (error) {\n      throw new Error(`Failed to join room: ${error.message}`);\n    }\n  }\n\n  // Leave the current room\n  async leaveRoom() {\n    try {\n      // Get user state to include nickname in the system message\n      const userState = await $room.getUserState($sender.account);\n\n      // Broadcast a system message that the user is leaving\n      await $room.broadcastToRoom('system-message', {\n        type: 'leave',\n        account: $sender.account,\n        nickname: userState.nickname,\n        timestamp: Date.now(),\n      });\n\n      // Actually leave the room\n      return await $global.leaveRoom();\n    } catch (error) {\n      throw new Error(`Failed to leave room: ${error.message}`);\n    }\n  }\n\n  // Set character for the current user\n  async setCharacter(character) {\n    try {\n      // Update user's character\n      await $room.updateUserState($sender.account, {\n        character,\n        lastActive: Date.now(),\n      });\n\n      // Broadcast a system message that user has selected a character\n      await $room.broadcastToRoom('system-message', {\n        type: 'character-select',\n        account: $sender.account,\n        character: character,\n        timestamp: Date.now(),\n      });\n\n      return character;\n    } catch (error) {\n      throw new Error(`Failed to select character: ${error.message}`);\n    }\n  }\n\n  // Update player transform and state\n  async updatePlayerTransform(transform, state) {\n    try {\n      // Validate transform data\n      if (!transform || !transform.position || !transform.rotation) {\n        throw new Error('Invalid transform data');\n      }\n\n      // Get the current user state (optional)\n      // const userState = await $room.getUserState($sender.account);\n\n      // Update user's transform (original object) and state\n      await $room.updateUserState($sender.account, {\n        transform: transform, // Use the original transform object\n        state,\n        lastActive: Date.now(),\n      });\n\n      return true;\n    } catch (error) {\n      console.error(`Failed to update player transform: ${error.message}`);\n      return false;\n    }\n  }\n\n  // Toggle ready status for the current user\n  async toggleReady() {\n    try {\n      // Get current user state\n      const userState = await $room.getUserState($sender.account);\n\n      // Don't allow toggling ready if not character is selected\n      if (!userState.character) {\n        throw new Error('Please select a character first');\n      }\n\n      // Toggle ready status\n      const newReadyStatus = !userState.isReady;\n\n      // Update user's ready status\n      await $room.updateUserState($sender.account, {\n        isReady: newReadyStatus,\n        lastActive: Date.now(),\n      });\n\n      // Get current room state\n      const roomState = await $room.getRoomState();\n\n      if (newReadyStatus) {\n        // If the user is now ready\n        if (!roomState.gameStarted) {\n          // If game hasn't started yet and this is the first ready user, start the game\n          const now = Date.now();\n          await $room.updateRoomState({\n            gameStarted: true,\n            gameStartTime: now,\n            lastActivity: now,\n          });\n\n          // Broadcast game start message\n          await $room.broadcastToRoom('system-message', {\n            type: 'game-start',\n            timestamp: now,\n            message: 'Game started!',\n          });\n        } else {\n          // If game is already started, player joins immediately\n          await $room.broadcastToRoom('system-message', {\n            type: 'player-join-game',\n            account: $sender.account,\n            nickname: userState.nickname,\n            timestamp: Date.now(),\n            message: `${userState.nickname} joined the game!`,\n          });\n        }\n      }\n\n      return newReadyStatus;\n    } catch (error) {\n      throw new Error(`Failed to change ready status: ${error.message}`);\n    }\n  }\n\n  // Send a chat message to everyone in the room\n  async sendMessage(message) {\n    try {\n      if (!message || message.trim() === '') {\n        throw new Error('Please enter a message');\n      }\n\n      // Get user state to include nickname in the message\n      const userState = await $room.getUserState($sender.account);\n\n      // Update user's last active timestamp\n      await $room.updateUserState($sender.account, {\n        lastActive: Date.now(),\n      });\n\n      // Broadcast the message to all users in the room\n      await $room.broadcastToRoom('chat-message', {\n        sender: $sender.account,\n        senderNickname: userState.nickname || null,\n        content: message,\n        timestamp: Date.now(),\n      });\n\n      return true;\n    } catch (error) {\n      throw new Error(`Failed to send message: ${error.message}`);\n    }\n  }\n\n  // Send effect event to all users in the room (Generic effect event sending function)\n  async sendEffectEvent(effectData) {\n    try {\n      // Get user state to include sender information\n      const userState = await $room.getUserState($sender.account);\n\n      // Validate effect data\n      if (!effectData || !effectData.type || !effectData.startPosition || !effectData.direction || !effectData.targetPosition) {\n        throw new Error('Invalid effect data');\n      }\n\n      // Update user's last active timestamp\n      await $room.updateUserState($sender.account, {\n        lastActive: Date.now(),\n      });\n\n      // Broadcast the effect event to all users in the room\n      await $room.broadcastToRoom('effect-event', {\n        sender: $sender.account,\n        effectData,\n        timestamp: Date.now(),\n      });\n\n      return true;\n    } catch (error) {\n      console.error(`Failed to send effect event: ${error.message}`);\n      return false;\n    }\n  }\n\n  // Send fireball effect event to all users in the room (For backward compatibility)\n  async sendFireballEffect(startPosition, direction, targetPosition) {\n    // Convert object form to array if needed\n    const convertToArray = (pos) => {\n      if (Array.isArray(pos)) return pos;\n      return [pos.x, pos.y, pos.z];\n    };\n\n    return this.sendEffectEvent({\n      type: 'FIREBALL',\n      startPosition: convertToArray(startPosition),\n      direction: convertToArray(direction),\n      targetPosition: convertToArray(targetPosition),\n    });\n  }\n\n  // Handle ping request from client for RTT calculation\n  async handlePing(clientPingTime) {\n    try {\n      const serverPongTime = Date.now(); // Get high-resolution timestamp\n      // console.log(`Received ping with clientTime: ${clientPingTime}, sending pong at: ${serverPongTime}`);\n      return {\n        clientPingTime, // Echo back the client's ping time\n        serverPongTime, // Send the server's pong time\n      };\n    } catch (error) {\n      console.error(`handlePing Error: ${error.message}`);\n      // In case of an error, return null or throw, depending on desired client handling\n      return {\n        clientPingTime: null, // Echo back the client's ping time\n        serverPongTime, // Send the server's pong time\n      };\n    }\n  }\n\n  // Apply damage to a target user\n  async applyDamage(targetAccount, damageAmount) {\n    try {\n      if (!targetAccount) {\n        throw new Error('Please specify a target user');\n      }\n\n      if (!damageAmount || damageAmount <= 0) {\n        throw new Error('Please enter a valid damage value');\n      }\n\n      // Get attacker info\n      const attackerState = await $room.getUserState($sender.account);\n\n      // Get target user state\n      const targetState = await $room.getUserState(targetAccount);\n\n      if (!targetState) {\n        throw new Error('Target user not found');\n      }\n\n      // Initialize stats if they don't exist\n      if (!targetState.stats) {\n        targetState.stats = { maxHp: 100, currentHp: 100 };\n      } else if (targetState.stats.currentHp === undefined) {\n        targetState.stats.maxHp = 100;\n        targetState.stats.currentHp = 100;\n      }\n\n      // Calculate new HP\n      const newHp = Math.max(0, targetState.stats.currentHp - damageAmount);\n\n      // Create state update object\n      const updateData = {\n        stats: {\n          ...targetState.stats,\n          currentHp: newHp,\n        },\n        lastActive: Date.now(),\n      };\n\n      // Set state to DIE if HP becomes 0\n      if (newHp <= 0) {\n        updateData.state = 'DIE';\n      }\n\n      // Update target's HP and state if died\n      await $room.updateUserState(targetAccount, updateData);\n\n      return {\n        success: true,\n        targetAccount,\n        newHp,\n      };\n    } catch (error) {\n      throw new Error(`Failed to apply damage: ${error.message}`);\n    }\n  }\n\n  // Room tick function to handle periodic updates\n  async $roomTick(deltaMS, roomId) {\n    try {\n      // Add periodic room state updates here if needed\n    } catch (error) {\n      console.error(`Room tick error: ${error.message}`);\n    }\n  }\n}\n",
    isBinary: false,
  },
  'tsconfig.app.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",\n    "target": "ES2020",\n    "useDefineForClassFields": true,\n    "lib": ["ES2020", "DOM", "DOM.Iterable"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n    "jsx": "react-jsx",\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["src"]\n}\n',
    isBinary: false,
  },
  'vite.config.ts': {
    type: 'file',
    content:
      'import { defineConfig } from "vite";\nimport react from "@vitejs/plugin-react";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  optimizeDeps: {\n    exclude: ["lucide-react"],\n  },\n  base: "./",\n  build: {\n    outDir: "dist",\n  },\n});\n',
    isBinary: false,
  },
  'PROJECT.md': {
    type: 'file',
    content:
      "# Basic 3D Minecraft-Style Voxel Game\n\n## Project Summary\n\nThis project is a 3D Minecraft-inspired voxel game built with Three.js and React. It features color-based block rendering, block manipulation, and first-person exploration. Players can add and remove blocks with various colors, explore the world, and create structures using different themed blocks.\n\n## Implementation Strategy\n\nThis project uses a **Color-Based 3D Three.js Voxel Optimization** approach because:\n\n- It requires efficient block-based world rendering\n- Three.js provides powerful 3D rendering capabilities in web browsers\n- React Three Fiber simplifies integration with React components\n- Instanced rendering allows for thousands of blocks with good performance\n- Chunk-based systems enable efficient world exploration\n\nKey technologies:\n\n- Three.js - 3D rendering\n- React Three Fiber - React integration\n- @react-three/rapier - Physics simulation\n- Zustand - State management\n- vibe-starter-3d (v0.4.0) - Advanced character control, animation system, and physics integration\n- Instanced Meshes - Optimized block rendering\n- Custom Shaders - Face-specific coloring\n- Tailwind CSS - UI composition\n\n## Core Features\n\n- **Block Manipulation**: Interactive block placing and removing with precise mouse targeting\n- **First-Person Control**: Smooth character movement with physics-based collision detection\n- **Advanced Animation System**: Character state management with multiple animation types (idle, walk, run, jump, cast)\n- **Color-Based Block System**: Multiple block types organized by intuitive color themes\n- **Optimized Rendering**: Chunk-based system with instanced meshes for efficient rendering of thousands of blocks\n- **Custom Shader Implementation**: Per-face color rendering without texture overhead\n- **Precise Raycasting**: Accurate block targeting with synchronized preview and placement systems\n- **Dynamic World Loading**: Automatic chunk loading/unloading based on player proximity\n- **Procedural CubeMap**: Advanced cubeMap generation with layer-based block distribution using absolute Y-coordinates\n- **Physics Integration**: Complete physics simulation with collision detection and rigid body management\n- **Player Reference System**: Multiplayer-ready player tracking and state management\n\n## Current Implementation Features\n\n- **Advanced Player System**: Dedicated Player.tsx component with comprehensive character management, animation control, and state transitions\n- **Character Animation System**: Complete character state management with animation mapping for idle, walking, running, jumping, and casting actions\n- **Physics Integration**: Full physics integration with collision detection, rigid body object type definitions, and player reference management\n- **Optimized CubeMap Generation**: Procedural cubeMap generation with smooth transitions, natural formations, and absolute Y-coordinate based layer distribution\n- **Precise Block Interaction**: Synchronized raycasting system with perfect alignment between preview and actual cube placement\n- **Theme-Based Block System**: Intuitive color-based theme organization with enhanced tile selection UI and visual feedback\n- **Chunk-Based Rendering**: Efficient world rendering with dynamic loading/unloading based on player proximity\n- **Custom Shader System**: Per-face color implementation for diverse block types without texture overhead\n\n## Color System Design\n\nThe rendering system uses a color-based approach with these key features:\n\n- Direct color values instead of textures for each cube face\n- Theme classifications organized by color-based themes (BLUE, GREEN, BROWN, GRAY, GOLD, RED)\n- Colors within each theme arranged as gradients from light to dark shades\n- Central color management system (ALL_CUBE_COLORS in colorUtils.ts) defines colors for all six faces of each cube type\n- Cleaner, more intuitive color management approach with consistent naming and organization\n\n## File Structure Overview\n\n### `src/main.tsx`\n\n- Entry point for the application.\n- Sets up React rendering and mounts the `App` component.\n\n### `src/App.tsx`\n\n- Main application component.\n- Configures the overall layout and includes the `GameScene` component.\n- Manages loading state and switches between `PreloadScene` and `GameScene`.\n\n### `src/App.css`\n\n- Defines the main styles for the `App` component and its child UI elements.\n\n### `src/index.css`\n\n- Defines global base styles, Tailwind CSS directives, fonts, etc., applied throughout the application.\n\n### `src/stores/`\n\n- Directory containing state management stores using Zustand.\n  - **`gameStore.ts`**: Store that manages the overall game state. Tracks and controls the readiness state of the map physics system (`isMapPhysicsReady`). This state is used to determine physics simulation pause/resume and loading screen display.\n  - **`localPlayerStore.ts`**: Store that manages the local player's state, such as position tracking.\n  - **`multiPlayerStore.ts`**: Store that manages multiple connected players' rigid body references for multiplayer functionality, including registration, unregistration, and retrieval of player references.\n  - **`cubeStore.ts`**: Store for voxel world management that handles adding, removing, and storing block data. Also manages theme selection and controls selected block type.\n  - **`playerActionStore.ts`**: Store that manages player action states including combat actions (punch, kick, meleeAttack, cast) and block manipulation (addCube) with support for setting, getting, and resetting action states.\n\n### `src/utils/`\n\n- Directory containing utility functions for the game.\n  - **`colorUtils.ts`**: Defines and manages per-face colors for all block types and provides functions for color conversion and access.\n  - **`cubeMapGenerator.ts`**: Implements procedural cubeMap generation with multiple layers, using absolute Y-coordinates for consistent block distribution.\n\n### `src/hooks/`\n\n- Directory containing custom React hooks.\n  - **`useCubeRaycaster.tsx`**: Custom hook for block placement and removal. Implements precise raycasting for block targeting and handles mouse interactions with perfect alignment between preview and actual placement.\n\n### `src/constants/`\n\n- Directory defining constant values used throughout the application.\n  - **`controls.ts`**: Defines keyboard control mappings and sets up input configuration for character movement.\n  - **`tiles.ts`**: Defines tile types used throughout the application.\n  - **`themes.ts`**: Defines color themes and theme-based block groupings for intuitive selection.\n  - **`character.ts`**: Defines character animation states and types for player state management.\n  - **`rigidBodyObjectType.ts`**: Defines physics object types for collision detection and interaction systems.\n\n### `src/components/`\n\n- Directory managing React components.\n\n  - **`r3f/`**: Contains 3D components related to React Three Fiber.\n\n    - **`Experience.tsx`**: Sets up 3D environment including lighting, sky, and world elements. Coordinates the overall 3D scene composition.\n    - **`GameSceneCanvas.tsx`**: React Three Fiber Canvas component that renders the 3D game world with physics simulation and controller setup.\n    - **`MapPhysicsReadyChecker.tsx`**: Component that checks if the map physics system is ready by performing raycasting from above downward to detect map geometry and ensures physics interactions are properly initialized before gameplay begins. Performs checks every frame until valid map geometry is detected, with a timeout after 180 frames to prevent infinite checking. Excludes Capsule shapes (likely characters/objects) and sensor colliders from the inspection.\n    - **`Player.tsx`**: Advanced player component integrating RigidBodyPlayer with CharacterRenderer for comprehensive character management, physics interactions, and animation state management with collision detection capabilities.\n    - **`InstancedCube.tsx`**: Core voxel rendering system using instanced meshes with custom shader for optimized color-based rendering and chunk-based optimization.\n    - **`SingleCube.tsx`**: Component for rendering individual cubes with color-based faces for UI and preview purposes.\n    - **`CubePreview.tsx`**: Shows preview of block placement location with precise coordinate alignment to the actual placement position.\n    - **`Water.tsx`**: Implements water simulation with translucent rendering.\n\n  - **`scene/`**: Contains components related to scene setup.\n\n    - **`GameScene.tsx`**: Main game scene component that serves as a layout container arranging the game UI and 3D Canvas. Contains critical performance warnings and guidelines to prevent re-rendering issues. Includes the `GameSceneCanvas` and `GameSceneUI` components in a proper layered structure where the Canvas renders the 3D world and UI components render as overlays.\n    - **`PreloadScene.tsx`**: Manages asset preloading before the game starts and displays a loading progress bar.\n\n  - **`ui/`**: Contains UI components for the game interface.\n    - **`GameSceneUI.tsx`**: Component that manages UI overlays for the game scene.\n    - **`LoadingScreen.tsx`**: Loading screen component displayed during game loading.\n    - **`InputController.tsx`**: Manages all input handling including keyboard, mouse, and touch controls with virtual joystick support for mobile devices and action buttons for block manipulation.\n    - **`Crosshair.tsx`**: Displays a crosshair in the center of the screen for accurate block targeting.\n    - **`TileSelector.tsx`**: Provides UI for selecting different block types and themes with 3D preview of each block.\n\n### Key Libraries & Components from External Sources\n\n- **`vibe-starter-3d`**: A library providing foundational 3D game components and utilities.\n\n  - **`FirstPersonViewController`**: Implements a first-person camera and character controller with physics. Handles movement, looking, and interactions with the voxel world.\n  - **`FollowLight`**: A directional light that follows the character to ensure consistent lighting throughout the voxel world.\n\n- **`@react-three/rapier`**: Physics library for React Three Fiber.\n  - Provides collision detection essential for character movement and interaction with blocks\n  - Implements raycasting functionality used for block targeting and manipulation\n\n### Voxel System Implementation\n\nThe Minecraft-style voxel system is implemented through a combination of components and techniques:\n\n1. **Chunk-Based Rendering**: The world is divided into chunks that are rendered using instanced meshes for performance optimization. Only chunks near the player are loaded, allowing for efficient rendering of large worlds.\n\n2. **Block Manipulation**: The system allows players to add and remove blocks through raycasting, with visual feedback provided through the `CubePreview` component which aligns perfectly with actual placement positions.\n\n3. **Color-Based System**: Multiple block types are supported through a custom shader that applies unique colors to each face, allowing for diverse environments with minimal performance impact.\n\n4. **Advanced Player System**: The dedicated `Player` component integrates with vibe-starter-3d's `FirstPersonViewController` and `CharacterRenderer` to provide smooth first-person movement, camera control, and comprehensive animation system with state management for character actions.\n\n5. **State Management**: Zustand stores including `cubeStore` for voxel world management and `playerStore` for player reference tracking maintain comprehensive game state, handling block operations, player physics interactions, and multiplayer support in a performant way.\n\n6. **Theme System**: Color-based themes group similar colored blocks to make it easy to create structures with natural gradient effects.\n\n7. **Optimized Instance Rendering**: The custom shader and instanced mesh approach allows for efficient rendering of thousands of blocks while still applying unique colors to each face of every block.\n\n8. **Advanced CubeMap Generation**: The cubeMap is generated using a layered approach based on absolute Y-coordinates, creating natural-looking landscapes with appropriate block types at different heights.\n\n9. **Coordinate System Synchronization**: The raycasting and placement systems are carefully aligned to ensure that preview blocks appear exactly where they will be placed, making building more intuitive and precise.\n\n# Critical Memory\n\n- **Design Decision**: Use only color values for cubes instead of textures if not explicitly requested\n\n# Next Actions\n\n- **HIGHEST PRIORITY**: AI AGENT MUST IMPLEMENT CREATIVE CUBEMAP GENERATION LOGIC IMMEDIATELY. Focus on cubeMapGenerator.ts and create an impressive, varied 3D world with multiple biomes, structures, and cubeMap features. This is the most critical task for game engagement and visual appeal. Skip all other tasks until cubeMap generation is complete and visually stunning.\n\n- **SECOND PRIORITY**: AI AGENT MUST IMPLEMENT SKYBOX USING EXISTING RESOURCES AND TOOLS. Immediately utilize available skybox resources, textures, or libraries to enhance the visual environment. If suitable tools or libraries exist for skybox implementation, use them directly rather than building from scratch. The skybox should complement the cubeMap features and biomes to create a cohesive visual experience. This task should be completed efficiently using readily available resources.\n\n- **Third Priority**: AI AGENT to implement additional gameplay features after cubeMap and skybox are properly implemented.\n",
    isBinary: false,
  },
  'postcss.config.js': {
    type: 'file',
    content: 'export default {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n',
    isBinary: false,
  },
  'tsconfig.node.json': {
    type: 'file',
    content:
      '{\n  "compilerOptions": {\n    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",\n    "target": "ES2022",\n    "lib": ["ES2023"],\n    "module": "ESNext",\n    "skipLibCheck": true,\n\n    /* Bundler mode */\n    "moduleResolution": "bundler",\n    "allowImportingTsExtensions": true,\n    "isolatedModules": true,\n    "moduleDetection": "force",\n    "noEmit": true,\n\n    /* Linting */\n    "strict": false,\n    "noUnusedLocals": false,\n    "noUnusedParameters": false,\n    "noFallthroughCasesInSwitch": false,\n    "noUncheckedSideEffectImports": false\n  },\n  "include": ["vite.config.ts"]\n}\n',
    isBinary: false,
  },
  'README.md': {
    type: 'file',
    content:
      "# React + TypeScript + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:\n\n```js\nexport default tseslint.config({\n  extends: [\n    // Remove ...tseslint.configs.recommended and replace with this\n    ...tseslint.configs.recommendedTypeChecked,\n    // Alternatively, use this for stricter rules\n    ...tseslint.configs.strictTypeChecked,\n    // Optionally, add this for stylistic rules\n    ...tseslint.configs.stylisticTypeChecked,\n  ],\n  languageOptions: {\n    // other options...\n    parserOptions: {\n      project: ['./tsconfig.node.json', './tsconfig.app.json'],\n      tsconfigRootDir: import.meta.dirname,\n    },\n  },\n})\n```\n\nYou can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:\n\n```js\n// eslint.config.js\nimport reactX from 'eslint-plugin-react-x'\nimport reactDom from 'eslint-plugin-react-dom'\n\nexport default tseslint.config({\n  plugins: {\n    // Add the react-x and react-dom plugins\n    'react-x': reactX,\n    'react-dom': reactDom,\n  },\n  rules: {\n    // other rules...\n    // Enable its recommended typescript rules\n    ...reactX.configs['recommended-typescript'].rules,\n    ...reactDom.configs.recommended.rules,\n  },\n})\n```\n",
    isBinary: false,
  },
  'tsconfig.json': {
    type: 'file',
    content:
      '{\n  "files": [],\n  "references": [\n    { "path": "./tsconfig.app.json" },\n    { "path": "./tsconfig.node.json" }\n  ]\n}\n',
    isBinary: false,
  },
  'docs/project-3d-rules.md': {
    type: 'file',
    content:
      "# 3D Project Development Rules\n\n## Guideline for Using `RigidBodyObject`\n\nWhen implementing physics interactions, it is mandatory to use the `RigidBodyObject` component from the `vibe-starter-3d` package instead of the standard `RigidBody` from `@react-three/rapier`.\n\nThe primary reason for this is to simplify event handling for collisions and intersections. Using the standard `RigidBody` component requires managing a complex set of events (`onCollisionEnter`, `onCollisionExit`, `onIntersectionEnter`, `onIntersectionExit`).\n\nIn contrast, `RigidBodyObject` abstracts this complexity. It allows you to handle all physics-based interactions uniformly through just two simple trigger events: `onTriggerEnter` and `onTriggerExit`. This makes the interaction logic significantly cleaner and easier to manage.\n\n## Canvas Component Structure Rules\n\n**Core Requirement:** Components that render HTML tags (e.g., `<div>`, `<button>`) must NEVER be placed inside React Three Fiber's `<Canvas>` component.\n\n**Reasoning:**\nThis is a core architectural rule. Placing standard HTML inside the `<Canvas>` WebGL context will cause rendering errors.\n\n**Implementation Guidelines:**\n\n- **UI Components:** Components using HTML tags belong in the `src/components/ui/` directory. They must be rendered as an overlay, outside the `<Canvas>`.\n- **3D Components:** Only Three.js-related components, located in `src/components/r3f/`, should be placed inside the `<Canvas>`.\n\n**Correct Structure Example:**\n\n```tsx\n// ‚úÖ Correct approach\n<div>\n  {/* The 3D scene is rendered inside the Canvas */}\n  <Canvas>\n    <Player />\n    <Floor />\n  </Canvas>\n\n  {/* UI components are rendered as overlays outside the Canvas */}\n  <Crosshair />\n  <LoadingScreen />\n</div>\n```\n\n**Incorrect Structure Example:**\n\n```tsx\n// ‚ùå Incorrect approach\n<Canvas>\n  <Player />\n  {/* This is forbidden, as Crosshair renders HTML */}\n  <Crosshair />\n</Canvas>\n```\n",
    isBinary: false,
  },
  'public/vite.svg': {
    type: 'file',
    content:
      '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>',
    isBinary: false,
  },
  'src/App.css': {
    type: 'file',
    content: '#root {\n  margin: 0 auto;\n  text-align: center;\n}\n',
    isBinary: false,
  },
  'src/assets.json': {
    type: 'file',
    content:
      '{\n  "characters": {\n    "base-model": {\n      "url": "https://agent8-games.verse8.io/assets/3d/characters/realistic style/base-model.glb"\n    }\n  },\n  "animations": {\n    "idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle.glb",\n      "description": "Idle"\n    },\n    "idle-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle-00.glb",\n      "description": "Idle 00"\n    },\n    "idle-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/idle-01.glb",\n      "description": "Idle 01"\n    },\n    "rifle-idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/rifle-idle.glb",\n      "description": "Rifle idle"\n    },\n    "pistol-idle": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/pistol-idle.glb",\n      "description": "Pistol idle"\n    },\n    "walk": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/walk.glb",\n      "description": "Walk"\n    },\n    "run-medium": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/run-medium.glb",\n      "description": "Run Medium"\n    },\n    "run-fast": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/run-fast.glb",\n      "description": "Run Fast"\n    },\n    "rifle-run": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/rifle-run.glb",\n      "description": "Rifle Run"\n    },\n    "pistol-run": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/pistol-run.glb",\n      "description": "Pistol Run"\n    },\n    "jump": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/jump.glb",\n      "description": "Jump"\n    },\n    "swim": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/swim.glb",\n      "description": "Swim"\n    },\n    "punch-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/punch-00.glb",\n      "description": "Punch 00"\n    },\n    "punch-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/punch-01.glb",\n      "description": "Punch 01"\n    },\n    "kick-00": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-00.glb",\n      "description": "Kick 00"\n    },\n    "kick-01": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-01.glb",\n      "description": "Kick 01"\n    },\n    "kick-02": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/kick-02.glb",\n      "description": "Kick 02"\n    },\n    "melee-attack": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/melee-attack.glb",\n      "description": "Melee Attack"\n    },\n    "cast": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/cast.glb",\n      "description": "Cast"\n    },\n    "dance-locking": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/dance-locking.glb",\n      "description": "Dance Locking"\n    },\n    "dance-wave": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/dance-wave.glb",\n      "description": "Dance Wave"\n    },\n    "death-backward": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/death-backward.glb",\n      "description": "Death Backward"\n    },\n    "death-foward": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/death-foward.glb",\n      "description": "Death Foward"\n    },\n    "hit-to-body": {\n      "url": "https://agent8-games.verse8.io/assets/3d/animations/mixamorig/hit-to-body.glb",\n      "description": "Hit to Body"\n    }\n  },\n  "sprites": {\n    "minecraft": {\n      "url": "https://agent8-games.verse8.io/assets/2d/minecraft/minecraft-tiles.png",\n      "description": "Minecraft style sprites",\n      "size": {\n        "width": 80,\n        "height": 80\n      },\n      "cellSize": {\n        "width": 16,\n        "height": 16\n      }\n    },\n    "dirt": {\n      "url": "https://agent8-games.verse8.io/assets/2d/minecraft/dirt.jpg",\n      "description": "Dirt texture",\n      "size": {\n        "width": 16,\n        "height": 16\n      }\n    },\n    "grass": {\n      "url": "https://agent8-games.verse8.io/assets/2d/minecraft/grass.jpg",\n      "description": "Grass texture",\n      "size": {\n        "width": 16,\n        "height": 16\n      }\n    }\n  }\n}\n',
    isBinary: false,
  },
  'src/vite-env.d.ts': {
    type: 'file',
    content: '/// <reference types="vite/client" />\n',
    isBinary: false,
  },
  'src/main.tsx': {
    type: 'file',
    content:
      "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport App from './App';\nimport './index.css'; // Import Tailwind CSS styles\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n",
    isBinary: false,
  },
  'src/App.tsx': {
    type: 'file',
    content:
      "import React, { useState } from 'react';\nimport './App.css';\nimport GameScene from './components/scene/GameScene';\nimport PreloadScene from './components/scene/PreloadScene';\n\nconst App: React.FC = () => {\n  const [isLoading, setIsLoading] = useState(true);\n\n  const handleLoadingComplete = () => {\n    setIsLoading(false);\n  };\n\n  return <div style={{ width: '100vw', height: '100vh' }}>{isLoading ? <PreloadScene onComplete={handleLoadingComplete} /> : <GameScene />}</div>;\n};\n\nexport default App;\n",
    isBinary: false,
  },
  'src/index.css': {
    type: 'file',
    content: '@tailwind base;\n@tailwind components;\n@tailwind utilities;\n',
    isBinary: false,
  },
  'src/constants/rigidBodyObjectType.ts': {
    type: 'file',
    content:
      "export const RigidBodyObjectType = {\n  /** Local Player */\n  LOCAL_PLAYER: 'LOCAL_PLAYER',\n  /** Enemy */\n  ENEMY: 'ENEMY',\n  /** Monster */\n  MONSTER: 'MONSTER',\n  /** Wall */\n  WALL: 'WALL',\n  /** Obstacle */\n  OBSTACLE: 'OBSTACLE',\n  /** Item */\n  ITEM: 'ITEM',\n  /** Bullet */\n  BULLET: 'BULLET',\n  /** Floor */\n  FLOOR: 'FLOOR',\n  /** Floating board */\n  PLOTTING_BOARD: 'PLOTTING_BOARD',\n} as const;\n",
    isBinary: false,
  },
  'src/constants/character.ts': {
    type: 'file',
    content:
      "import { AnimationType } from 'vibe-starter-3d';\n\nexport const CharacterState: { [key: string]: AnimationType } = {\n  /** IDLE ACTION */\n  IDLE: 'IDLE',\n  /** IDLE ACTION */\n  IDLE_01: 'IDLE_01',\n  /** WALKING ACTION */\n  WALK: 'WALK',\n  /** RUNNING ACTION */\n  RUN: 'RUN',\n  /** SPRINTING ACTION */\n  FAST_RUN: 'FAST_RUN',\n  /** JUMP ACTION */\n  JUMP: 'JUMP',\n  /** PUNCH ACTION */\n  PUNCH: 'PUNCH',\n  /** PUNCH ACTION */\n  PUNCH_01: 'PUNCH_01',\n  /** KICK ACTION */\n  KICK: 'KICK',\n  /** KICK ACTION */\n  KICK_01: 'KICK_01',\n  /** KICK ACTION */\n  KICK_02: 'KICK_02',\n  /** MELEE ATTACK ACTION */\n  MELEE_ATTACK: 'MELEE_ATTACK',\n  /** CAST ACTION */\n  CAST: 'CAST',\n  /** HIT ACTION */\n  HIT: 'HIT',\n  /** DIE ACTION */\n  DIE: 'DIE',\n};\n\nexport type CharacterState = (typeof CharacterState)[keyof typeof CharacterState];\n",
    isBinary: false,
  },
  'src/constants/tiles.ts': {
    type: 'file',
    content:
      '// Extended tile types (25 types)\nexport const TILE_TYPES = {\n  // Basic blocks - first row\n  GRASS: 1, // Green top grass block\n  DIRT: 2, // Brown dirt block\n  STONE: 3, // Gray stone block\n  COBBLESTONE: 4, // Textured stone block\n  BEDROCK: 5, // Dark gray bedrock\n\n  // More blocks - second row\n  WOOD_PLANKS: 6, // Wooden planks\n  SAPLING: 7, // Small tree sapling\n  BEDROCK_2: 8, // Alternative bedrock\n  WATER: 9, // Blue water\n  LAVA: 10, // Orange lava\n\n  // Third row\n  SAND: 11, // Yellow sand\n  GRAVEL: 12, // Gray gravel\n  GOLD_ORE: 13, // Gold ore in stone\n  IRON_ORE: 14, // Iron ore in stone\n  COAL_ORE: 15, // Coal ore in stone\n\n  // Fourth row\n  WOOD: 16, // Tree trunk\n  LEAVES: 17, // Tree leaves\n  GLASS: 18, // Transparent glass\n  WOOL_WHITE: 19, // White wool\n  FLOWER_YELLOW: 20, // Yellow flower\n\n  // Fifth row\n  FLOWER_RED: 21, // Red flower\n  MUSHROOM_BROWN: 22, // Brown mushroom\n  MUSHROOM_RED: 23, // Red mushroom\n  GOLD_BLOCK: 24, // Solid gold block\n  IRON_BLOCK: 25, // Solid iron block\n};\n',
    isBinary: false,
  },
  'src/constants/themes.ts': {
    type: 'file',
    content:
      "import { TILE_TYPES } from './tiles';\n\n/**\n * Tile theme definitions\n */\nexport enum THEMES {\n  ALL = 'all', // All tiles\n  BLUE = 'blue', // Blue colors (water, sky, glass)\n  GREEN = 'green', // Green colors (grass, leaves)\n  BROWN = 'brown', // Brown colors (dirt, wood)\n  GRAY = 'gray', // Gray colors (stone, gravel)\n  GOLD = 'gold', // Gold colors (gold ore, sand)\n  RED = 'red', // Red colors (lava, flowers)\n}\n\n/**\n * Theme display names\n */\nexport const THEME_NAMES: Record<THEMES, string> = {\n  [THEMES.ALL]: 'All Blocks',\n  [THEMES.BLUE]: 'Blue',\n  [THEMES.GREEN]: 'Green',\n  [THEMES.BROWN]: 'Brown',\n  [THEMES.GRAY]: 'Gray',\n  [THEMES.GOLD]: 'Gold',\n  [THEMES.RED]: 'Red',\n};\n\n/**\n * Tile groups by theme - organized for gradient effects\n */\nexport const THEME_TILES: Record<THEMES, number[]> = {\n  // All tiles (empty array means all tiles)\n  [THEMES.ALL]: [],\n\n  // Blue colors (light sky blue ‚Üí deep blue)\n  [THEMES.BLUE]: [\n    18, // Glass (cyan)\n    19, // White wool (used as light blue)\n    9, // Water (blue)\n    23, // Red mushroom (used as purple)\n  ],\n\n  // Green colors (light lime ‚Üí dark green)\n  [THEMES.GREEN]: [\n    7, // Sapling (lime green)\n    1, // Grass (green top)\n    17, // Leaves (dark green)\n  ],\n\n  // Brown colors (light beige ‚Üí dark brown)\n  [THEMES.BROWN]: [\n    6, // Wooden planks (light brown)\n    2, // Dirt (brown)\n    16, // Wood trunk (dark brown)\n    22, // Brown mushroom (very dark brown)\n  ],\n\n  // Gray colors (light gray ‚Üí black)\n  [THEMES.GRAY]: [\n    25, // Iron block (light gray)\n    12, // Gravel (gray)\n    3, // Stone (slightly dark gray)\n    4, // Cobblestone (dark gray)\n    15, // Coal ore (deep gray)\n    8, // Bedrock 2 (very dark gray)\n    5, // Bedrock (almost black)\n  ],\n\n  // Gold/yellow colors (bright yellow ‚Üí orange)\n  [THEMES.GOLD]: [\n    20, // Yellow flower (bright yellow)\n    24, // Gold block (gold)\n    11, // Sand (sand color)\n    13, // Gold ore (light gold)\n  ],\n\n  // Red colors (pink ‚Üí red ‚Üí orange)\n  [THEMES.RED]: [\n    21, // Red flower (red)\n    14, // Iron ore (reddish brown)\n    10, // Lava (orange)\n  ],\n};\n\n/**\n * Theme descriptions (description for the selected theme)\n */\nexport const THEME_DESCRIPTIONS: Record<THEMES, string> = {\n  [THEMES.ALL]: 'You can use all available blocks.',\n  [THEMES.BLUE]: 'Create gradient effects from light sky blue to deep blue.',\n  [THEMES.GREEN]: 'Express natural plant gradients from lime green to dark green.',\n  [THEMES.BROWN]: 'Create natural soil gradients from light wood to dark earth tones.',\n  [THEMES.GRAY]: 'Express stone and rock gradients from light gray to deep black.',\n  [THEMES.GOLD]: 'Create vibrant gradients from bright yellow to gold colors.',\n  [THEMES.RED]: 'Express warm color gradients from red to orange tones.',\n};\n\n/**\n * Theme icons (Emoji)\n */\nexport const THEME_ICONS: Record<THEMES, string> = {\n  [THEMES.ALL]: 'üß±',\n  [THEMES.BLUE]: 'üî∑',\n  [THEMES.GREEN]: 'üåø',\n  [THEMES.BROWN]: 'üü§',\n  [THEMES.GRAY]: '‚¨ú',\n  [THEMES.GOLD]: 'üü°',\n  [THEMES.RED]: 'üî¥',\n};\n\n/**\n * Find themes that contain a tile index\n * @param tileIndex Tile index\n * @returns List of themes that contain the tile\n */\nexport const findThemesByTileIndex = (tileIndex: number): THEMES[] => {\n  const themes: THEMES[] = [];\n\n  // All theme is included by default\n  themes.push(THEMES.ALL);\n\n  // Check other themes\n  Object.entries(THEME_TILES).forEach(([theme, tiles]) => {\n    if (theme !== THEMES.ALL && (tiles.includes(tileIndex) || tiles.length === 0)) {\n      themes.push(theme as THEMES);\n    }\n  });\n\n  return themes;\n};\n\n/**\n * Convert tile type to theme index\n * @param tileType Tile type\n * @returns Array index corresponding to the tile type\n */\nexport const getTileIndexFromType = (tileType: number): number => {\n  const tileTypeValues = Object.values(TILE_TYPES);\n  return tileTypeValues.indexOf(tileType);\n};\n\n/**\n * Get tile index list for a theme\n * @param theme Theme\n * @returns List of tile indices for the theme\n */\nexport const getThemeTileIndices = (theme: THEMES): number[] => {\n  // Return all indices if the theme is ALL\n  if (theme === THEMES.ALL) {\n    return Array.from({ length: Object.keys(TILE_TYPES).length }, (_, i) => i);\n  }\n\n  // Return tile indices specified for the theme (already stored as indices)\n  return THEME_TILES[theme];\n};\n",
    isBinary: false,
  },
  'src/utils/cubeMapGenerator.ts': {
    type: 'file',
    content:
      "import { createNoise2D, createNoise3D } from 'simplex-noise';\nimport { TILE_TYPES } from '../constants/tiles';\n\n// TODO: Define your own biomes here!\nexport const BIOMES = {\n  PLAINS: 'plains',\n  MOUNTAINS: 'mountains',\n  DESERT: 'desert',\n  // TODO: Add more biomes\n  // FOREST: 'forest',\n  // TUNDRA: 'tundra',\n  // VOLCANIC: 'volcanic',\n  // CRYSTAL: 'crystal',\n  // MUSHROOM: 'mushroom',\n  // UNDERWATER: 'underwater',\n  // FLOATING_ISLANDS: 'floating_islands',\n};\n\n// TODO: Configure your cubeMap generation parameters\nexport const CUBEMAP_CONFIG = {\n  // Basic settings\n  scale: 0.03,\n  amplitude: 18,\n  baseHeight: 5,\n\n  // TODO: Add your own configuration parameters\n  // biomeScale: 0.008,\n  // caveScale: 0.05,\n  // caveDensity: 0.3,\n  // featureProbability: 0.003,\n};\n\n// TODO: Define your biome characteristics\nexport const BIOME_MODIFIERS = {\n  // Example:\n  [BIOMES.PLAINS]: {\n    heightScale: 0.8,\n    surfaceTile: TILE_TYPES.GRASS,\n    // TODO: Add more properties\n  },\n  // TODO: Add modifiers for your other biomes\n};\n\n// TODO: Define your structures\nexport const STRUCTURES = {\n  // Example:\n  SMALL_TREE: {\n    // TODO: Define structure properties\n  },\n  // TODO: Add more structures\n  // LARGE_TREE: {},\n  // HOUSE: {},\n  // CAVE: {},\n};\n\n/**\n * Creates a deterministic noise function from a seed string\n */\nexport function createSeedBasedNoise(seed: string, dimension: '2d' | '3d' = '2d') {\n  // Generate a numeric seed from the string\n  let numericSeed = 0;\n  for (let i = 0; i < seed.length; i++) {\n    numericSeed = ((numericSeed << 5) - numericSeed + seed.charCodeAt(i)) | 0;\n  }\n\n  // Create a seeded random number generator\n  const seededRandom = () => {\n    numericSeed = (numericSeed * 9301 + 49297) % 233280;\n    return numericSeed / 233280;\n  };\n\n  // Return the appropriate noise function\n  return dimension === '2d' ? createNoise2D(seededRandom) : createNoise3D(seededRandom);\n}\n\n/**\n * Cube information interface\n */\nexport interface GeneratedCube {\n  position: [number, number, number];\n  tileIndex: number;\n}\n\n/**\n * CubeMap generation function\n *\n * TODO: This is where your creativity comes in! Implement your own cubeMap generation logic.\n * Some ideas:\n * - Create floating islands\n * - Generate cave systems\n * - Make mountain ranges\n * - Add underwater features\n * - Create custom biomes\n * - Implement rivers, lakes, or oceans\n * - Add special structures\n */\nexport function generateCubeMap(seed: string, width: number = 160, depth: number = 160): GeneratedCube[] {\n  console.log(`Generating cubeMap with seed: ${seed}`);\n\n  // Create noise functions\n  const cubeMapNoise = createSeedBasedNoise(seed + '-cubemap');\n  // TODO: Create more noise functions as needed\n\n  // Create cube array\n  const cubes: GeneratedCube[] = [];\n\n  // Calculate offsets to center the terrain around (0,0)\n  const xOffset = Math.floor(width / 2);\n  const zOffset = Math.floor(depth / 2);\n\n  // Basic flat cubeMap example\n  // TODO: Replace with your own cubeMap generation logic!\n  for (let x = 0; x < width; x++) {\n    for (let z = 0; z < depth; z++) {\n      // Generate a simple height using noise\n      const nx = x * CUBEMAP_CONFIG.scale;\n      const nz = z * CUBEMAP_CONFIG.scale;\n      // Add 0 as the third parameter for 2D noise\n      const height = Math.floor((cubeMapNoise(nx, nz, 0) + 1) * 5) + CUBEMAP_CONFIG.baseHeight;\n\n      // Calculate centered positions\n      const xPos = x - xOffset;\n      const zPos = z - zOffset;\n\n      // Add blocks from bottom to top\n      for (let y = 0; y <= height; y++) {\n        let tileType;\n\n        // Simple layer-based tile assignment\n        // TODO: Implement your own tile selection logic\n        if (y === 0) {\n          tileType = TILE_TYPES.BEDROCK;\n        } else if (y < height - 1) {\n          tileType = TILE_TYPES.DIRT;\n        } else {\n          tileType = TILE_TYPES.GRASS;\n        }\n\n        cubes.push({\n          position: [xPos, y, zPos],\n          tileIndex: tileType,\n        });\n      }\n\n      // TODO: Add your own features here!\n      // - Trees, rocks, flowers\n      // - Caves, tunnels\n      // - Structures\n      // - Biome-specific features\n    }\n  }\n\n  return cubes;\n}\n\n/**\n * Determines the biome at a given position\n *\n * TODO: Implement your own biome selection logic!\n */\nexport function getBiomeAt(x: number, z: number, biomeNoise: ReturnType<typeof createNoise2D>): string {\n  // TODO: Replace with your own biome selection logic\n  return BIOMES.PLAINS;\n}\n\n/**\n * Generates a special structure at the given position\n *\n * TODO: Implement your own structure generation logic!\n */\nexport function generateStructure(x: number, y: number, z: number, structureType: keyof typeof STRUCTURES, cubes: GeneratedCube[]): void {\n  // TODO: Implement your structure generation logic\n}\n\n/**\n * Generates a cave system\n *\n * TODO: Implement your own cave generation logic!\n */\nexport function generateCaves(x: number, y: number, z: number, caveNoise: ReturnType<typeof createNoise3D>): boolean {\n  // TODO: Implement your cave generation logic\n  return false;\n}\n\n/**\n * Post-processing for the cubeMap\n *\n * TODO: Implement your own post-processing logic!\n * - Smooth cubeMap\n * - Create rivers\n * - Add paths\n */\nexport function postProcessCubeMap(cubes: GeneratedCube[]): GeneratedCube[] {\n  // TODO: Implement your post-processing logic\n  return cubes;\n}\n",
    isBinary: false,
  },
  'src/utils/colorUtils.ts': {
    type: 'file',
    content:
      "import * as THREE from 'three';\nimport { TILE_TYPES } from '../constants/tiles';\n\n// Face index definition (for reference)\nexport const FACE_INDEX = {\n  FRONT: 0, // Front\n  RIGHT: 1, // Right\n  BACK: 2, // Back\n  LEFT: 3, // Left\n  TOP: 4, // Top\n  BOTTOM: 5, // Bottom\n};\n\n// Define all colors for all faces of all tiles directly\nexport const ALL_CUBE_COLORS: Record<number, Array<{ r: number; g: number; b: number }>> = {\n  // Tile 0 (Default gray)\n  0: [\n    { r: 0.4, g: 0.4, b: 0.4 }, // Front\n    { r: 0.4, g: 0.4, b: 0.4 }, // Right\n    { r: 0.4, g: 0.4, b: 0.4 }, // Back\n    { r: 0.4, g: 0.4, b: 0.4 }, // Left\n    { r: 0.4, g: 0.4, b: 0.4 }, // Top\n    { r: 0.4, g: 0.4, b: 0.4 }, // Bottom\n  ],\n\n  // Tile 1 (Grass)\n  1: [\n    { r: 0.6, g: 0.3, b: 0.0 }, // Front (Dirt)\n    { r: 0.6, g: 0.3, b: 0.0 }, // Right (Dirt)\n    { r: 0.6, g: 0.3, b: 0.0 }, // Back (Dirt)\n    { r: 0.6, g: 0.3, b: 0.0 }, // Left (Dirt)\n    { r: 0.0, g: 0.8, b: 0.0 }, // Top (Green grass)\n    { r: 0.6, g: 0.3, b: 0.0 }, // Bottom (Dirt)\n  ],\n\n  // Tile 2 (Dirt)\n  2: [\n    { r: 0.6, g: 0.3, b: 0.0 }, // Front\n    { r: 0.6, g: 0.3, b: 0.0 }, // Right\n    { r: 0.6, g: 0.3, b: 0.0 }, // Back\n    { r: 0.6, g: 0.3, b: 0.0 }, // Left\n    { r: 0.6, g: 0.3, b: 0.0 }, // Top\n    { r: 0.6, g: 0.3, b: 0.0 }, // Bottom\n  ],\n\n  // Tile 3 (Stone)\n  3: [\n    { r: 0.6, g: 0.55, b: 0.5 }, // Front\n    { r: 0.55, g: 0.5, b: 0.45 }, // Right\n    { r: 0.5, g: 0.45, b: 0.4 }, // Back\n    { r: 0.55, g: 0.5, b: 0.45 }, // Left\n    { r: 0.65, g: 0.6, b: 0.55 }, // Top\n    { r: 0.5, g: 0.45, b: 0.4 }, // Bottom\n  ],\n\n  // Tile 4 (Gravel)\n  4: [\n    { r: 0.45, g: 0.45, b: 0.4 }, // Front\n    { r: 0.4, g: 0.4, b: 0.35 }, // Right\n    { r: 0.35, g: 0.35, b: 0.3 }, // Back\n    { r: 0.4, g: 0.4, b: 0.35 }, // Left\n    { r: 0.5, g: 0.5, b: 0.45 }, // Top\n    { r: 0.35, g: 0.35, b: 0.3 }, // Bottom\n  ],\n\n  // Tile 5 (Bedrock)\n  5: [\n    { r: 0.2, g: 0.2, b: 0.2 }, // Front\n    { r: 0.2, g: 0.2, b: 0.2 }, // Right\n    { r: 0.2, g: 0.2, b: 0.2 }, // Back\n    { r: 0.2, g: 0.2, b: 0.2 }, // Left\n    { r: 0.2, g: 0.2, b: 0.2 }, // Top\n    { r: 0.2, g: 0.2, b: 0.2 }, // Bottom\n  ],\n\n  // Tile 6 (Wooden Planks)\n  6: [\n    { r: 0.8, g: 0.5, b: 0.2 }, // Front\n    { r: 0.75, g: 0.45, b: 0.15 }, // Right\n    { r: 0.7, g: 0.4, b: 0.1 }, // Back\n    { r: 0.75, g: 0.45, b: 0.15 }, // Left\n    { r: 0.85, g: 0.55, b: 0.25 }, // Top\n    { r: 0.7, g: 0.4, b: 0.1 }, // Bottom\n  ],\n\n  // Tile 7 (Small Tree Sapling)\n  7: [\n    { r: 0.0, g: 0.7, b: 0.1 }, // Front\n    { r: 0.0, g: 0.65, b: 0.1 }, // Right\n    { r: 0.0, g: 0.6, b: 0.1 }, // Back\n    { r: 0.0, g: 0.65, b: 0.1 }, // Left\n    { r: 0.0, g: 0.75, b: 0.1 }, // Top\n    { r: 0.0, g: 0.6, b: 0.1 }, // Bottom\n  ],\n\n  // Tile 8 (Alternative Bedrock)\n  8: [\n    { r: 0.3, g: 0.3, b: 0.3 }, // Front\n    { r: 0.3, g: 0.3, b: 0.3 }, // Right\n    { r: 0.3, g: 0.3, b: 0.3 }, // Back\n    { r: 0.3, g: 0.3, b: 0.3 }, // Left\n    { r: 0.3, g: 0.3, b: 0.3 }, // Top\n    { r: 0.3, g: 0.3, b: 0.3 }, // Bottom\n  ],\n\n  // Tile 9 (Water)\n  9: [\n    { r: 0.0, g: 0.0, b: 0.7 }, // Front\n    { r: 0.0, g: 0.0, b: 0.7 }, // Right\n    { r: 0.0, g: 0.0, b: 0.7 }, // Back\n    { r: 0.0, g: 0.0, b: 0.7 }, // Left\n    { r: 0.0, g: 0.2, b: 0.9 }, // Top\n    { r: 0.0, g: 0.0, b: 0.6 }, // Bottom\n  ],\n\n  // Tile 10 (Lava)\n  10: [\n    { r: 0.9, g: 0.3, b: 0.0 }, // Front\n    { r: 0.9, g: 0.3, b: 0.0 }, // Right\n    { r: 0.9, g: 0.3, b: 0.0 }, // Back\n    { r: 0.9, g: 0.3, b: 0.0 }, // Left\n    { r: 1.0, g: 0.4, b: 0.0 }, // Top\n    { r: 0.7, g: 0.2, b: 0.0 }, // Bottom\n  ],\n\n  // Tile 11 (Sand)\n  11: [\n    { r: 0.9, g: 0.8, b: 0.2 }, // Front\n    { r: 0.85, g: 0.75, b: 0.18 }, // Right\n    { r: 0.85, g: 0.75, b: 0.18 }, // Back\n    { r: 0.85, g: 0.75, b: 0.18 }, // Left\n    { r: 0.95, g: 0.85, b: 0.25 }, // Top\n    { r: 0.85, g: 0.75, b: 0.18 }, // Bottom\n  ],\n\n  // Tile 12 (Gravel)\n  12: [\n    { r: 0.6, g: 0.6, b: 0.6 }, // Front\n    { r: 0.55, g: 0.55, b: 0.55 }, // Right\n    { r: 0.5, g: 0.5, b: 0.5 }, // Back\n    { r: 0.55, g: 0.55, b: 0.55 }, // Left\n    { r: 0.65, g: 0.65, b: 0.65 }, // Top\n    { r: 0.5, g: 0.5, b: 0.5 }, // Bottom\n  ],\n\n  // Tile 13 (Gold Ore)\n  13: [\n    { r: 0.7, g: 0.7, b: 0.4 }, // Front\n    { r: 0.65, g: 0.65, b: 0.35 }, // Right\n    { r: 0.6, g: 0.6, b: 0.3 }, // Back\n    { r: 0.65, g: 0.65, b: 0.35 }, // Left\n    { r: 0.75, g: 0.75, b: 0.45 }, // Top\n    { r: 0.6, g: 0.6, b: 0.3 }, // Bottom\n  ],\n\n  // Tile 14 (Iron Ore)\n  14: [\n    { r: 0.7, g: 0.5, b: 0.5 }, // Front\n    { r: 0.65, g: 0.45, b: 0.45 }, // Right\n    { r: 0.6, g: 0.4, b: 0.4 }, // Back\n    { r: 0.65, g: 0.45, b: 0.45 }, // Left\n    { r: 0.75, g: 0.55, b: 0.55 }, // Top\n    { r: 0.6, g: 0.4, b: 0.4 }, // Bottom\n  ],\n\n  // Tile 15 (Coal Ore)\n  15: [\n    { r: 0.35, g: 0.3, b: 0.25 }, // Front\n    { r: 0.3, g: 0.25, b: 0.2 }, // Right\n    { r: 0.25, g: 0.2, b: 0.15 }, // Back\n    { r: 0.3, g: 0.25, b: 0.2 }, // Left\n    { r: 0.4, g: 0.35, b: 0.3 }, // Top\n    { r: 0.25, g: 0.2, b: 0.15 }, // Bottom\n  ],\n\n  // Tile 16 (Wood Trunk)\n  16: [\n    { r: 0.5, g: 0.3, b: 0.0 }, // Front\n    { r: 0.5, g: 0.3, b: 0.0 }, // Right\n    { r: 0.5, g: 0.3, b: 0.0 }, // Back\n    { r: 0.5, g: 0.3, b: 0.0 }, // Left\n    { r: 0.7, g: 0.4, b: 0.1 }, // Top\n    { r: 0.7, g: 0.4, b: 0.1 }, // Bottom\n  ],\n\n  // Tile 17 (Leaves)\n  17: [\n    { r: 0.0, g: 0.5, b: 0.0 }, // Front\n    { r: 0.0, g: 0.45, b: 0.0 }, // Right\n    { r: 0.0, g: 0.45, b: 0.0 }, // Back\n    { r: 0.0, g: 0.45, b: 0.0 }, // Left\n    { r: 0.0, g: 0.6, b: 0.0 }, // Top\n    { r: 0.0, g: 0.4, b: 0.0 }, // Bottom\n  ],\n\n  // Tile 18 (Glass)\n  18: [\n    { r: 0.2, g: 0.8, b: 0.8 }, // Front\n    { r: 0.15, g: 0.7, b: 0.7 }, // Right\n    { r: 0.1, g: 0.6, b: 0.6 }, // Back\n    { r: 0.15, g: 0.7, b: 0.7 }, // Left\n    { r: 0.3, g: 0.9, b: 0.9 }, // Top\n    { r: 0.1, g: 0.6, b: 0.6 }, // Bottom\n  ],\n\n  // Tile 19 (White Wool)\n  19: [\n    { r: 1.0, g: 0.5, b: 0.8 }, // Front\n    { r: 0.9, g: 0.4, b: 0.7 }, // Right\n    { r: 0.8, g: 0.3, b: 0.6 }, // Back\n    { r: 0.9, g: 0.4, b: 0.7 }, // Left\n    { r: 1.0, g: 0.6, b: 0.9 }, // Top\n    { r: 0.8, g: 0.3, b: 0.6 }, // Bottom\n  ],\n\n  // Tile 20 (Yellow Flower)\n  20: [\n    { r: 1.0, g: 0.9, b: 0.3 }, // Front\n    { r: 0.95, g: 0.85, b: 0.25 }, // Right\n    { r: 0.9, g: 0.8, b: 0.2 }, // Back\n    { r: 0.95, g: 0.85, b: 0.25 }, // Left\n    { r: 1.0, g: 1.0, b: 0.4 }, // Top\n    { r: 0.9, g: 0.8, b: 0.2 }, // Bottom\n  ],\n\n  // Tile 21 (Red Flower)\n  21: [\n    { r: 1.0, g: 0.0, b: 0.0 }, // Front\n    { r: 0.9, g: 0.0, b: 0.0 }, // Right\n    { r: 0.8, g: 0.0, b: 0.0 }, // Back\n    { r: 0.9, g: 0.0, b: 0.0 }, // Left\n    { r: 1.0, g: 0.2, b: 0.2 }, // Top\n    { r: 0.8, g: 0.0, b: 0.0 }, // Bottom\n  ],\n\n  // Tile 22 (Brown Mushroom)\n  22: [\n    { r: 0.6, g: 0.4, b: 0.2 }, // Front\n    { r: 0.5, g: 0.3, b: 0.15 }, // Right\n    { r: 0.4, g: 0.25, b: 0.1 }, // Back\n    { r: 0.5, g: 0.3, b: 0.15 }, // Left\n    { r: 0.7, g: 0.45, b: 0.25 }, // Top\n    { r: 0.4, g: 0.25, b: 0.1 }, // Bottom\n  ],\n\n  // Tile 23 (Red Mushroom)\n  23: [\n    { r: 0.6, g: 0.2, b: 0.8 }, // Front\n    { r: 0.5, g: 0.15, b: 0.7 }, // Right\n    { r: 0.4, g: 0.1, b: 0.6 }, // Back\n    { r: 0.5, g: 0.15, b: 0.7 }, // Left\n    { r: 0.7, g: 0.25, b: 0.9 }, // Top\n    { r: 0.4, g: 0.1, b: 0.6 }, // Bottom\n  ],\n\n  // Tile 24 (Gold Block)\n  24: [\n    { r: 1.0, g: 0.8, b: 0.0 }, // Front\n    { r: 0.95, g: 0.75, b: 0.0 }, // Right\n    { r: 0.95, g: 0.75, b: 0.0 }, // Back\n    { r: 0.95, g: 0.75, b: 0.0 }, // Left\n    { r: 1.0, g: 0.9, b: 0.0 }, // Top\n    { r: 0.9, g: 0.7, b: 0.0 }, // Bottom\n  ],\n\n  // Tile 25 (Iron Block)\n  25: [\n    { r: 0.6, g: 0.65, b: 0.7 }, // Front\n    { r: 0.55, g: 0.6, b: 0.65 }, // Right\n    { r: 0.5, g: 0.55, b: 0.6 }, // Back\n    { r: 0.55, g: 0.6, b: 0.65 }, // Left\n    { r: 0.65, g: 0.7, b: 0.75 }, // Top\n    { r: 0.5, g: 0.55, b: 0.6 }, // Bottom\n  ],\n};\n\n/**\n * Convert from index to tile type\n * @param index Tile index (0-based)\n * @returns Tile type value (1-based)\n */\nexport const getTileTypeFromIndex = (index: number): number => {\n  // Get array of values from TILE_TYPES\n  const tileTypeValues = Object.values(TILE_TYPES);\n  // Return the corresponding tile type if index is valid, otherwise return default (0)\n  return index >= 0 && index < tileTypeValues.length ? tileTypeValues[index] : 0;\n};\n\n/**\n * Return color based on tile index and face direction\n * @param index Tile index\n * @param faceDirection Face direction (0-5)\n * @returns RGB color object\n */\nexport const getColorByFace = (index: number, faceDirection: number): { r: number; g: number; b: number } => {\n  // Default color (gray)\n  const defaultColor = { r: 0.5, g: 0.5, b: 0.5 };\n\n  // Return the color for the specified face and index\n  if (ALL_CUBE_COLORS[index] && ALL_CUBE_COLORS[index][faceDirection]) {\n    return ALL_CUBE_COLORS[index][faceDirection];\n  }\n\n  // Return default color if the specified color doesn't exist\n  return defaultColor;\n};\n\n/**\n * Convert to Three.js Color object\n * @param color RGB color object\n * @returns THREE.Color object\n */\nexport const getThreeColor = (color: { r: number; g: number; b: number }): THREE.Color => {\n  return new THREE.Color(color.r, color.g, color.b);\n};\n",
    isBinary: false,
  },
  'src/stores/localPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport * as THREE from 'three';\n\ntype PlayerState = {\n  position: THREE.Vector3;\n  speed: number;\n};\n\ntype LocalPlayerState = {\n  state: PlayerState;\n  setSpeed: (speed: number) => void;\n  setPosition: (x: number, y: number, z: number) => void;\n  clearPosition: () => void;\n};\n\nexport const useLocalPlayerStore = create<LocalPlayerState>()(\n  subscribeWithSelector((_, get) => ({\n    state: {\n      position: new THREE.Vector3(0, 0, 0),\n      speed: 0,\n    },\n\n    setSpeed: (speed: number) => {\n      get().state.speed = speed;\n    },\n\n    setPosition: (x: number, y: number, z: number) => {\n      const state = get().state;\n      state.position.x = x;\n      state.position.y = y;\n      state.position.z = z;\n    },\n\n    clearPosition: () => {\n      const state = get().state;\n      state.position.x = 0;\n      state.position.y = 0;\n      state.position.z = 0;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/multiPlayerStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\nimport React from 'react';\nimport { RigidBody } from '@dimforge/rapier3d-compat';\n\ntype MultiPlayerRigidBodyState = {\n  connectedPlayerRefs: Record<string, React.RefObject<RigidBody>>;\n  registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => void;\n  unregisterConnectedPlayer: (account: string) => void;\n  getConnectedPlayerRef: (account: string) => React.RefObject<RigidBody> | undefined;\n  getAllConnectedPlayerRefs: () => Record<string, React.RefObject<RigidBody>>;\n  getConnectedPlayerCount: () => number;\n};\n\nexport const useMultiPlayerStore = create<MultiPlayerRigidBodyState>()(\n  subscribeWithSelector((set, get) => ({\n    connectedPlayerRefs: {},\n\n    registerConnectedPlayer: (account: string, rigidBodyRef: React.RefObject<RigidBody>) => {\n      set((state) => ({\n        connectedPlayerRefs: {\n          ...state.connectedPlayerRefs,\n          [account]: rigidBodyRef,\n        },\n      }));\n    },\n\n    unregisterConnectedPlayer: (account: string) => {\n      set((state) => {\n        const newConnectedPlayerRefs = { ...state.connectedPlayerRefs };\n        delete newConnectedPlayerRefs[account];\n        return { connectedPlayerRefs: newConnectedPlayerRefs };\n      });\n    },\n\n    getConnectedPlayerRef: (account: string) => {\n      return get().connectedPlayerRefs[account];\n    },\n\n    getAllConnectedPlayerRefs: () => {\n      return get().connectedPlayerRefs;\n    },\n\n    getConnectedPlayerCount: () => {\n      return Object.keys(get().connectedPlayerRefs).length;\n    },\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/playerActionStore.ts': {
    type: 'file',
    content:
      'interface PlayerActionState {\n  punch: boolean;\n  kick: boolean;\n  meleeAttack: boolean;\n  cast: boolean;\n  addCube: boolean;\n}\n\ninterface PlayerActionStore extends PlayerActionState {\n  setPlayerAction: (action: string, pressed: boolean) => void;\n  getPlayerAction: (action: string) => boolean;\n  resetAllPlayerActions: () => void;\n}\n\nconst playerActionStore: PlayerActionStore = {\n  punch: false,\n  kick: false,\n  meleeAttack: false,\n  cast: false,\n  addCube: false,\n\n  setPlayerAction: (action: string, pressed: boolean) => {\n    (playerActionStore as any)[action] = pressed;\n  },\n\n  getPlayerAction: (action: string): boolean => {\n    return (playerActionStore as any)[action];\n  },\n\n  resetAllPlayerActions: () => {\n    playerActionStore.punch = false;\n    playerActionStore.kick = false;\n    playerActionStore.meleeAttack = false;\n    playerActionStore.cast = false;\n    playerActionStore.addCube = false;\n  },\n};\n\nexport const usePlayerActionStore = () => playerActionStore;',
    isBinary: false,
  },
  'src/stores/gameStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { subscribeWithSelector } from 'zustand/middleware';\n\ninterface GameStore {\n  isMapPhysicsReady: boolean;\n  setMapPhysicsReady: (ready: boolean) => void;\n}\n\nexport const useGameStore = create<GameStore>()(\n  subscribeWithSelector((set) => ({\n    isMapPhysicsReady: false,\n    setMapPhysicsReady: (ready: boolean) => set({ isMapPhysicsReady: ready }),\n  })),\n);\n",
    isBinary: false,
  },
  'src/stores/cubeStore.ts': {
    type: 'file',
    content:
      "import { create } from 'zustand';\nimport { TILE_TYPES } from '../constants/tiles';\nimport { THEMES, getThemeTileIndices } from '../constants/themes';\nimport { getTileTypeFromIndex } from '../utils/colorUtils';\nimport { generateCubeMap, GeneratedCube } from '../utils/cubeMapGenerator';\n\n// Seed value constant\nconst DEFAULT_SEED = import.meta.env.VITE_AGENT8_VERSE || 'minecraft123';\n\n// Single cubeMap configuration value\nconst CUBEMAP_CONFIG = {\n  width: 80,\n  depth: 80,\n};\n\n// Cube information interface - storing tileIndex directly without conversion\ninterface CubeInfo {\n  position: [number, number, number]; // Cube position\n  tileIndex: number; // Tile index (not tile type)\n}\n\n// Create a mapping table to convert from array index to tile type\nconst TILE_INDEX_MAP = Object.values(TILE_TYPES).reduce(\n  (map, val, idx) => {\n    map[idx] = val;\n    return map;\n  },\n  {} as Record<number, number>,\n);\n\ninterface CubeStore {\n  cubes: CubeInfo[]; // Cube information array\n  seed: string; // Terrain generation seed\n  addCube: (x: number, y: number, z: number, tileIndex: number) => void; // Add cube\n  removeCube: (x: number, y: number, z: number) => void; // Remove cube\n  selectedTile: number; // Selected tile\n  setSelectedTile: (index: number) => void; // Tile selection function\n  getTileTypeFromIndex: (index: number) => number; // Index to tile type conversion function\n  tileTypes: typeof TILE_TYPES; // Tile type constants\n  builderMode: boolean; // Builder mode\n  toggleBuilderMode: () => void; // Toggle builder mode\n  regenerateCubeMap: (newSeed?: string) => void; // Function to regenerate cubeMap\n\n  // Theme related states and functions\n  selectedTheme: THEMES; // Selected theme\n  setSelectedTheme: (theme: THEMES) => void; // Theme selection function\n  availableTiles: number[]; // List of available tile indices in the current theme\n  updateAvailableTiles: () => void; // Function to update the list of available tiles\n}\n\n// Check if two positions are the same\nconst isSamePosition = (a: [number, number, number], b: [number, number, number]) => {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n};\n\n// Function to create initial cubeMap\nconst createInitialCubeMap = (seed: string): CubeInfo[] => {\n  return generateCubeMap(seed, CUBEMAP_CONFIG.width, CUBEMAP_CONFIG.depth);\n};\n\nconst useCubeStore = create<CubeStore>((set, get) => ({\n  // Initial setup\n  seed: DEFAULT_SEED,\n  cubes: createInitialCubeMap(DEFAULT_SEED), // Apply initial cubeMap generation\n  tileTypes: TILE_TYPES,\n  builderMode: true,\n\n  // CubeMap regeneration function\n  regenerateCubeMap: (newSeed) =>\n    set((state) => {\n      const seed = newSeed || state.seed;\n      return {\n        seed,\n        cubes: createInitialCubeMap(seed), // Regenerate cubeMap\n      };\n    }),\n\n  // Add cube - store the index directly without conversion\n  addCube: (x, y, z, tileIndex) => {\n    set((state) => ({\n      cubes: [...state.cubes, { position: [x, y, z], tileIndex: tileIndex }],\n    }));\n  },\n\n  // Remove cube\n  removeCube: (x, y, z) =>\n    set((state) => ({\n      cubes: state.cubes.filter((cube) => !isSamePosition(cube.position, [x, y, z])),\n    })),\n\n  selectedTile: 0, // Default tile\n  setSelectedTile: (index) => set({ selectedTile: index }),\n\n  // Index to tile type conversion function - use the shared function\n  getTileTypeFromIndex,\n\n  // Toggle builder mode\n  toggleBuilderMode: () => set((state) => ({ builderMode: !state.builderMode })),\n\n  // Theme related states and functions\n  selectedTheme: THEMES.ALL, // Default theme is all blocks\n  setSelectedTheme: (theme) => {\n    set({ selectedTheme: theme });\n    // Update the list of available tiles when the theme changes\n    get().updateAvailableTiles();\n  },\n  availableTiles: getThemeTileIndices(THEMES.ALL), // Initial value is all tiles\n  updateAvailableTiles: () => {\n    const theme = get().selectedTheme;\n    const availableTiles = getThemeTileIndices(theme);\n\n    set({ availableTiles });\n\n    // If the currently selected tile is not available in the new theme, change to the first available tile\n    const selectedTile = get().selectedTile;\n    if (!availableTiles.includes(selectedTile) && availableTiles.length > 0) {\n      set({ selectedTile: availableTiles[0] });\n    }\n  },\n}));\n\nexport default useCubeStore;\n",
    isBinary: false,
  },
  'src/hooks/useCubeRaycaster.tsx': {
    type: 'file',
    content:
      "import { useCallback, useEffect, useState, useRef } from 'react';\nimport * as THREE from 'three';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport useCubeStore from '../stores/cubeStore';\nimport { usePlayerActionStore } from '../stores/playerActionStore';\nimport throttle from 'lodash/throttle';\n\n// Raycast distance limit constants\nconst MIN_RAYCAST_DISTANCE = 2;\nconst MAX_RAYCAST_DISTANCE = 15;\n\nconst useCubeRaycaster = () => {\n  const { scene, camera } = useThree();\n  const [previewPosition, setPreviewPosition] = useState<[number, number, number] | null>(null);\n  const [faceIndex, setFaceIndex] = useState<number | null>(null);\n  const addCube = useCubeStore((state) => state.addCube);\n  const selectedTile = useCubeStore((state) => state.selectedTile);\n  const playerActions = usePlayerActionStore();\n  \n  // Track previous addCube state for edge detection\n  const previousAddCubeState = useRef(false);\n\n  // Create Raycaster\n  const raycaster = new THREE.Raycaster();\n  // Set raycast distance limits\n  raycaster.near = MIN_RAYCAST_DISTANCE;\n  raycaster.far = MAX_RAYCAST_DISTANCE;\n  const centerScreen = new THREE.Vector2(0, 0); // Screen center\n\n  // Cast ray from the center of the screen\n  const handleRaycast = useCallback(() => {\n    raycaster.setFromCamera(centerScreen, camera);\n\n    // Check for intersections with all mesh objects in the scene\n    const intersects = raycaster.intersectObjects(scene.children, true);\n\n    // Find collision object (floor or cube only)\n    if (intersects.length > 0) {\n      // Filter for valid collision objects only\n      const validIntersection = intersects.find((intersect) => {\n        // Check if the object has a parent object\n        if (!intersect.object || !intersect.object.parent) return false;\n\n        // If InstancedMesh (if instanceId exists)\n        if (intersect.instanceId !== undefined && intersect.object instanceof THREE.InstancedMesh) {\n          return true; // Instance cubes are always treated as valid\n        }\n\n        // Check for cube object (userData.isCube is set to true)\n        if (intersect.object.userData && intersect.object.userData.isCube === true) {\n          return true;\n        }\n\n        if (intersect.object.parent.userData && intersect.object.parent.userData.isCube === true) {\n          return true;\n        }\n\n        // Check for floor object Method 1: Check userData\n        if (intersect.object.userData && intersect.object.userData.isFloor === true) {\n          return true;\n        }\n\n        // Check for floor object Method 2: Check parent's userData\n        if (intersect.object.parent.userData && (intersect.object.parent.userData.isFloor === true || intersect.object.parent.userData.type === 'fixed')) {\n          // Additional check if it's a floor mesh\n          if (intersect.object instanceof THREE.Mesh && intersect.object.geometry instanceof THREE.PlaneGeometry) {\n            return true;\n          }\n        }\n\n        return false;\n      });\n\n      if (validIntersection) {\n        // Calculate collision point\n        const point = validIntersection.point;\n        const normal = validIntersection.face?.normal.clone() || new THREE.Vector3(0, 1, 0);\n        let objectMatrix = validIntersection.object.matrixWorld;\n\n        // Differentiate between InstancedMesh and cube object\n        const isInstancedCube = validIntersection.instanceId !== undefined && validIntersection.object instanceof THREE.InstancedMesh;\n        const isFloor =\n          (validIntersection.object.userData && validIntersection.object.userData.isFloor === true) ||\n          (validIntersection.object.parent.userData && validIntersection.object.parent.userData.isFloor === true);\n\n        // Get instance matrix if InstancedMesh\n        if (isInstancedCube) {\n          const instancedMesh = validIntersection.object as THREE.InstancedMesh;\n          const instanceMatrix = new THREE.Matrix4();\n          instancedMesh.getMatrixAt(validIntersection.instanceId!, instanceMatrix);\n\n          // Calculate world matrix of the instance\n          const instanceWorldMatrix = new THREE.Matrix4().copy(validIntersection.object.matrixWorld).multiply(instanceMatrix);\n          objectMatrix = instanceWorldMatrix;\n        }\n\n        // Here we need to determine the cube position in exactly the same way\n        // as the handleCubeClick function in InstancedCube\n\n        // 1. Calculate exact position and face direction\n        normal.transformDirection(objectMatrix);\n\n        // 2. Calculate the position of the hit cube (InstancedCube uses integer coordinates)\n        // InstancedMesh already uses integer coordinates\n        const hitCubeX = Math.round(point.x - normal.x * 0.5);\n        const hitCubeY = Math.round(point.y - normal.y * 0.5);\n        const hitCubeZ = Math.round(point.z - normal.z * 0.5);\n\n        // 3. Calculate new cube position based on face direction (normal vector)\n        // Normalize normal direction to -1, 0, or 1\n        const nx = Math.round(normal.x);\n        const ny = Math.round(normal.y);\n        const nz = Math.round(normal.z);\n\n        // 4. New cube position = hit cube position + normal direction\n        // Calculate in the same way as InstancedCube.handleCubeClick\n        const x = hitCubeX + nx;\n        const y = hitCubeY + ny;\n        const z = hitCubeZ + nz;\n\n        setPreviewPosition([x, y, z]);\n        setFaceIndex(validIntersection.faceIndex || 0);\n      } else {\n        setPreviewPosition(null);\n        setFaceIndex(null);\n      }\n    } else {\n      setPreviewPosition(null);\n      setFaceIndex(null);\n    }\n  }, [camera, raycaster, scene]);\n\n  // Create throttled version of handleRaycast function (runs only once every 150ms)\n  const throttledRaycast = useRef(throttle(handleRaycast, 150, { leading: true, trailing: true })).current;\n\n  // Cube action handler (always operates in builder mode)\n  const handleCubeAction = useCallback(() => {\n    if (previewPosition) {\n      // previewPosition is already calculated as integer position, so use it as is\n      const [x, y, z] = previewPosition;\n      addCube(x, y, z, selectedTile);\n    }\n  }, [previewPosition, addCube, selectedTile]);\n\n  // Cancel throttle function on component unmount\n  useEffect(() => {\n    return () => {\n      throttledRaycast.cancel();\n    };\n  }, [throttledRaycast]);\n\n  // Main update loop - handles both raycasting and cube actions\n  useFrame(() => {\n    // 1. Update raycasting (throttled)\n    throttledRaycast();\n    \n    const currentAddCubeState = playerActions.addCube;\n    \n    // Detect rising edge (false -> true)\n    if (currentAddCubeState && !previousAddCubeState.current) {\n      handleCubeAction();\n      // Reset action after handling\n      playerActions.setPlayerAction('addCube', false);\n    }\n    \n    // Update previous state\n    previousAddCubeState.current = currentAddCubeState;\n  });\n\n  return { previewPosition };\n};\n\nexport default useCubeRaycaster;\n",
    isBinary: false,
  },
  'src/components/scene/GameScene.tsx': {
    type: 'file',
    content:
      "import GameSceneCanvas from '../r3f/GameSceneCanvas';\nimport GameSceneUI from '../ui/GameSceneUI';\n\n/**\n * Main Game Scene Component\n *\n * This component serves as a layout container that arranges the game UI and 3D Canvas.\n *\n * üö® CRITICAL PERFORMANCE WARNING:\n * Re-rendering of this component triggers re-rendering of the entire 3D Canvas, causing severe performance degradation.\n *\n * Prohibited Actions:\n * - Using state management hooks like useState, useReducer\n * - Passing frequently changing values as props\n * - State updates inside useEffect\n * - Conditional rendering that changes component structure\n * - Creating inline objects/functions (e.g., style={{...}}, onClick={() => {}})\n *\n * Recommendations:\n * - Handle state management in child components (GameSceneUI, GameSceneCanvas)\n * - Access global state directly through zustand store or similar\n * - Memoize event handlers with useCallback before use\n */\nconst GameScene = () => {\n  return (\n    <div className=\"relative w-full h-screen\">\n      <GameSceneUI />\n      <GameSceneCanvas />\n    </div>\n  );\n};\n\nexport default GameScene;\n",
    isBinary: false,
  },
  'src/components/scene/PreloadScene.tsx': {
    type: 'file',
    content:
      "import React, { useEffect, useState } from 'react';\nimport assets from '../../assets.json';\nimport * as THREE from 'three';\nimport { GLTF, GLTFLoader } from 'three-stdlib';\nimport { TextureLoader } from 'three';\n\ninterface PreloadSceneProps {\n  onComplete: () => void;\n}\n\n// Type definition to accept any structure in assets.json\ntype AssetCategory = Record<string, { url: string; [key: string]: unknown }>;\n\n// Type for the different possible loaded asset types\ntype LoadedAsset = GLTF | THREE.Texture | HTMLAudioElement | HTMLVideoElement | Response | null;\n\n/**\n * Asset Preloading Scene Component\n *\n * Preloads all assets defined in assets.json regardless of type\n * (models, animations, textures, etc.) and calls the onComplete callback when loading is finished.\n */\nconst PreloadScene: React.FC<PreloadSceneProps> = ({ onComplete }) => {\n  const [progress, setProgress] = useState(0);\n  const [isComplete, setIsComplete] = useState(false);\n\n  useEffect(() => {\n    const preloadAssets = async () => {\n      try {\n        // Collect all asset URLs from every category in assets.json\n        const allUrls: string[] = [];\n\n        // Get all categories from assets.json (characters, animations, textures, etc.)\n        const categories = Object.keys(assets);\n\n        // Loop through each category and collect URLs\n        categories.forEach((category) => {\n          const assetCategory = assets[category as keyof typeof assets] as AssetCategory;\n          if (assetCategory && typeof assetCategory === 'object') {\n            const categoryUrls = Object.values(assetCategory)\n              .filter((item) => item && typeof item === 'object' && 'url' in item)\n              .map((item) => item.url);\n\n            allUrls.push(...categoryUrls);\n          }\n        });\n\n        console.log(`Found ${allUrls.length} assets to preload`);\n\n        // Setup loading manager for all assets\n        const loadingManager = new THREE.LoadingManager();\n\n        // Set up loading manager event handlers\n        loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {\n          const currentProgress = Math.floor((itemsLoaded / itemsTotal) * 100);\n          console.log(`Loading progress: ${currentProgress}% (${url})`);\n          setProgress(currentProgress);\n        };\n\n        loadingManager.onLoad = () => {\n          console.log('All assets preloaded successfully');\n          setProgress(100);\n          setIsComplete(true);\n        };\n\n        loadingManager.onError = (url) => {\n          console.error(`Loading error: ${url}`);\n        };\n\n        // Create a Promise for each asset to load with appropriate loader\n        const loadPromises = allUrls.map((url) => {\n          // Determine file type from extension\n          const fileExtension = url.split('.').pop()?.toLowerCase();\n\n          return new Promise<LoadedAsset>((resolve) => {\n            // Choose appropriate loader based on file extension\n            if (fileExtension === 'glb' || fileExtension === 'gltf') {\n              // Use GLTFLoader for 3D models and animations\n              const loader = new GLTFLoader(loadingManager);\n              loader.load(\n                url,\n                (gltf) => {\n                  console.log(`Loaded model: ${url}`);\n                  resolve(gltf);\n                },\n                undefined,\n                (error) => {\n                  console.error(`Failed to load model: ${url}`, error);\n                  resolve(null);\n                },\n              );\n            } else if (['jpg', 'jpeg', 'png', 'webp'].includes(fileExtension || '')) {\n              // Use TextureLoader for image textures\n              const loader = new TextureLoader(loadingManager);\n              loader.load(\n                url,\n                (texture) => {\n                  console.log(`Loaded texture: ${url}`);\n                  resolve(texture);\n                },\n                undefined,\n                (error) => {\n                  console.error(`Failed to load texture: ${url}`, error);\n                  resolve(null);\n                },\n              );\n            } else if (['mp3', 'wav', 'ogg'].includes(fileExtension || '')) {\n              // For audio files, preload with audio element\n              const audio = new Audio();\n              audio.src = url;\n\n              audio.addEventListener('canplaythrough', () => {\n                console.log(`Loaded audio: ${url}`);\n                resolve(audio);\n              });\n\n              audio.addEventListener('error', () => {\n                console.error(`Failed to load audio: ${url}`);\n                resolve(null);\n              });\n\n              // Force preloading\n              audio.load();\n            } else if (['mp4', 'webm'].includes(fileExtension || '')) {\n              // For video files\n              const video = document.createElement('video');\n              video.src = url;\n              video.preload = 'auto';\n\n              video.addEventListener('canplaythrough', () => {\n                console.log(`Loaded video: ${url}`);\n                resolve(video);\n              });\n\n              video.addEventListener('error', () => {\n                console.error(`Failed to load video: ${url}`);\n                resolve(null);\n              });\n\n              // Force preloading\n              video.load();\n            } else {\n              // For other file types, use a simple fetch to ensure it's in browser cache\n              fetch(url)\n                .then((response) => {\n                  if (!response.ok) throw new Error(`Failed to load: ${url}`);\n                  console.log(`Loaded other: ${url}`);\n                  return resolve(response);\n                })\n                .catch((error) => {\n                  console.error(`Failed to load: ${url}`, error);\n                  resolve(null);\n                });\n            }\n          });\n        });\n\n        // Wait for all loading tasks to complete\n        await Promise.all(loadPromises);\n      } catch (error) {\n        console.error('Error during asset preloading:', error);\n      }\n    };\n\n    preloadAssets();\n  }, []);\n\n  // Call onComplete callback when loading is finished\n  useEffect(() => {\n    if (isComplete) {\n      onComplete();\n    }\n  }, [isComplete, onComplete]);\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex flex-col items-center justify-center bg-black text-white\">\n      <h2 className=\"text-2xl font-bold mb-4\">Loading</h2>\n      <div className=\"w-64 h-2 bg-gray-700 rounded-full overflow-hidden\">\n        <div className=\"h-full bg-blue-500 transition-all duration-300\" style={{ width: `${Math.max(0, Math.min(100, progress))}%` }} />\n      </div>\n      <p className=\"mt-2\">{progress}%</p>\n    </div>\n  );\n};\n\nexport default PreloadScene;\n",
    isBinary: false,
  },
  'src/components/ui/LoadingScreen.tsx': {
    type: 'file',
    content:
      "import { useThree } from '@react-three/fiber';\nimport { Html } from '@react-three/drei';\n\n/**\n * Loading screen component\n */\nconst LoadingScreen = () => {\n  let isInThreeCanvas: boolean;\n  try {\n    useThree();\n    isInThreeCanvas = true;\n  } catch {\n    isInThreeCanvas = false;\n  }\n\n  const loadingContent = (\n    <div>\n      <style>{`\n        .loading-container {\n          inset: 0;\n          z-index: 50;\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: center;\n          background-color: black;\n          color: white;\n          width: 100%;\n          height: 100%;\n        }\n        .loading-title {\n          font-size: 1.5rem;\n          font-weight: bold;\n          margin-bottom: 1rem;\n        }\n        .spinner {\n          width: 30px;\n          height: 30px;\n          border: 3px solid rgba(255, 255, 255, 0.3);\n          border-radius: 50%;\n          border-top-color: white;\n          animation: spin 1s ease-in-out infinite;\n        }\n        @keyframes spin {\n          to {\n            transform: rotate(360deg);\n          }\n        }\n      `}</style>\n      <div className=\"loading-container\">\n        <h2 className=\"loading-title\">Loading</h2>\n        <div className=\"spinner\"></div>\n      </div>\n    </div>\n  );\n\n  if (isInThreeCanvas) {\n    return (\n      <Html\n        center\n        style={{\n          width: '100vw',\n          height: '100vh',\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          pointerEvents: 'none',\n        }}\n      >\n        {loadingContent}\n      </Html>\n    );\n  }\n\n  return loadingContent;\n};\n\nexport default LoadingScreen;\n",
    isBinary: false,
  },
  'src/components/ui/Crosshair.tsx': {
    type: 'file',
    content:
      'import React from \'react\';\n\nconst Crosshair: React.FC = () => {\n  return (\n    <div className="fixed inset-0 pointer-events-none flex items-center justify-center z-50">\n      <div className="crosshair-container flex items-center justify-center w-6 h-6">\n        <div className="crosshair-horizontal w-4 h-[2px] bg-white opacity-70"></div>\n        <div className="crosshair-vertical h-4 w-[2px] bg-white opacity-70 absolute"></div>\n        <div className="crosshair-dot w-1 h-1 bg-white opacity-90 rounded-full absolute"></div>\n      </div>\n    </div>\n  );\n};\n\nexport default Crosshair;\n',
    isBinary: false,
  },
  'src/components/ui/InputController.tsx': {
    type: 'file',
    content:
      "import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport * as THREE from 'three';\nimport { IS_MOBILE, useInputStore } from 'vibe-starter-3d';\nimport { usePlayerActionStore } from '../../stores/playerActionStore';\nimport nipplejs from 'nipplejs';\n\n/**\n * Key mapping configuration - simple Record<string, string[]>\n */\ntype KeyMapping = Record<string, string[]>; // action: [key1, key2, ...]\n\n/**\n * Controller key mapping\n */\nconst CONTROL_KEY_MAPPING: KeyMapping = {\n  forward: ['KeyW', 'ArrowUp'],\n  backward: ['KeyS', 'ArrowDown'],\n  leftward: ['KeyA', 'ArrowLeft'],\n  rightward: ['KeyD', 'ArrowRight'],\n  jump: ['Space'],\n  run: ['ShiftLeft', 'ShiftRight'],\n};\n\n/**\n * Player action key mapping\n */\nconst ACTION_KEY_MAPPING: KeyMapping = {\n  addCube: ['KeyF', 'Mouse0'],\n  removeCube: ['KeyG', 'Mouse2'],\n};\n\n// Movement speed constants\nconst MOVEMENT_SPEED_WALK = 0.6;\nconst MOVEMENT_SPEED_RUN_BOOST = 0.4;\nconst MOVEMENT_SPEED_MAX = 1.0;\nconst JOYSTICK_RANGE_MULTIPLIER = 2.0; // Converts joystick range (0~0.5) to full range (0~1.0)\n\ninterface InputControllerProps {\n  disabled?: boolean;\n  disableKeyboard?: boolean;\n  disableJoystick?: boolean;\n}\n\nexport const InputController: React.FC<InputControllerProps> = ({ disabled = false, disableKeyboard = false, disableJoystick = false }) => {\n  // Store actions to controller\n  const { setMovementInput, setActionInput, resetAllInputs, setActiveInputSource } = useInputStore();\n  const { setPlayerAction, resetAllPlayerActions } = usePlayerActionStore();\n\n  // Button states\n  const [isJumpPressed, setIsJumpPressed] = useState(false);\n  const [isAddCubePressed, setIsAddCubePressed] = useState(false);\n\n  // Keyboard state tracking\n  const keyboardStateRef = useRef({\n    forward: false,\n    backward: false,\n    leftward: false,\n    rightward: false,\n    run: false,\n  });\n\n  // Helper function to calculate movement from keyboard state\n  const calculateKeyboardMovement = useCallback(() => {\n    const state = keyboardStateRef.current;\n\n    // Calculate direction\n    const x = (state.leftward ? 1 : 0) + (state.rightward ? -1 : 0);\n    const y = (state.forward ? 1 : 0) + (state.backward ? -1 : 0);\n\n    // Use Three.js Vector2 for efficient normalization\n    const direction = new THREE.Vector2(x, y);\n    const magnitude = direction.length();\n\n    // Normalize diagonal movement\n    if (magnitude > 0) {\n      direction.normalize();\n    }\n\n    // Calculate intensity: base speed + run boost\n    const baseIntensity = magnitude > 0 ? MOVEMENT_SPEED_WALK : 0; // Base walking speed\n    const runBoost = state.run ? MOVEMENT_SPEED_RUN_BOOST : 0; // Additional speed when running\n    const intensity = Math.min(baseIntensity + runBoost, MOVEMENT_SPEED_MAX);\n\n    return {\n      direction: { x: direction.x, y: direction.y },\n      intensity,\n    };\n  }, []);\n\n  // Joystick input handling with analog support\n  useEffect(() => {\n    if (disabled || disableJoystick || !IS_MOBILE) return;\n\n    // Create div element for left side area of screen\n    const joystickZone = document.createElement('div');\n    joystickZone.style.position = 'fixed';\n    joystickZone.style.left = '0';\n    joystickZone.style.top = '0';\n    joystickZone.style.width = '50%'; // Left 50% of screen\n    joystickZone.style.height = '100%';\n    joystickZone.style.zIndex = '1000';\n    joystickZone.style.pointerEvents = 'auto';\n    joystickZone.style.backgroundColor = 'transparent';\n    // Disable long touch events\n    joystickZone.style.touchAction = 'none';\n    joystickZone.style.userSelect = 'none';\n    joystickZone.style.setProperty('-webkit-user-select', 'none');\n    joystickZone.style.setProperty('-webkit-touch-callout', 'none');\n    document.body.appendChild(joystickZone);\n\n    const options: nipplejs.JoystickManagerOptions = {\n      zone: joystickZone,\n      color: 'white',\n      mode: 'dynamic',\n      shape: 'circle',\n    };\n\n    const manager = nipplejs.create(options);\n\n    manager.on('move', (evt, data) => {\n      if (disabled || disableJoystick) return; // Check disabled state\n      setActiveInputSource('joystick');\n\n      // Extract analog data from nipplejs\n      const angle = data.angle?.radian || 0; // Angle in radians\n      const distance = data.distance || 0; // Distance from center\n      const maxDistance = data.instance.options.size || 100; // Maximum distance\n\n      // Calculate normalized direction vector\n      // nipplejs uses mathematical coordinate system (0¬∞ = right, 90¬∞ = up)\n      // We need to convert to game coordinate system (0¬∞ = up, 90¬∞ = right)\n      const gameAngle = angle - Math.PI / 2; // Rotate by -90 degrees\n      const directionX = Math.sin(gameAngle); // Right/Left\n      const directionY = Math.cos(gameAngle); // Forward/Backward\n\n      // Calculate intensity (0.0 to 1.0) based on distance from center\n      const intensity = Math.min((distance / maxDistance) * JOYSTICK_RANGE_MULTIPLIER, MOVEMENT_SPEED_MAX);\n\n      // Set analog movement input\n      setMovementInput({ x: directionX, y: directionY }, intensity, 'joystick');\n    });\n\n    manager.on('end', () => {\n      if (disabled || disableJoystick) return; // Check disabled state\n      // Reset all inputs when joystick ends\n      setMovementInput({ x: 0, y: 0 }, 0, 'joystick');\n    });\n\n    return () => {\n      manager.destroy();\n      if (joystickZone.parentNode) {\n        joystickZone.parentNode.removeChild(joystickZone);\n      }\n    };\n  }, [disabled, disableJoystick, setMovementInput, setActiveInputSource]);\n\n  // Keyboard input handling - convert to movement immediately\n  useEffect(() => {\n    if (disabled || disableKeyboard) return;\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n      let stateChanged = false;\n\n      // Handle movement keys\n      if (CONTROL_KEY_MAPPING['forward']?.includes(event.code) && !keyboardStateRef.current.forward) {\n        keyboardStateRef.current.forward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['backward']?.includes(event.code) && !keyboardStateRef.current.backward) {\n        keyboardStateRef.current.backward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['leftward']?.includes(event.code) && !keyboardStateRef.current.leftward) {\n        keyboardStateRef.current.leftward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['rightward']?.includes(event.code) && !keyboardStateRef.current.rightward) {\n        keyboardStateRef.current.rightward = true;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['run']?.includes(event.code) && !keyboardStateRef.current.run) {\n        keyboardStateRef.current.run = true;\n        stateChanged = true;\n      }\n\n      // Handle action keys\n      if (CONTROL_KEY_MAPPING['jump']?.includes(event.code)) {\n        setActionInput('jump', true, 'keyboard');\n      }\n\n      // Handle player action keys\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(event.code)) {\n          setPlayerAction(action, true);\n        }\n      });\n\n      // Update movement if any movement-related key changed\n      if (stateChanged) {\n        const movement = calculateKeyboardMovement();\n        setMovementInput(movement.direction, movement.intensity, 'keyboard');\n      }\n    };\n\n    const handleKeyUp = (event: KeyboardEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n      let stateChanged = false;\n\n      // Handle movement keys\n      if (CONTROL_KEY_MAPPING['forward']?.includes(event.code) && keyboardStateRef.current.forward) {\n        keyboardStateRef.current.forward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['backward']?.includes(event.code) && keyboardStateRef.current.backward) {\n        keyboardStateRef.current.backward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['leftward']?.includes(event.code) && keyboardStateRef.current.leftward) {\n        keyboardStateRef.current.leftward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['rightward']?.includes(event.code) && keyboardStateRef.current.rightward) {\n        keyboardStateRef.current.rightward = false;\n        stateChanged = true;\n      }\n      if (CONTROL_KEY_MAPPING['run']?.includes(event.code) && keyboardStateRef.current.run) {\n        keyboardStateRef.current.run = false;\n        stateChanged = true;\n      }\n\n      // Handle action keys\n      if (CONTROL_KEY_MAPPING['jump']?.includes(event.code)) {\n        setActionInput('jump', false, 'keyboard');\n      }\n\n      // Handle player action keys\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(event.code)) {\n          setPlayerAction(action, false);\n        }\n      });\n\n      // Update movement if any movement-related key changed\n      if (stateChanged) {\n        const movement = calculateKeyboardMovement();\n        setMovementInput(movement.direction, movement.intensity, 'keyboard');\n      }\n    };\n\n    const handleMouseDown = (event: MouseEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n\n      // Handle player action mouse keys\n      const mouseButton = `Mouse${event.button}`;\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(mouseButton)) {\n          setPlayerAction(action, true);\n        }\n      });\n    };\n\n    const handleMouseUp = (event: MouseEvent) => {\n      if (disabled || disableKeyboard) return; // Additional check in handler\n\n      // Handle player action mouse keys\n      const mouseButton = `Mouse${event.button}`;\n      Object.keys(ACTION_KEY_MAPPING).forEach((action) => {\n        if (ACTION_KEY_MAPPING[action]?.includes(mouseButton)) {\n          setPlayerAction(action, false);\n        }\n      });\n    };\n\n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mouseup', handleMouseUp);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n      document.removeEventListener('mousedown', handleMouseDown);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [disabled, disableKeyboard, setMovementInput, setActionInput, setPlayerAction, calculateKeyboardMovement]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      resetAllInputs();\n      resetAllPlayerActions();\n    };\n  }, [resetAllInputs, resetAllPlayerActions]);\n\n  // Reset inputs when disabled\n  useEffect(() => {\n    if (disabled || disableKeyboard || disableJoystick) {\n      // Reset keyboard state if keyboard is disabled\n      if (disabled || disableKeyboard) {\n        keyboardStateRef.current = {\n          forward: false,\n          backward: false,\n          leftward: false,\n          rightward: false,\n          run: false,\n        };\n      }\n      // Reset button states\n      setIsJumpPressed(false);\n      setIsAddCubePressed(false);\n      resetAllInputs();\n      resetAllPlayerActions();\n    }\n  }, [disabled, disableKeyboard, disableJoystick, resetAllInputs, resetAllPlayerActions]);\n\n  // Button handlers\n  const handleJumpStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation(); // Prevent event propagation\n      setIsJumpPressed(true);\n      setActionInput('jump', true, 'touch');\n    },\n    [disabled, setActionInput],\n  );\n\n  const handleJumpEnd = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation(); // Prevent event propagation\n      setIsJumpPressed(false);\n      setActionInput('jump', false, 'touch');\n    },\n    [disabled, setActionInput],\n  );\n\n  const handleAddCubeStart = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation();\n      setIsAddCubePressed(true);\n      // NOTE: change to other action if needed\n      setPlayerAction('addCube', true);\n    },\n    [disabled, setPlayerAction],\n  );\n\n  const handleAddCubeEnd = useCallback(\n    (event: React.MouseEvent | React.TouchEvent) => {\n      if (disabled) return;\n      event.preventDefault();\n      event.stopPropagation();\n      setIsAddCubePressed(false);\n      // NOTE: change to other action if needed\n      setPlayerAction('addCube', false);\n    },\n    [disabled, setPlayerAction],\n  );\n\n  // Don't render action buttons if joystick is disabled\n  if (disableJoystick) {\n    return null;\n  }\n\n  // Render action buttons\n  return (\n    <div className=\"fixed bottom-8 right-8 z-[1001]\">\n      {/* Add cube Button */}\n      <div\n        className={`w-20 h-20 rounded-full bg-white/30 \n                   flex items-center justify-center cursor-pointer select-none touch-none\n                   ${isAddCubePressed ? 'scale-90' : 'scale-100'} transition-transform`}\n        onMouseDown={handleAddCubeStart}\n        onMouseUp={handleAddCubeEnd}\n        onMouseLeave={handleAddCubeEnd}\n        onTouchStart={handleAddCubeStart}\n        onTouchEnd={handleAddCubeEnd}\n      >\n        <span className=\"text-white text-xs font-bold\">ADD CUBE</span>\n      </div>\n\n      {/* Attack Button */}\n      <div\n        className={`absolute bottom-0 -left-12 -top-12 w-14 h-14 rounded-full bg-white/30 \n                   flex items-center justify-center cursor-pointer select-none touch-none\n                   ${isJumpPressed ? 'scale-90' : 'scale-100'} transition-transform`}\n        onMouseDown={handleJumpStart}\n        onMouseUp={handleJumpEnd}\n        onMouseLeave={handleJumpEnd}\n        onTouchStart={handleJumpStart}\n        onTouchEnd={handleJumpEnd}\n      >\n        <span className=\"text-white text-xs font-bold\">JUMP</span>\n      </div>\n    </div>\n  );\n};\n",
    isBinary: false,
  },
  'src/components/ui/GameSceneUI.tsx': {
    type: 'file',
    content:
      "import { useGameStore } from '../../stores/gameStore';\nimport Crosshair from './Crosshair';\nimport { InputController } from './InputController';\nimport LoadingScreen from './LoadingScreen';\nimport TileSelector from './TileSelector';\n\n/**\n * Game Scene UI Component\n *\n * This component manages UI overlays for the game scene.\n * It handles loading states and displays appropriate UI elements based on game state.\n */\nconst GameSceneUI = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* Input Controller - Global input management (keyboard, touch) */}\n      <InputController disableJoystick={false} disableKeyboard={false} disabled={!isMapPhysicsReady} />\n      {/* Loading Game Scene screen overlay */}\n      {!isMapPhysicsReady && <LoadingScreen />}\n      <TileSelector />\n      <Crosshair />\n    </>\n  );\n};\n\nexport default GameSceneUI;\n",
    isBinary: false,
  },
  'src/components/ui/TileSelector.tsx': {
    type: 'file',
    content:
      "import React, { useEffect, useState, useCallback, useMemo } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { OrbitControls } from '@react-three/drei';\nimport useCubeStore from '../../stores/cubeStore';\nimport SingleCube from '../r3f/SingleCube';\nimport { THEMES, THEME_NAMES, THEME_ICONS, THEME_DESCRIPTIONS } from '../../constants/themes';\nimport { getTileTypeFromIndex } from '../../utils/colorUtils';\n\n/**\n * Single tile rendering component\n */\nconst TileItem = ({ tileIndex, isSelected, onClick }: { tileIndex: number; isSelected: boolean; onClick: () => void }) => {\n  const actualTileType = getTileTypeFromIndex(tileIndex);\n\n  const scale = isSelected ? 0.8 : 0.6;\n\n  // Compact configuration - slightly larger tiles\n  const size = isSelected\n    ? 'w-[30px] h-[30px] sm:w-[35px] sm:h-[35px] md:w-[40px] md:h-[40px]'\n    : 'w-[25px] h-[25px] sm:w-[30px] sm:h-[30px] md:w-[35px] md:h-[35px]';\n\n  const border = isSelected ? 'border border-white shadow-sm' : 'border border-[#313a40]';\n\n  const transform = isSelected ? '-translate-y-0.5' : '';\n\n  return (\n    <div\n      className={`\n        relative ${size} ${border} ${transform}\n        bg-[#222222] rounded\n        cursor-pointer\n        transition-all duration-200\n        flex items-center justify-center\n        mx-0.5\n        z-10\n      `}\n      title={`Tile ${tileIndex} (Type: ${actualTileType})`}\n      onClick={onClick}\n    >\n      <div className=\"w-full h-full\">\n        <Canvas camera={{ position: [0, 0, 3], fov: 40 }} dpr={[1, 2]}>\n          <color attach=\"background\" args={['#222222']} />\n          <ambientLight intensity={1.2} />\n          <directionalLight position={[3, 3, 3]} intensity={0.8} />\n          <SingleCube tileIndex={tileIndex} scale={scale} rotation={[0.5, 0.8, 0]} />\n          {isSelected && <OrbitControls enableZoom={false} enablePan={false} />}\n        </Canvas>\n      </div>\n\n      {/* Display tile index - compact */}\n      {!isSelected && (\n        <div\n          className={`\n        absolute bottom-[-10px]\n        left-1/2 transform -translate-x-1/2\n        bg-[#1d1c21] text-white\n        px-1 py-0.5 rounded\n        text-xs font-bold\n      `}\n        >\n          {tileIndex}\n        </div>\n      )}\n    </div>\n  );\n};\n\n/**\n * Theme item component\n */\nconst ThemeItem = ({ theme, isSelected, onClick }: { theme: THEMES; isSelected: boolean; onClick: () => void }) => {\n  return (\n    <div\n      className={`\n        flex flex-col items-center justify-center\n        p-1 rounded cursor-pointer\n        transition-all duration-200\n        ${isSelected ? 'bg-white text-black shadow-sm' : 'bg-[#313a40] text-white hover:bg-[#474f52]'}\n      `}\n      onClick={onClick}\n    >\n      <div className=\"text-sm mb-0.5\">{THEME_ICONS[theme]}</div>\n      <div className=\"text-[10px] font-bold text-center\">{THEME_NAMES[theme]}</div>\n    </div>\n  );\n};\n\n/**\n * Tile selector component\n */\nconst TileSelector: React.FC = () => {\n  const tileStore = useCubeStore();\n  const { selectedTile, setSelectedTile, availableTiles, regenerateCubeMap, selectedTheme, setSelectedTheme } = tileStore;\n\n  // Theme selection mode (false: tile selection mode, true: theme selection mode)\n  const [showThemes, setShowThemes] = useState(false);\n\n  // State for seed input and terrain generation\n  const [customSeed, setCustomSeed] = useState(tileStore.seed);\n\n  // List of available tiles\n  const tileOptions = availableTiles || [];\n\n  // Tile index related\n  const currentTileIndex = useMemo(() => {\n    if (availableTiles.length === 0) return 0;\n    const index = availableTiles.indexOf(selectedTile);\n    return index >= 0 ? index : 0;\n  }, [selectedTile, availableTiles]);\n\n  // Keyboard event handler\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      if (showThemes) {\n        // In theme selection mode, press ESC or T to switch to tile selection mode\n        if (e.key === 'Escape' || e.key === 't' || e.key === 'T') {\n          e.preventDefault();\n          setShowThemes(false);\n        }\n      } else {\n        // Tile selection mode\n        if (e.key === 'q' || e.key === 'Q') {\n          // Previous tile\n          e.preventDefault();\n          if (availableTiles.length > 0) {\n            const newIndex = (currentTileIndex - 1 + availableTiles.length) % availableTiles.length;\n            setSelectedTile(availableTiles[newIndex]);\n          }\n        } else if (e.key === 'e' || e.key === 'E') {\n          // Next tile\n          e.preventDefault();\n          if (availableTiles.length > 0) {\n            const newIndex = (currentTileIndex + 1) % availableTiles.length;\n            setSelectedTile(availableTiles[newIndex]);\n          }\n        } else if (e.key === 't' || e.key === 'T') {\n          // Switch to theme selection mode\n          e.preventDefault();\n          setShowThemes(true);\n        }\n      }\n    },\n    [showThemes, currentTileIndex, availableTiles, setSelectedTile],\n  );\n\n  // Register keyboard event\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown]);\n\n  // Theme selection handler\n  const handleThemeSelect = useCallback(\n    (theme: THEMES) => {\n      setSelectedTheme(theme);\n      setShowThemes(false);\n    },\n    [setSelectedTheme],\n  );\n\n  // Adjust number of tiles to display based on screen size\n  const maxDisplayTiles = 5;\n\n  // Tiles to display (current selected tile and sides)\n  const displayTiles = useMemo(() => {\n    if (availableTiles.length === 0) return [];\n\n    // If there are fewer tiles than max display, show all\n    if (availableTiles.length <= maxDisplayTiles) {\n      return availableTiles;\n    }\n\n    const tiles = [];\n    const sideCount = Math.floor((maxDisplayTiles - 1) / 2);\n\n    // Display current selected tile and tiles on each side\n    for (let i = -sideCount; i <= sideCount; i++) {\n      const idx = (currentTileIndex + i + availableTiles.length) % availableTiles.length;\n      tiles.push(availableTiles[idx]);\n    }\n    return tiles;\n  }, [availableTiles, currentTileIndex, maxDisplayTiles]);\n\n  // CubeMap regeneration function\n  const handleRegenerateCubeMap = () => {\n    regenerateCubeMap(customSeed);\n  };\n\n  // Theme selection mode rendering\n  if (showThemes) {\n    return (\n      <div className=\"fixed left-1/2 bottom-2 transform -translate-x-1/2 bg-black/90 p-1 rounded border border-[#313a40] shadow-lg z-50 w-[80vw] max-w-[180px] sm:max-w-[200px] md:max-w-[220px]\">\n        <div className=\"flex justify-between items-center mb-1\">\n          <h3 className=\"text-xs font-bold text-white\">Theme</h3>\n          <button className=\"px-1 py-0.5 text-[10px] bg-[#313a40] hover:bg-[#474f52] text-white rounded\" onClick={() => setShowThemes(false)}>\n            √ó\n          </button>\n        </div>\n\n        <div className=\"grid grid-cols-2 gap-0.5 mb-1\">\n          {Object.values(THEMES).map((theme) => (\n            <ThemeItem key={theme} theme={theme} isSelected={selectedTheme === theme} onClick={() => handleThemeSelect(theme)} />\n          ))}\n        </div>\n\n        <div className=\"text-[10px] text-white text-left px-1 py-1 bg-[#313a40] rounded\">{THEME_DESCRIPTIONS[selectedTheme]}</div>\n      </div>\n    );\n  }\n\n  // Tile selection mode rendering\n  return (\n    <div className=\"fixed left-1/2 bottom-2 transform -translate-x-1/2 bg-black/90 p-1 rounded border border-[#313a40] shadow-lg z-50 w-[80vw] max-w-[180px] sm:max-w-[200px] md:max-w-[220px]\">\n      {availableTiles.length === 0 ? (\n        <div className=\"text-white text-center py-1 text-xs\">No tiles available.</div>\n      ) : (\n        <div className=\"flex items-center justify-center overflow-x-auto\">\n          {displayTiles.map((tileIndex, idx) => {\n            const middleIndex = Math.floor(maxDisplayTiles / 2);\n            const isSelectedTile = availableTiles.length <= maxDisplayTiles ? tileIndex === selectedTile : idx === middleIndex;\n\n            return (\n              <TileItem\n                key={`tile-${idx}-${tileIndex}`}\n                tileIndex={tileIndex}\n                isSelected={isSelectedTile}\n                onClick={() => !isSelectedTile && setSelectedTile(tileIndex)}\n              />\n            );\n          })}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default TileSelector;\n",
    isBinary: false,
  },
  'src/components/r3f/GameSceneCanvas.tsx': {
    type: 'file',
    content:
      "import React, { Suspense } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { Physics } from '@react-three/rapier';\nimport Experience from '../r3f/Experience';\nimport { FirstPersonViewController, FollowLight, IS_MOBILE } from 'vibe-starter-3d';\nimport { useGameStore } from '../../stores/gameStore';\nimport MapPhysicsReadyChecker from '../r3f/MapPhysicsReadyChecker';\n\n/**\n * Game Scene Canvas Component\n *\n * This component is responsible for rendering the entire 3D game world using React Three Fiber.\n * It serves as the root container for all 3D elements, physics simulation, and game interactions.\n */\nconst GameSceneCanvas = () => {\n  // ‚ö†Ô∏è MUST CHECK: Map physics system ready state\n  // Physics paused and loading screen displayed while this value is false\n  const { isMapPhysicsReady } = useGameStore();\n\n  return (\n    <>\n      {/* ‚ö†Ô∏è DO NOT DELETE: Core Canvas component for React Three Fiber */}\n      <Canvas\n        shadows\n        onPointerDown={(e) => {\n          if (!IS_MOBILE) {\n            (e.target as HTMLCanvasElement).requestPointerLock();\n          }\n        }}\n      >\n        <Physics paused={!isMapPhysicsReady}>\n          <Suspense fallback={null}>\n            {/* ‚ö†Ô∏è MUST INCLUDE: Essential checker for map physics initialization */}\n            {!isMapPhysicsReady && <MapPhysicsReadyChecker />}\n            <FollowLight intensity={0.8} />\n            <FirstPersonViewController />\n            <Experience />\n          </Suspense>\n        </Physics>\n      </Canvas>\n    </>\n  );\n};\n\nexport default GameSceneCanvas;\n",
    isBinary: false,
  },
  'src/components/r3f/Experience.tsx': {
    type: 'file',
    content:
      "import { Environment } from '@react-three/drei';\n\nimport InstancedCube from './InstancedCube';\nimport CubePreview from './CubePreview';\nimport useCubeRaycaster from '../../hooks/useCubeRaycaster';\nimport Water from './Water';\nimport Player from './Player';\n\nconst Experience = () => {\n  const { previewPosition } = useCubeRaycaster();\n\n  return (\n    <>\n      {/* Lower ambient light intensity for stronger shadows and contrast */}\n      <ambientLight intensity={0.5} />\n\n      {/* Main directional light - acts as the sun */}\n      <directionalLight position={[50, 100, 50]} intensity={1.5} castShadow shadow-mapSize={[2048, 2048]} />\n\n      {/* Secondary light - side lighting for enhanced depth */}\n      <directionalLight position={[-30, 50, -30]} intensity={0.8} color=\"#b9d4ff\" />\n\n      {/* Weak fill light from below */}\n      <directionalLight position={[0, -10, 0]} intensity={0.3} color=\"#fff9e8\" />\n\n      <Environment preset=\"dawn\" background={true} />\n\n      {/* Water */}\n      <Water />\n\n      {/* Render instanced cubes (optimized way) */}\n      <InstancedCube />\n\n      {/* Cube Preview */}\n      <CubePreview position={previewPosition} />\n\n      <Player />\n    </>\n  );\n};\n\nexport default Experience;\n",
    isBinary: false,
  },
  'src/components/r3f/CubePreview.tsx': {
    type: 'file',
    content:
      "import { useEffect, useRef } from 'react';\nimport * as THREE from 'three';\nimport useCubeStore from '../../stores/cubeStore';\nimport SingleCube from './SingleCube';\n\ninterface CubePreviewProps {\n  position: [number, number, number] | null;\n}\n\n/**\n * Cube preview component\n *\n * Important: Must use the same position calculation method as InstancedCube\n * Terrain generation and InstancedCube operate by passing the position directly\n */\nconst CubePreview = ({ position }: CubePreviewProps) => {\n  const groupRef = useRef<THREE.Group>(null);\n  const selectedTile = useCubeStore((state) => state.selectedTile);\n\n  // Update position when the position changes\n  useEffect(() => {\n    if (groupRef.current && position) {\n      // Apply integer coordinates directly\n      // Process in the same way as InstancedCube rendering\n      // In Three.js, boxGeometry is internally defined as a -0.5~0.5 sized cube with center at origin\n      // Using raw coordinates places the center of the boxGeometry at that coordinate\n      groupRef.current.position.set(position[0], position[1], position[2]);\n      groupRef.current.visible = true;\n    } else if (groupRef.current) {\n      groupRef.current.visible = false;\n    }\n  }, [position]);\n\n  return (\n    <group ref={groupRef} visible={!!position}>\n      {/* Create SingleCube component with position 0, 0, 0 - position determined by groupRef's position */}\n      <SingleCube tileIndex={selectedTile} scale={1.03} position={[0, 0, 0]} rotation={[0, 0, 0]} opacity={0.7} />\n    </group>\n  );\n};\n\nexport default CubePreview;\n",
    isBinary: false,
  },
  'src/components/r3f/Player.tsx': {
    type: 'file',
    content:
      "import React, { useRef, useEffect, useCallback } from 'react';\nimport { useFrame, Vector3 } from '@react-three/fiber';\nimport { CollisionPayload } from '@react-three/rapier';\nimport { useGameServer } from '@agent8/gameserver';\n\nimport { useLocalPlayerStore } from '../../stores/localPlayerStore';\nimport { useMultiPlayerStore } from '../../stores/multiPlayerStore';\n\nimport { CharacterState } from '../../constants/character';\nimport { RigidBodyObjectType } from '../../constants/rigidBodyObjectType';\n\nimport Assets from '../../assets.json';\nimport {\n  AnimationConfigMap,\n  AnimationType,\n  CharacterMovementState,\n  CharacterRenderer,\n  RigidBodyPlayer,\n  RigidBodyPlayerRef,\n  useCharacterAnimation,\n  useControllerStore,\n} from 'vibe-starter-3d';\nimport { usePlayerActionStore } from '../../stores/playerActionStore';\n\nconst targetHeight = 1.6;\n\n// States that can be interrupted by actions\nconst INTERRUPTIBLE_STATES = [\n  CharacterState.IDLE,\n  CharacterState.IDLE_01,\n  CharacterState.WALK,\n  CharacterState.RUN,\n  CharacterState.FAST_RUN,\n  CharacterState.JUMP,\n] as const;\n\n// Animation configuration map moved outside component for better performance\nconst animationConfigMap: AnimationConfigMap = {\n  [CharacterState.IDLE]: {\n    url: Assets.animations['idle-00'].url,\n    loop: true,\n  },\n  [CharacterState.IDLE_01]: {\n    url: Assets.animations['idle-01'].url,\n    loop: true,\n  },\n  [CharacterState.WALK]: {\n    url: Assets.animations['walk'].url,\n    loop: true,\n  },\n  [CharacterState.RUN]: {\n    url: Assets.animations['run-medium'].url,\n    loop: true,\n  },\n  [CharacterState.FAST_RUN]: {\n    url: Assets.animations['run-fast'].url,\n    loop: true,\n  },\n  [CharacterState.JUMP]: {\n    url: Assets.animations['jump'].url,\n    loop: true,\n    clampWhenFinished: true,\n  },\n  [CharacterState.PUNCH]: {\n    url: Assets.animations['punch-00'].url,\n    loop: false,\n    duration: 0.5,\n    clampWhenFinished: true,\n  },\n  [CharacterState.PUNCH_01]: {\n    url: Assets.animations['punch-01'].url,\n    loop: false,\n    duration: 0.5,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK]: {\n    url: Assets.animations['kick-00'].url,\n    loop: false,\n    duration: 0.75,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK_01]: {\n    url: Assets.animations['kick-01'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.KICK_02]: {\n    url: Assets.animations['kick-02'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.MELEE_ATTACK]: {\n    url: Assets.animations['melee-attack'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.CAST]: {\n    url: Assets.animations['cast'].url,\n    loop: false,\n    duration: 1,\n    clampWhenFinished: true,\n  },\n  [CharacterState.HIT]: {\n    url: Assets.animations['hit-to-body'].url,\n    loop: false,\n    clampWhenFinished: false,\n  },\n  [CharacterState.DANCE]: {\n    url: Assets.animations['dance-wave'].url,\n    loop: false,\n    clampWhenFinished: false,\n  },\n  [CharacterState.SWIM]: {\n    url: Assets.animations['swim'].url,\n    loop: true,\n  },\n  [CharacterState.DIE]: {\n    url: Assets.animations['death-backward'].url,\n    loop: false,\n    clampWhenFinished: true,\n  },\n};\n\n/**\n * Player props\n */\ninterface PlayerProps {\n  /** Initial position of the player */\n  position?: Vector3;\n}\n\n/**\n * Player component that manages character model and animations\n *\n * Handles player state management and delegates rendering to CharacterRenderer.\n * Movement states come from ControllerStore, actions are handled locally.\n */\nconst Player = ({ position }: PlayerProps) => {\n  const { account } = useGameServer();\n  const { registerConnectedPlayer, unregisterConnectedPlayer } = useMultiPlayerStore();\n  const { setPosition: setLocalPlayerPosition } = useLocalPlayerStore();\n  const { getPlayerAction } = usePlayerActionStore();\n\n  // Use the new useCharacterAnimation hook\n  const { animationState, setAnimation, getAnimation } = useCharacterAnimation<CharacterState>(CharacterState.IDLE);\n\n  // Get movement state from controller store (unified API)\n  const { getCharacterMovementState, isControlLocked, lockControls, unlockControls } = useControllerStore();\n\n  // IMPORTANT: rigidBodyPlayerRef.current type is RigidBody\n  const rigidBodyPlayerRef = useRef<RigidBodyPlayerRef>(null);\n\n  // IMPORTANT: Register connected player reference\n  useEffect(() => {\n    if (!account) return;\n\n    registerConnectedPlayer(account, rigidBodyPlayerRef);\n\n    return () => {\n      unregisterConnectedPlayer(account);\n    };\n  }, [account, registerConnectedPlayer, unregisterConnectedPlayer]);\n\n  // IMPORTANT: Update local player store position information\n  useFrame(() => {\n    const playerRigidBody = rigidBodyPlayerRef.current;\n    if (!playerRigidBody) return;\n\n    const position = playerRigidBody.translation();\n    setLocalPlayerPosition(position.x, position.y, position.z);\n  });\n\n  // Helper functions\n  const canInterrupt = useCallback((state: CharacterState): boolean => {\n    return INTERRUPTIBLE_STATES.includes(state);\n  }, []);\n\n  // Convert ControllerStore state to Player animation state\n  const toCharacterState = useCallback((characterMovementState: CharacterMovementState): CharacterState => {\n    switch (characterMovementState) {\n      case CharacterMovementState.IDLE:\n        return CharacterState.IDLE;\n      case CharacterMovementState.WALKING:\n        return CharacterState.WALK;\n      case CharacterMovementState.RUN:\n        return CharacterState.RUN;\n      case CharacterMovementState.FAST_RUN:\n        return CharacterState.FAST_RUN;\n      case CharacterMovementState.AIRBORNE:\n        return CharacterState.JUMP;\n      default:\n        return CharacterState.IDLE;\n    }\n  }, []);\n\n  // Callback triggered when a non-looping animation finishes.\n  const handleAnimationComplete = useCallback(\n    (type: AnimationType) => {\n      unlockControls();\n      switch (type) {\n        case CharacterState.PUNCH:\n        case CharacterState.PUNCH_01:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.KICK:\n        case CharacterState.KICK_01:\n        case CharacterState.KICK_02:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.CAST:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.HIT:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.MELEE_ATTACK:\n          setAnimation(CharacterState.IDLE_01);\n          break;\n        case CharacterState.DANCE:\n          setAnimation(CharacterState.IDLE);\n          break;\n        default:\n          break;\n      }\n    },\n    [unlockControls, setAnimation],\n  );\n\n  const updatePlayerState = useCallback((): void => {\n    const currentState = getAnimation();\n\n    // If controls are locked, don't process actions\n    if (isControlLocked()) {\n      return;\n    }\n\n    // Handle death and revive states\n    // TODO: Connect with actual game state\n    // const isRevive = playerHealth > 0 && currentState === CharacterState.DIE;\n    // const isDying = playerHealth <= 0 && currentState !== CharacterState.DIE;\n\n    // Currently using placeholder false values\n    const isRevive = false;\n    const isDying = false;\n\n    // Revive handling: when health is restored while in death state\n    if (isRevive) {\n      setAnimation(CharacterState.IDLE);\n      return;\n    }\n\n    // Death handling: when health drops to 0 or below\n    if (isDying) {\n      setAnimation(CharacterState.DIE);\n      return;\n    }\n\n    // Handle action states (punch, kick, etc.) - highest priority\n    if (getPlayerAction('punch') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.PUNCH);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('kick') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.KICK);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('meleeAttack') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.MELEE_ATTACK);\n      lockControls();\n      return;\n    }\n\n    if (getPlayerAction('cast') && canInterrupt(currentState)) {\n      setAnimation(CharacterState.CAST);\n      lockControls();\n      return;\n    }\n\n    // For movement states, use ControllerStore state\n    if (canInterrupt(currentState)) {\n      const characterMovementState = getCharacterMovementState();\n      const characterState = toCharacterState(characterMovementState);\n      setAnimation(characterState);\n    }\n  }, [isControlLocked, canInterrupt, lockControls, getCharacterMovementState, toCharacterState, getAnimation, setAnimation, getPlayerAction]);\n\n  // Update player action state based on inputs and physics\n  useFrame(() => {\n    if (!rigidBodyPlayerRef.current) return;\n    updatePlayerState();\n  });\n\n  /** handleTriggerEnter: Called when the player intersects or collides with another object.\n   * - Handles when entering a specific area or colliding with another object\n   */\n  const handleTriggerEnter = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when entering a specific area or colliding with another object\n    }\n  };\n\n  /** handleTriggerExit: Called when the player exits an intersection or ends a collision with another object.\n   * - Handles when exiting a specific area or when collision with another object ends\n   */\n  const handleTriggerExit = (payload: CollisionPayload) => {\n    if (payload.other.rigidBody?.userData?.['type']) {\n      // TODO: Handle when exiting a specific area or when collision with another object ends\n    }\n  };\n\n  return (\n    <RigidBodyPlayer\n      ref={rigidBodyPlayerRef}\n      userData={{ account, type: RigidBodyObjectType.LOCAL_PLAYER }}\n      position={position}\n      targetHeight={targetHeight}\n      onTriggerEnter={handleTriggerEnter}\n      onTriggerExit={handleTriggerExit}\n    >\n      <CharacterRenderer\n        visible={false}\n        url={Assets.characters['base-model'].url}\n        animationConfigMap={animationConfigMap}\n        animationState={animationState}\n        targetHeight={targetHeight}\n        onAnimationComplete={handleAnimationComplete}\n      />\n    </RigidBodyPlayer>\n  );\n};\n\nexport default Player;\n",
    isBinary: false,
  },
  'src/components/r3f/InstancedCube.tsx': {
    type: 'file',
    content:
      "import { useRef, useEffect, useMemo, useState, useCallback } from 'react';\nimport * as THREE from 'three';\nimport { ThreeEvent, useFrame, useThree } from '@react-three/fiber';\nimport { RigidBody, TrimeshCollider } from '@react-three/rapier';\nimport useCubeStore from '../../stores/cubeStore';\nimport { getColorByFace, getTileTypeFromIndex } from '../../utils/colorUtils';\n\n// Maximum number of cube instances\nconst MAX_INSTANCES = 1000000;\n\n// Chunk size definition\nconst CHUNK_SIZE = 10;\n// Active chunk radius\nconst ACTIVE_CHUNKS_RADIUS = 3;\n// Maximum active chunks limit\nconst MAX_ACTIVE_CHUNKS = 27; // 3x3x3 area\n\n// Shader that supports different colors for each face\nconst vertexShader = `\n  attribute vec3 colorTop;\n  attribute vec3 colorBottom;\n  attribute vec3 colorFront;\n  attribute vec3 colorBack;\n  attribute vec3 colorLeft;\n  attribute vec3 colorRight;\n  \n  varying vec3 vColor;\n  varying vec3 vNormal;\n  varying vec2 vUv; // UV coordinates\n  \n  void main() {\n    // Pass normal\n    vNormal = normalize(normalMatrix * normal);\n    \n    // Calculate appropriate UV coordinates based on face direction\n    if (abs(normal.y) > 0.9) {\n      // Top/bottom face - use xz plane\n      vUv = vec2(position.x + 0.5, position.z + 0.5);\n    } else if (abs(normal.x) > 0.9) {\n      // Left/right face - use zy plane\n      vUv = vec2(position.z + 0.5, position.y + 0.5);\n    } else {\n      // Front/back face - use xy plane\n      vUv = vec2(position.x + 0.5, position.y + 0.5);\n    }\n    \n    // Select color based on face\n    if (abs(normal.y) > 0.9) {\n      // Top/bottom face\n      vColor = normal.y > 0.0 ? colorTop : colorBottom;\n    } else if (abs(normal.x) > 0.9) {\n      // Left/right face\n      vColor = normal.x > 0.0 ? colorRight : colorLeft;\n    } else if (abs(normal.z) > 0.9) {\n      // Front/back face\n      vColor = normal.z > 0.0 ? colorBack : colorFront;\n    }\n    \n    vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n  }\n`;\n\nconst fragmentShader = `\n  varying vec3 vColor;\n  varying vec3 vNormal;\n  varying vec2 vUv;\n  \n  void main() {\n    // Draw border: add border to all cube faces\n    float border = 0.025; // Border width\n    \n    // Check if current fragment is at edge\n    bool isEdge = vUv.x < border || vUv.x > 1.0 - border || \n                 vUv.y < border || vUv.y > 1.0 - border;\n    \n    // Simple directional lighting\n    float light = max(dot(vNormal, normalize(vec3(1.0, 3.0, 2.0))), 0.0) * 0.3 + 0.7;\n    \n    // Apply lighting to base color\n    vec3 litColor = vColor * light;\n    \n    // Apply border effect with subtle darkening\n    vec3 finalColor = isEdge ? litColor * 0.75 : litColor;\n    \n    // Output color\n    gl_FragColor = vec4(finalColor, 1.0);\n  }\n`;\n\n// Function to calculate chunk coordinates - 2D system (X, Z only)\nconst getChunkCoords = (position: [number, number, number]): [number, number] => {\n  return [Math.floor(position[0] / CHUNK_SIZE), Math.floor(position[2] / CHUNK_SIZE)];\n};\n\n// Function to generate chunk key (unique identifier) - 2D system\nconst getChunkKey = (chunkCoords: [number, number]): string => {\n  return `${chunkCoords[0]},${chunkCoords[1]}`;\n};\n\n// Type for cube data\ntype Cube = {\n  position: [number, number, number];\n  colorIndex: number;\n  chunkKey: string;\n};\n\n// Type for chunk data\ntype Chunk = {\n  key: string;\n  coords: [number, number]; // 2D coordinates (X, Z)\n  cubes: Cube[];\n  isActive: boolean;\n  distance: number; // Distance from camera\n  // Collision mesh data\n  vertices?: Float32Array;\n  indices?: Uint32Array;\n};\n\nconst InstancedCube = () => {\n  const instancedMeshRef = useRef<THREE.InstancedMesh>(null);\n  const { camera } = useThree();\n  const prevCameraChunkRef = useRef<string | null>(null);\n  const frameCountRef = useRef(0);\n  // Previous active chunks ref\n  const prevActiveChunksRef = useRef<Set<string>>(new Set());\n\n  // Camera chunk change detection state\n  const [cameraChunkTrigger, setCameraChunkTrigger] = useState<string | null>(null);\n\n  // RigidBody pooling state\n  const [rigidBodiesPool] = useState(() => new Map<string, boolean>());\n\n  // Get necessary data from the cube store\n  const cubes = useCubeStore((state) => state.cubes);\n  const addCube = useCubeStore((state) => state.addCube);\n  const selectedTile = useCubeStore((state) => state.selectedTile);\n\n  // Create shader material\n  const material = useMemo(() => {\n    return new THREE.ShaderMaterial({\n      vertexShader,\n      fragmentShader,\n      side: THREE.FrontSide,\n    });\n  }, []);\n\n  // Get current camera chunk (used in useFrame)\n  const getCurrentCameraChunk = useCallback(() => {\n    if (!camera) return null;\n    const cameraPosition = camera.position;\n    const chunkCoords = getChunkCoords([cameraPosition.x, cameraPosition.y, cameraPosition.z]);\n    return getChunkKey(chunkCoords);\n  }, [camera]);\n\n  // Distance-based chunk sorting function\n  const sortChunksByDistance = useCallback((chunks: Chunk[], cameraPosition: THREE.Vector3): Chunk[] => {\n    return [...chunks].sort((a, b) => {\n      const centerA = new THREE.Vector3(\n        a.coords[0] * CHUNK_SIZE + CHUNK_SIZE / 2,\n        0, // Y Í∞íÏùÄ Í±∞Î¶¨ Í≥ÑÏÇ∞ÏóêÏÑú Ï†úÏô∏\n        a.coords[1] * CHUNK_SIZE + CHUNK_SIZE / 2,\n      );\n\n      const centerB = new THREE.Vector3(\n        b.coords[0] * CHUNK_SIZE + CHUNK_SIZE / 2,\n        0, // Y Í∞íÏùÄ Í±∞Î¶¨ Í≥ÑÏÇ∞ÏóêÏÑú Ï†úÏô∏\n        b.coords[1] * CHUNK_SIZE + CHUNK_SIZE / 2,\n      );\n\n      const cameraPosXZ = new THREE.Vector3(cameraPosition.x, 0, cameraPosition.z);\n      const distA = centerA.distanceTo(cameraPosXZ);\n      const distB = centerB.distanceTo(cameraPosXZ);\n\n      return distA - distB;\n    });\n  }, []);\n\n  // Monitor camera position and trigger only when crossing chunk boundaries\n  useFrame(() => {\n    const currentChunk = getCurrentCameraChunk();\n\n    // Update trigger only when chunk changes\n    if (currentChunk !== prevCameraChunkRef.current) {\n      prevCameraChunkRef.current = currentChunk;\n      setCameraChunkTrigger(currentChunk);\n    }\n\n    // Update only every 3 frames (reduce unnecessary calculations)\n    frameCountRef.current = (frameCountRef.current + 1) % 3;\n  });\n\n  // Calculate active chunks based on camera position - 2D system\n  const activeChunks = useMemo(() => {\n    if (!camera || !cameraChunkTrigger) return new Set<string>();\n\n    const cameraPosition = camera.position;\n    const centerChunk = getChunkCoords([cameraPosition.x, cameraPosition.y, cameraPosition.z]);\n    const activeChunkSet = new Set<string>();\n\n    // Distance calculation for circular activation area (using squared distance to avoid sqrt)\n    const radius = ACTIVE_CHUNKS_RADIUS;\n    const maxDistSq = radius * CHUNK_SIZE * (radius * CHUNK_SIZE);\n\n    // Activate base area - 2D system (X, Z only)\n    for (let x = -radius; x <= radius; x++) {\n      for (let z = -radius; z <= radius; z++) {\n        const chunkCoords: [number, number] = [centerChunk[0] + x, centerChunk[1] + z];\n\n        // Distance-based activation: exclude corner chunks too far from center\n        const chunkCenter = new THREE.Vector3(\n          chunkCoords[0] * CHUNK_SIZE + CHUNK_SIZE / 2,\n          0, // Y Í∞íÏùÄ Í±∞Î¶¨ Í≥ÑÏÇ∞ÏóêÏÑú Ï†úÏô∏\n          chunkCoords[1] * CHUNK_SIZE + CHUNK_SIZE / 2,\n        );\n\n        const cameraPosXZ = new THREE.Vector3(cameraPosition.x, 0, cameraPosition.z);\n        const distSq = chunkCenter.distanceToSquared(cameraPosXZ);\n        if (distSq <= maxDistSq) {\n          activeChunkSet.add(getChunkKey(chunkCoords));\n        }\n      }\n    }\n\n    // Store calculated result\n    prevActiveChunksRef.current = activeChunkSet;\n    return activeChunkSet;\n  }, [camera, cameraChunkTrigger]); // Recalculate only when camera chunk changes\n\n  // Organize cubes into chunks - optimized version\n  const chunks = useMemo(() => {\n    const chunkMap = new Map<string, Chunk>();\n    const cameraPosition = camera?.position || new THREE.Vector3();\n\n    // Construct chunk data\n    cubes.forEach((cube) => {\n      const chunkCoords = getChunkCoords(cube.position);\n      const chunkKey = getChunkKey(chunkCoords);\n      const isActive = activeChunks.has(chunkKey);\n\n      if (!chunkMap.has(chunkKey)) {\n        // Calculate chunk center - 2D system\n        const chunkCenter = new THREE.Vector3(\n          chunkCoords[0] * CHUNK_SIZE + CHUNK_SIZE / 2,\n          0, // Y Í∞íÏùÄ Í±∞Î¶¨ Í≥ÑÏÇ∞ÏóêÏÑú Ï†úÏô∏\n          chunkCoords[1] * CHUNK_SIZE + CHUNK_SIZE / 2,\n        );\n\n        // Calculate distance from camera (2D distance)\n        const cameraPosXZ = new THREE.Vector3(cameraPosition.x, 0, cameraPosition.z);\n        const distance = chunkCenter.distanceTo(cameraPosXZ);\n\n        chunkMap.set(chunkKey, {\n          key: chunkKey,\n          coords: chunkCoords,\n          cubes: [],\n          isActive,\n          distance,\n        });\n      }\n\n      chunkMap.get(chunkKey)!.cubes.push({\n        ...cube,\n        colorIndex: cube.tileIndex,\n        chunkKey,\n      });\n    });\n\n    // Return distance-sorted chunk array\n    const allChunks = Array.from(chunkMap.values());\n    const sortedChunks = sortChunksByDistance(allChunks, cameraPosition);\n\n    // Activate only nearby chunks and generate mesh data to limit RigidBody count\n    const finalChunks = sortedChunks.map((chunk, index) => {\n      const isActiveChunk = index < MAX_ACTIVE_CHUNKS ? activeChunks.has(chunk.key) : false;\n\n      // Generate collision mesh data only for active chunks\n      let vertices: Float32Array | undefined;\n      let indices: Uint32Array | undefined;\n\n      if (isActiveChunk && chunk.cubes.length > 0) {\n        // Optimization: Create cube position map for fast lookups\n        const cubePositionMap = new Map<string, boolean>();\n        chunk.cubes.forEach((cube) => {\n          const key = `${Math.floor(cube.position[0])},${Math.floor(cube.position[1])},${Math.floor(cube.position[2])}`;\n          cubePositionMap.set(key, true);\n        });\n\n        // Single cube vertex data (cube center at origin)\n        const cubeVertices = new Float32Array([\n          -0.5,\n          -0.5,\n          -0.5, // 0\n          0.5,\n          -0.5,\n          -0.5, // 1\n          0.5,\n          0.5,\n          -0.5, // 2\n          -0.5,\n          0.5,\n          -0.5, // 3\n          -0.5,\n          -0.5,\n          0.5, // 4\n          0.5,\n          -0.5,\n          0.5, // 5\n          0.5,\n          0.5,\n          0.5, // 6\n          -0.5,\n          0.5,\n          0.5, // 7\n        ]);\n\n        // Face-based index data - defined by face to add only necessary faces\n        const faceIndices = [\n          [0, 1, 2, 0, 2, 3], // Front face (z-)\n          [1, 5, 6, 1, 6, 2], // Right face (x+)\n          [5, 4, 7, 5, 7, 6], // Back face (z+)\n          [4, 0, 3, 4, 3, 7], // Left face (x-)\n          [3, 2, 6, 3, 6, 7], // Top face (y+)\n          [4, 5, 1, 4, 1, 0], // Bottom face (y-)\n        ];\n\n        // Temporary arrays (add only actually used data here)\n        const tempVertices: number[] = [];\n        const tempIndices: number[] = [];\n\n        let vertexOffset = 0; // Current vertex index offset\n\n        chunk.cubes.forEach((cube) => {\n          const [x, y, z] = [Math.floor(cube.position[0]), Math.floor(cube.position[1]), Math.floor(cube.position[2])];\n\n          // Check which faces are hidden by other cubes\n          const hiddenFaces = [\n            cubePositionMap.has(`${x},${y},${z - 1}`), // Front face\n            cubePositionMap.has(`${x + 1},${y},${z}`), // Right face\n            cubePositionMap.has(`${x},${y},${z + 1}`), // Back face\n            cubePositionMap.has(`${x - 1},${y},${z}`), // Left face\n            cubePositionMap.has(`${x},${y + 1},${z}`), // Top face\n            cubePositionMap.has(`${x},${y - 1},${z}`), // Bottom face\n          ];\n\n          // Add all vertices for this cube\n          for (let j = 0; j < cubeVertices.length; j += 3) {\n            tempVertices.push(cubeVertices[j] + cube.position[0], cubeVertices[j + 1] + cube.position[1], cubeVertices[j + 2] + cube.position[2]);\n          }\n\n          // Add indices only for visible faces\n          for (let faceIdx = 0; faceIdx < 6; faceIdx++) {\n            if (!hiddenFaces[faceIdx]) {\n              // This face is visible, add indices\n              for (const idx of faceIndices[faceIdx]) {\n                tempIndices.push(idx + vertexOffset);\n              }\n            }\n          }\n\n          vertexOffset += 8; // 8 vertices per cube\n        });\n\n        // Convert optimized data to Float32Array and Uint32Array\n        vertices = new Float32Array(tempVertices);\n        indices = new Uint32Array(tempIndices);\n      }\n\n      return {\n        ...chunk,\n        isActive: isActiveChunk,\n        vertices,\n        indices,\n      };\n    });\n\n    return finalChunks;\n  }, [cubes, activeChunks, camera, sortChunksByDistance, cameraChunkTrigger]); // Recalculate only when camera chunk changes\n\n  // Calculate number of active and inactive chunks (for logging)\n  useEffect(() => {\n    const activeChunksCount = chunks.filter((chunk) => chunk.isActive).length;\n    const activeCount = chunks.filter((chunk) => chunk.isActive).reduce((acc, chunk) => acc + chunk.cubes.length, 0);\n    const inactiveCount = cubes.length - activeCount;\n\n    // Current camera chunk info\n    const cameraChunkInfo = camera\n      ? `Camera chunk: ${getChunkKey(getChunkCoords([camera.position.x, camera.position.y, camera.position.z]))}`\n      : 'No camera info';\n\n    // Calculate average cubes per chunk\n    const avgCubesPerChunk = chunks.length > 0 ? (cubes.length / chunks.length).toFixed(1) : 0;\n\n    // Limit log frequency\n    if (frameCountRef.current === 0) {\n      console.log(\n        `üìä Terrain stats:\\n` +\n          `- Active chunks: ${activeChunksCount}/${chunks.length} (${((activeChunksCount / chunks.length) * 100).toFixed(1)}%)\\n` +\n          `- Active cubes: ${activeCount}/${cubes.length} (${((activeCount / cubes.length) * 100).toFixed(1)}%)\\n` +\n          `- Avg cubes per chunk: ${avgCubesPerChunk}\\n` +\n          `- ${cameraChunkInfo}`,\n      );\n    }\n\n    // RigidBody pooling logic\n    chunks.forEach((chunk) => {\n      const key = chunk.key;\n      const isActive = chunk.isActive;\n\n      // Track newly activated chunks\n      if (isActive && !rigidBodiesPool.has(key)) {\n        rigidBodiesPool.set(key, true);\n      }\n      // Track deactivated chunks\n      else if (!isActive && rigidBodiesPool.has(key)) {\n        rigidBodiesPool.delete(key);\n      }\n    });\n  }, [chunks, cubes.length, rigidBodiesPool, camera, frameCountRef.current]);\n\n  // Update buffer attributes\n  useEffect(() => {\n    if (!instancedMeshRef.current) return;\n\n    const mesh = instancedMeshRef.current;\n    const count = Math.min(cubes.length, MAX_INSTANCES);\n\n    if (count % 100 === 0 || count < 100) {\n      console.log(`Updating color attributes for ${count} cubes`);\n    }\n\n    // Create color data arrays for each face\n    const colorTopArray = new Float32Array(MAX_INSTANCES * 3);\n    const colorBottomArray = new Float32Array(MAX_INSTANCES * 3);\n    const colorFrontArray = new Float32Array(MAX_INSTANCES * 3);\n    const colorBackArray = new Float32Array(MAX_INSTANCES * 3);\n    const colorLeftArray = new Float32Array(MAX_INSTANCES * 3);\n    const colorRightArray = new Float32Array(MAX_INSTANCES * 3);\n\n    // Set position matrix\n    const matrix = new THREE.Matrix4();\n    const quaternion = new THREE.Quaternion();\n    const scale = new THREE.Vector3(1, 1, 1);\n\n    // Set colors for each face of every cube\n    for (let i = 0; i < count; i++) {\n      const cube = cubes[i];\n      if (!cube) continue;\n\n      // Set color for each face - using cube's tileIndex directly\n      const colorTop = getColorByFace(cube.tileIndex, 4); // Top\n      const colorBottom = getColorByFace(cube.tileIndex, 5); // Bottom\n      const colorFront = getColorByFace(cube.tileIndex, 0); // Front\n      const colorBack = getColorByFace(cube.tileIndex, 2); // Back\n      const colorLeft = getColorByFace(cube.tileIndex, 3); // Left\n      const colorRight = getColorByFace(cube.tileIndex, 1); // Right\n\n      // Top face color\n      colorTopArray[i * 3] = colorTop.r;\n      colorTopArray[i * 3 + 1] = colorTop.g;\n      colorTopArray[i * 3 + 2] = colorTop.b;\n\n      // Bottom face color\n      colorBottomArray[i * 3] = colorBottom.r;\n      colorBottomArray[i * 3 + 1] = colorBottom.g;\n      colorBottomArray[i * 3 + 2] = colorBottom.b;\n\n      // Front face color\n      colorFrontArray[i * 3] = colorFront.r;\n      colorFrontArray[i * 3 + 1] = colorFront.g;\n      colorFrontArray[i * 3 + 2] = colorFront.b;\n\n      // Back face color\n      colorBackArray[i * 3] = colorBack.r;\n      colorBackArray[i * 3 + 1] = colorBack.g;\n      colorBackArray[i * 3 + 2] = colorBack.b;\n\n      // Left face color\n      colorLeftArray[i * 3] = colorLeft.r;\n      colorLeftArray[i * 3 + 1] = colorLeft.g;\n      colorLeftArray[i * 3 + 2] = colorLeft.b;\n\n      // Right face color\n      colorRightArray[i * 3] = colorRight.r;\n      colorRightArray[i * 3 + 1] = colorRight.g;\n      colorRightArray[i * 3 + 2] = colorRight.b;\n\n      // Set position matrix\n      const position = new THREE.Vector3().fromArray(cube.position);\n      matrix.compose(position, quaternion, scale);\n      mesh.setMatrixAt(i, matrix);\n    }\n\n    // Update or create buffer attributes\n    updateInstancedAttribute(mesh, 'colorTop', colorTopArray, 3);\n    updateInstancedAttribute(mesh, 'colorBottom', colorBottomArray, 3);\n    updateInstancedAttribute(mesh, 'colorFront', colorFrontArray, 3);\n    updateInstancedAttribute(mesh, 'colorBack', colorBackArray, 3);\n    updateInstancedAttribute(mesh, 'colorLeft', colorLeftArray, 3);\n    updateInstancedAttribute(mesh, 'colorRight', colorRightArray, 3);\n\n    // Update instance matrix\n    mesh.count = count;\n    mesh.instanceMatrix.needsUpdate = true;\n  }, [cubes]);\n\n  // Helper function to update instanced attributes\n  const updateInstancedAttribute = (mesh: THREE.InstancedMesh, name: string, array: Float32Array, itemSize: number) => {\n    if (mesh.geometry.getAttribute(name)) {\n      (mesh.geometry.getAttribute(name) as THREE.BufferAttribute).set(array);\n      (mesh.geometry.getAttribute(name) as THREE.BufferAttribute).needsUpdate = true;\n    } else {\n      mesh.geometry.setAttribute(name, new THREE.InstancedBufferAttribute(array, itemSize));\n    }\n  };\n\n  // Cube click handler\n  const handleCubeClick = (e: ThreeEvent<MouseEvent>) => {\n    e.stopPropagation();\n    if (typeof e.instanceId !== 'number') return;\n\n    const clickedCube = cubes[e.instanceId];\n    if (!clickedCube) return;\n\n    const { position } = clickedCube;\n    const faceIndex = Math.floor(e.faceIndex! / 2);\n\n    // Add new cube in the direction of the clicked face\n    const [x, y, z] = position;\n    const directions: [number, number, number][] = [\n      [x, y, z - 1], // Front\n      [x + 1, y, z], // Right\n      [x, y, z + 1], // Back\n      [x - 1, y, z], // Left\n      [x, y + 1, z], // Top\n      [x, y - 1, z], // Bottom\n    ];\n\n    addCube(...directions[faceIndex], selectedTile);\n  };\n\n  // Active chunks memoization\n  const activeChunksArray = useMemo(() => {\n    return chunks.filter((chunk) => chunk.isActive);\n  }, [chunks]);\n\n  // Don't render if there are no cubes\n  if (cubes.length === 0) {\n    return null;\n  }\n\n  return (\n    <>\n      {/* InstancedMesh for rendering all cubes */}\n      <instancedMesh\n        ref={instancedMeshRef}\n        args={[undefined, undefined, cubes.length]}\n        castShadow\n        receiveShadow\n        frustumCulled={true}\n        onClick={handleCubeClick}\n        userData={{ isCube: true }}\n      >\n        <boxGeometry args={[1, 1, 1]} />\n        {material && <primitive object={material} />}\n      </instancedMesh>\n\n      {/* Create one TrimeshCollider per active chunk */}\n      {activeChunksArray\n        .filter((chunk) => chunk.vertices && chunk.indices)\n        .map((chunk) => (\n          <RigidBody key={chunk.key} type=\"fixed\" colliders={false} userData={{ type: 'cubeChunk', chunkKey: chunk.key }}>\n            <TrimeshCollider args={[chunk.vertices!, chunk.indices!]} />\n          </RigidBody>\n        ))}\n    </>\n  );\n};\n\nexport default InstancedCube;\n",
    isBinary: false,
  },
  'src/components/r3f/Water.tsx': {
    type: 'file',
    content:
      "import { useRef } from 'react';\nimport { Mesh } from 'three';\n\n// Renamed from Floor to Sea and positioned in the middle of the terrain\nconst Water = () => {\n  const meshRef = useRef<Mesh>(null);\n\n  // Position in the middle of the terrain (baseHeight + amplitude/2 = about 15)\n  const seaLevel = 10;\n\n  return (\n    <mesh ref={meshRef} receiveShadow position={[0, seaLevel, 0]} rotation-x={-Math.PI / 2} userData={{ type: 'fixed', isSea: true }}>\n      <planeGeometry args={[1000, 1000]} />\n      <meshStandardMaterial\n        color=\"#0077be\" // Sea color\n        transparent={true}\n        opacity={0.6} // Semi-transparent\n      />\n    </mesh>\n  );\n};\n\nexport default Water;\n",
    isBinary: false,
  },
  'src/components/r3f/MapPhysicsReadyChecker.tsx': {
    type: 'file',
    content:
      "import { useFrame } from '@react-three/fiber';\nimport { useRapier } from '@react-three/rapier';\nimport { useRef } from 'react';\nimport * as THREE from 'three';\nimport { useGameStore } from '../../stores/gameStore';\n\n/**\n * Component that checks if the map physics is ready by performing raycasting.\n * Casts a ray downward from above to detect map geometry and ensures physics\n * interactions are properly initialized before gameplay begins.\n *\n * - Performs checks every frame until map physics is confirmed ready\n * - Times out after 60 frames as fallback to prevent infinite checking\n * - Excludes Capsule shapes (likely characters/objects) and sensor colliders\n * - Sets mapPhysicsReady to true once valid map geometry is detected\n */\nfunction MapPhysicsReadyChecker() {\n  const { isMapPhysicsReady, setMapPhysicsReady } = useGameStore();\n  const physicsCheckCount = useRef(0);\n  const { rapier, world } = useRapier();\n\n  useFrame(() => {\n    if (isMapPhysicsReady) return;\n\n    physicsCheckCount.current++;\n    if (physicsCheckCount.current > 180) {\n      setMapPhysicsReady(true);\n      return;\n    }\n\n    const origin = new THREE.Vector3(0, 50, 0);\n    const downDirection = new THREE.Vector3(0, -1, 0);\n    const ray = new rapier.Ray(origin, downDirection);\n\n    // Get all intersections and find the first non-sensor collider\n    const intersections: any[] = [];\n    world.propagateModifiedBodyPositionsToColliders();\n    world.updateSceneQueries();\n    world.intersectionsWithRay(ray, 100, true, (intersection) => {\n      // Exclude Capsule shapes as they are unlikely to be map colliders\n      if (intersection.collider.shape.type === rapier.ShapeType.Capsule) {\n        return true;\n      }\n      intersections.push(intersection);\n      return true; // continue searching\n    });\n\n    // Find the first non-sensor collider\n    const validHit = intersections.find((intersection) => !intersection.collider.isSensor());\n    if (!validHit) return;\n\n    console.log('%c[vibe-starter-3d]%c Map physics initialized.', 'color: #7159c1; font-weight: bold', 'color: inherit;');\n    setMapPhysicsReady(true);\n  });\n\n  return null;\n}\n\nexport default MapPhysicsReadyChecker;\n",
    isBinary: false,
  },
  'src/components/r3f/SingleCube.tsx': {
    type: 'file',
    content:
      'import { useRef } from \'react\';\nimport * as THREE from \'three\';\nimport { getColorByFace, getThreeColor } from \'../../utils/colorUtils\';\n\ninterface SingleCubeProps {\n  tileIndex: number;\n  scale?: number;\n  position?: [number, number, number];\n  rotation?: [number, number, number];\n  opacity?: number;\n}\n\n// Single cube rendering component\nconst SingleCube: React.FC<SingleCubeProps> = ({ tileIndex, scale = 1, position = [0, 0, 0], rotation = [0.5, 0.8, 0], opacity = 1 }) => {\n  const meshRef = useRef<THREE.Mesh>(null);\n\n  // Calculate cube face colors (0: front, 1: right, 2: back, 3: left, 4: top, 5: bottom)\n  const colorFront = getColorByFace(tileIndex, 0); // front\n  const colorRight = getColorByFace(tileIndex, 1); // right\n  const colorBack = getColorByFace(tileIndex, 2); // back\n  const colorLeft = getColorByFace(tileIndex, 3); // left\n  const colorTop = getColorByFace(tileIndex, 4); // top\n  const colorBottom = getColorByFace(tileIndex, 5); // bottom\n\n  // Create materials for each face with improved transparency\n  const createMaterial = (color: { r: number; g: number; b: number }) => {\n    if (opacity < 1) {\n      // For translucent preview mode\n      return new THREE.MeshBasicMaterial({\n        color: getThreeColor(color),\n        transparent: true,\n        opacity: opacity,\n        depthWrite: false,\n        side: THREE.DoubleSide,\n      });\n    } else {\n      // For normal mode\n      return new THREE.MeshStandardMaterial({\n        color: getThreeColor(color),\n        transparent: false,\n      });\n    }\n  };\n\n  // Using custom materials for better transparency\n  return (\n    <mesh ref={meshRef} scale={[scale, scale, scale]} position={position} rotation={rotation}>\n      <boxGeometry args={[1, 1, 1]} />\n      <group>\n        {/* Front */}\n        <mesh position={[0, 0, 0.51]} renderOrder={opacity < 1 ? 1000 : 0}>\n          <planeGeometry args={[1, 1]} />\n          <primitive object={createMaterial(colorFront)} attach="material" />\n        </mesh>\n\n        {/* Back */}\n        <mesh position={[0, 0, -0.51]} rotation={[0, Math.PI, 0]} renderOrder={opacity < 1 ? 1000 : 0}>\n          <planeGeometry args={[1, 1]} />\n          <primitive object={createMaterial(colorBack)} attach="material" />\n        </mesh>\n\n        {/* Right */}\n        <mesh position={[0.51, 0, 0]} rotation={[0, Math.PI / 2, 0]} renderOrder={opacity < 1 ? 1000 : 0}>\n          <planeGeometry args={[1, 1]} />\n          <primitive object={createMaterial(colorRight)} attach="material" />\n        </mesh>\n\n        {/* Left */}\n        <mesh position={[-0.51, 0, 0]} rotation={[0, -Math.PI / 2, 0]} renderOrder={opacity < 1 ? 1000 : 0}>\n          <planeGeometry args={[1, 1]} />\n          <primitive object={createMaterial(colorLeft)} attach="material" />\n        </mesh>\n\n        {/* Top */}\n        <mesh position={[0, 0.51, 0]} rotation={[-Math.PI / 2, 0, 0]} renderOrder={opacity < 1 ? 1000 : 0}>\n          <planeGeometry args={[1, 1]} />\n          <primitive object={createMaterial(colorTop)} attach="material" />\n        </mesh>\n\n        {/* Bottom */}\n        <mesh position={[0, -0.51, 0]} rotation={[Math.PI / 2, 0, 0]} renderOrder={opacity < 1 ? 1000 : 0}>\n          <planeGeometry args={[1, 1]} />\n          <primitive object={createMaterial(colorBottom)} attach="material" />\n        </mesh>\n      </group>\n    </mesh>\n  );\n};\n\nexport default SingleCube;\n',
    isBinary: false,
  },
} as FileMap;

export const TEMPLATE_BASIC = TEMPLATE_BASIC_VITE_REACT;

export const TEMPLATE_MAP: Record<string, FileMap> = {
  'basic-vite-react': TEMPLATE_BASIC_VITE_REACT,
  '2d-phaser-basic': TEMPLATE_2D_PHASER_BASIC,
  '2d-phaser-sprite-character-gravity': TEMPLATE_2D_PHASER_SPRITE_CHARACTER_GRAVITY,
  'basic-3d': TEMPLATE_3D_BASIC,
  'basic-3d-freeview': TEMPLATE_3D_BASIC_FREEVIEW,
  'basic-3d-quarterview': TEMPLATE_3D_BASIC_QUARTERVIEW,
  'basic-3d-flightview': TEMPLATE_3D_BASIC_FLIGHTVIEW,
  'basic-3d-firstpersonview': TEMPLATE_3D_BASIC_FIRSTPERSONVIEW,
  'basic-3d-sideview': TEMPLATE_3D_BASIC_SIDEVIEW,
  'basic-3d-minecraft': TEMPLATE_3D_BASIC_MINECRAFT,
};
